The following text is a Git repository with code. The structure of the text are sections that begin with ----, followed by a single line containing the file path and file name, followed by a variable amount of lines containing the file contents. The text representing the Git repository ends when the symbols --END-- are encounted. Any further text beyond --END-- are meant to be interpreted as instructions using the aforementioned Git repository as context.
----
_meta.json
{
  "index": "Quickstart",
  "concepts": "Concepts",
  "getting-started": "Getting Started",
  "customization": "Customizing React Flow",
  "layouting": "Layouting",
  "advanced-use": "Advanced Use",
  "tutorials": {
    "title": "Tutorials",
    "theme": {
      "layout": "raw"
    }
  },
  "troubleshooting": "Troubleshooting",
  "api-link": {
    "title": "API Reference",
    "href": "/api-reference"
  }
}

----
index.mdx
---
title: Quickstart
description: React Flow quickstart that shows how to install the package, use it and where to find example apps
sidebar_position: 1
pagination_next: null
---

# Quickstart

import { Tab, Tabs, Cards, Card } from 'nextra/components';

import { Emoji } from '@xyflow/xy-ui';
import { ReactPlayer } from 'xy-shared';
import ExampleViewer from '@/components/example-viewer';

If you want to get up-and-running as soon as possible you're in the right place!
This page will take you from zero to a working React Flow app in a few minutes.
From there, you can take a deeper look at what React Flow is all about, check out
the examples, or dive into the API docs.

## React Flow in 60 seconds

<div style={{ position: 'relative', paddingTop: '56.25%' }}>
  <ReactPlayer
    controls
    url="https://www.youtube.com/watch?v=aUBWE41a900"
    width="100%"
    height="100%"
    style={{ position: 'absolute', top: 0, left: 0 }}
  />
</div>

## Play online

You can try React Flow without setting anything up locally by checking out the
starter projects we have on [CodeSandbox](https://codesandbox.io/):

<Cards num={2}>
  <Card
    title="new.reactflow.dev/js"
    href="https://new.reactflow.dev/js"
    icon={
      <div className="rounded-full w-10 h-10 bg-yellow-200 text-gray-700 font-black flex items-center justify-center">
        JS
      </div>
    }
  />
  <Card
    title="new.reactflow.dev/ts"
    href="https://new.reactflow.dev/ts"
    icon={
      <div className="rounded-full w-10 h-10 bg-blue-500 text-white font-black flex items-center justify-center">
        TS
      </div>
    }
  />
</Cards>

## Vite template

If you want to get started right away, you can use our [vite template](https://github.com/xyflow/vite-react-flow-template):

```bash copy
npx degit xyflow/vite-react-flow-template app-name
```

## Installation

To get started locally you should have a few things:

- [Node.js](https://nodejs.org/en/) installed.
- Either npm or another package manager like [yarn](https://yarnpkg.com/) or
  [pnpm](https://pnpm.io/).
- A working knowledge of [React](https://reactjs.org/). You don't need to be an
  expert, but you should be comfortable with the basics.

First, spin up a new [React](https://reactjs.org/) project however you like; we
recommend using [Vite](https://vitejs.dev/) but the choice is yours.

<Tabs items={['npm', 'pnpm', 'yarn']}>
  <Tab>

```bash copy
npm create vite@latest my-react-flow-app -- --template react
```

  </Tab>
  <Tab >

```bash copy
pnpm create vite my-react-flow-app -- --template react
```

  </Tab>
  <Tab >

```bash copy
yarn create vite my-react-flow-app -- --template react
```

  </Tab>
</Tabs>

React Flow is published on npm as [`@xyflow/react`](https://npmjs.com/package/@xyflow/react), so go ahead and add it next.

<Tabs items={['npm', 'pnpm', 'yarn', 'bun']}>
  <Tab >

```bash copy
npm install @xyflow/react
```

  </Tab>
    <Tab >

```bash copy
pnpm add @xyflow/react
```

  </Tab>
  <Tab >

```bash copy
yarn add @xyflow/react
```

  </Tab>
  <Tab>

```bash copy
bun add @xyflow/react
```

</Tab>
</Tabs>

Lastly, spin up the dev server and we're good to go!

<Tabs items={['npm', 'pnpm', 'yarn', 'bun']}>
  <Tab>

```bash copy
npm run dev
```

  </Tab>
  <Tab>

```bash copy
pnpm dev
```

  </Tab>
  <Tab>

```bash copy
yarn dev
```

  </Tab>
  <Tab>

```bash copy
bun run dev
```

</Tab>
</Tabs>

## Creating your first flow

The `reactflow` package exports the `<ReactFlow />` component as the default export.
That and a handful of nodes and edges are all we need to get something going! Get
rid of everything inside `App.jsx` and add the following:

```jsx
import React from 'react';
import { ReactFlow } from '@xyflow/react';

import '@xyflow/react/dist/style.css';

const initialNodes = [
  { id: '1', position: { x: 0, y: 0 }, data: { label: '1' } },
  { id: '2', position: { x: 0, y: 100 }, data: { label: '2' } },
];
const initialEdges = [{ id: 'e1-2', source: '1', target: '2' }];

export default function App() {
  return (
    <div style={{ width: '100vw', height: '100vh' }}>
      <ReactFlow nodes={initialNodes} edges={initialEdges} />
    </div>
  );
}
```

There are a few things to pay attention to here:

- <Emoji content="🎨" /> You must import the React Flow stylesheet.
- <Emoji content="📐" /> The `<ReactFlow />` component must be wrapped in an element
  with a width and height.

## Adding interactivity

Graphs created with React Flow are fully interactive. We can move nodes around,
connect them together, delete them, ... To get the basic functionality we need
to add three things:

- A callback for what to do when [nodes change](/api-reference/react-flow#on-nodes-change).
- A callback for what to do when [edges change](/api-reference/react-flow#on-edges-change).
- A callback for what to do when nodes are [connected](/api-reference/react-flow#on-connect).

Fortunately for you, we provide some hooks to make this easy!

```jsx
import React, { useCallback } from 'react';
import {
  ReactFlow,
  useNodesState,
  useEdgesState,
  addEdge,
} from '@xyflow/react';

import '@xyflow/react/dist/style.css';

const initialNodes = [
  { id: '1', position: { x: 0, y: 0 }, data: { label: '1' } },
  { id: '2', position: { x: 0, y: 100 }, data: { label: '2' } },
];
const initialEdges = [{ id: 'e1-2', source: '1', target: '2' }];

export default function App() {
  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);
  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);

  const onConnect = useCallback(
    (params) => setEdges((eds) => addEdge(params, eds)),
    [setEdges],
  );

  return (
    <div style={{ width: '100vw', height: '100vh' }}>
      <ReactFlow
        nodes={nodes}
        edges={edges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        onConnect={onConnect}
      />
    </div>
  );
}
```

## Some extra goodies

Finally, React Flow ships with some plugins out of the box for things like a
[`<Minimap />`](/api-reference/components/minimap) or viewport
[`<Controls />`](/api-reference/components/controls).

```jsx
import React, { useCallback } from 'react';
import {
  ReactFlow,
  MiniMap,
  Controls,
  Background,
  useNodesState,
  useEdgesState,
  addEdge,
} from '@xyflow/react';

import '@xyflow/react/dist/style.css';

const initialNodes = [
  { id: '1', position: { x: 0, y: 0 }, data: { label: '1' } },
  { id: '2', position: { x: 0, y: 100 }, data: { label: '2' } },
];
const initialEdges = [{ id: 'e1-2', source: '1', target: '2' }];

export default function App() {
  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);
  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);

  const onConnect = useCallback(
    (params) => setEdges((eds) => addEdge(params, eds)),
    [setEdges],
  );

  return (
    <div style={{ width: '100vw', height: '100vh' }}>
      <ReactFlow
        nodes={nodes}
        edges={edges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        onConnect={onConnect}
      >
        <Controls />
        <MiniMap />
        <Background variant="dots" gap={12} size={1} />
      </ReactFlow>
    </div>
  );
}
```

<ExampleViewer
  codePath="api-flows/Quickstart"
  applyStyles={false}
  showEditor={false}
/>

<Emoji content="🎉" /> Et voila. You've already created your first interactive flow!
Check out the links below on where to head next.

## Next Steps

<Cards>
  <Card title="Concepts" href="/learn/concepts/introduction" />
  <Card title="Customization" href="/learn/customization/custom-nodes" />
  <Card title="Examples" href="/examples" />
  <Card title="API Reference" href="/api-reference" />
  <Card title="Discord" href="https://discord.gg/RVmnytFmGW" />
  <Card
    title="Template Projects"
    href="https://github.com/xyflow/react-flow-example-apps"
  />
</Cards>

----
tutorials.mdx
---
title: Tutorials
description: Tutorials and in-depth guides on how to build with React Flow.
---

import TutorialsPage from '@/sites/tutorials';

<TutorialsPage />

----
customization/_meta.json
{
  "custom-nodes": {
    "title": "Custom Nodes",
    "theme": {
      "pagination": false
    }
  },
  "node-props": {
    "title": "Custom Node Props",
    "href": "/api-reference/types/node-props"
  },
  "custom-edges": {
    "title": "Custom Edges",
    "theme": {
      "pagination": false
    }
  },
  "edge-props": {
    "title": "Custom Edge Props",
    "href": "/api-reference/types/edge-props"
  },
  "theming": {
    "title": "Theming",
    "theme": {
      "pagination": false
    }
  }
}

----
customization/custom-nodes.mdx
---
title: Custom Nodes
description: Custom nodes in React Flow are just React components. This guide shows you how to implement your own nodes complete with target/source handles.
---

# Custom Nodes

A powerful feature of React Flow is the ability to add custom nodes. Within your custom nodes you can render everything you want. You can define multiple source and target handles and render form inputs or charts for example. In this section we will implement a node with an input field that updates some text in another part of the application.

## Implementing the Custom Node

A custom node is a React component that is wrapped to provide basic functionality like selecting or dragging. From the wrapper component we are passing props like the position or the data besides [other props](/api-reference/types/node-props). Let's start to implement the `TextUpdaterNode`. We are using the [`Handle` component](/api-reference/components/handle) to be able to connect our custom node with other nodes and add an input field to the node:

```jsx
import { useCallback } from 'react';
import { Handle, Position } from '@xyflow/react';

const handleStyle = { left: 10 };

function TextUpdaterNode({ data }) {
  const onChange = useCallback((evt) => {
    console.log(evt.target.value);
  }, []);

  return (
    <>
      <Handle type="target" position={Position.Top} />
      <div>
        <label htmlFor="text">Text:</label>
        <input id="text" name="text" onChange={onChange} className="nodrag" />
      </div>
      <Handle type="source" position={Position.Bottom} id="a" />
      <Handle
        type="source"
        position={Position.Bottom}
        id="b"
        style={handleStyle}
      />
    </>
  );
}
```

As you see we've added the class name "nodrag" to the input. This prevents dragging within the input field and lets us select text for example.

## Adding the Node Type

You can add a new node type to React Flow by adding it to the `nodeTypes` prop. **It's important that the `nodeTypes` are memoized or defined outside of the component.** Otherwise React creates a new object on every render which leads to performance issues and bugs.

```jsx
const nodeTypes = useMemo(() => ({ textUpdater: TextUpdaterNode }), []);

return <ReactFlow nodeTypes={nodeTypes} />;
```

After defining your new node type, you can use it by using the `type` node option:

```js
const nodes = [
  {
    id: 'node-1',
    type: 'textUpdater',
    position: { x: 0, y: 0 },
    data: { value: 123 },
  },
];
```

After putting all together and adding some basic styles we get a custom node that prints text to the console:

import ExampleViewer from '@/components/example-viewer';

<ExampleViewer
  codePath="api-flows/CustomNode"
  applyStyles={false}
  options={{ editorHeight: 500, editorWidthPercentage: 45, wrapContent: true }}
  additionalFiles={['TextUpdaterNode.js', 'text-updater-node.css']}
/>

## Using Multiple Handles

As you can see we added two source handles to the node so that it has two outputs. If you want to connect other nodes with these specific handles, the node id is not enough but you also need to pass the specific handle id. In this case one handle has the id `"a"` and the other one `"b"`. Handle specific edges use the `sourceHandle` or `targetHandle` options that reference a handle within a node:

```js
const initialEdges = [
  { id: 'edge-1', source: 'node-1', sourceHandle: 'a', target: 'node-2' },
  { id: 'edge-2', source: 'node-1', sourceHandle: 'b', target: 'node-3' },
];
```

In this case the source node is `node-1` for both handles but the handle ids are different. One comes from handle id `"a"` and the other one from `"b"`. Both edges also have different target nodes:

<ExampleViewer
  codePath="api-flows/CustomNode2"
  applyStyles={false}
  options={{ editorHeight: 500, editorWidthPercentage: 45, wrapContent: true }}
  additionalFiles={['TextUpdaterNode.js', 'text-updater-node.css']}
/>

Note that if you are programmatically changing the position or number of handles in your custom node, you will need to use the [`useUpdateNodeInternals`](/api-reference/hooks/use-update-node-internals) hook to properly notify ReactFlow of changes. From here you should be able to build your custom nodes. In most cases we recommend to use custom nodes only. The built-in ones are just basic examples. You can find a list of the passed props and more information in the [custom node API section](/api-reference/types/node-props).

----
customization/custom-edges.mdx
---
title: Custom Edges
description:
  Like custom nodes, parts of a custom edge in React Flow are just React components.
  This guide shows you how to implement a custom edge with some additional controls.
---

import { Callout } from 'nextra/components';
import ExampleViewer from '@/components/example-viewer';
import { Image } from 'xy-shared';

# Custom edges

Like [custom nodes](/learn/customization/custom-nodes), parts of a custom edge in
React Flow are just React components: that means you can render anything you want
along an edge! This guide shows you how to implement a custom edge with some
additional controls.

## A basic custom edge

An edge isn't much use to us if it doesn't render a path between two connected
nodes. These paths are always SVG-based and are typically rendered using the
[`<BaseEdge />`](/api-reference/components/base-edge) component. To calculate
the actual SVG path to render, React Flow comes with some handy utility functions:

- [`getBezierPath`](/api-reference/utils/get-bezier-path)
- [`getSimpleBezierPath`](/api-reference/utils/get-simple-bezier-path)
- [`getSmoothStepPath`](/api-reference/utils/get-smooth-step-path)
- [`getStraightPath`](/api-reference/utils/get-straight-path)

To kick start our custom edge, we'll just render a straight path between the
source and target.

```jsx
import { BaseEdge, getStraightPath } from '@xyflow/react';

export default function CustomEdge({ id, sourceX, sourceY, targetX, targetY }) {
  const [edgePath] = getStraightPath({
    sourceX,
    sourceY,
    targetX,
    targetY,
  });

  return (
    <>
      <BaseEdge id={id} path={edgePath} />
    </>
  );
}
```

<Callout type="info">
  All the props passed to your custom edge component can be found in the API
  reference under the [`EdgeProps`](/api-reference/types/edge-props) type.
</Callout>

This gives us a straight edge that behaves the same as the default `"straight"`
[edge type](/api-reference/types/edge#default-edge-types). To use it, we also
need to update the [`edgeTypes`](/api-reference/react-flow#edge-types) prop on
the `<ReactFlow />` component.

It's important to define the `edgeTypes` object _outside of the component_ or to
use React's `useMemo` hook to prevent unnecessary re-renders. React Flow will
show a warning in the console if you forget to do this.

```jsx
import ReactFlow from '@xyflow/react'
import CustomEdge from './CustomEdge'


const edgeTypes = {
  'custom-edge': CustomEdge
}

export function Flow() {
  return <ReactFlow edgeTypes={edgeTypes} ... />
}
```

After defining the `edgeTypes` object, we can use our new custom edge by setting
the `type` field of an edge to `"custom-edge"`.

<ExampleViewer
  codePath="api-flows/CustomEdge"
  options={{ editorHeight: 500, editorWidthPercentage: 45, wrapContent: true }}
  additionalFiles={['CustomEdge.js']}
/>

## Adding an edge label

One of the more common uses for custom edges is rendering some controls or info
along an edge's path. In React Flow we call that an _edge label_ and unlike the
edge path, edge labels can be any React component!

To render a custom edge label we must wrap it in the
[`<EdgeLabelRenderer />`](/api-reference/components/edge-label-renderer) component.
This is necessary for performance reasons: the edge label renderer is a portal
to a single container that _all_ edge labels are rendered into.

Let's add a button to our custom edge that can be used to delete the edge it's
attached to:

```jsx
import {
  BaseEdge,
  EdgeLabelRenderer,
  getStraightPath,
  useReactFlow,
} from '@xyflow/react';

export default function CustomEdge({ id, sourceX, sourceY, targetX, targetY }) {
  const { setEdges } = useReactFlow();
  const [edgePath] = getStraightPath({
    sourceX,
    sourceY,
    targetX,
    targetY,
  });

  return (
    <>
      <BaseEdge id={id} path={edgePath} />
      <EdgeLabelRenderer>
        <button
          onClick={() => setEdges((edges) => edges.filter((e) => e.id !== id))}
        >
          delete
        </button>
      </EdgeLabelRenderer>
    </>
  );
}
```

If we try to use this edge now, we'll see that the button is rendered in the
centre of the flow (it might be hidden behind "Node A"). Because of the edge
label portal, we'll need to do some extra work to position the button ourselves.

<Image
  src="/img/learn/edge-label-renderer-position.png"
  alt="A screen shot of a simple flow. The edge label renderer is highlighted in
  the DOM inspector and the button is rendered in the centre of the flow."
/>

Fortunately, the path utils we've already seen can help us with this! Along with
the SVG path to render, these functions also return the `x` and `y` coordinates
of the path's midpoint. We can then use these coordinates to translate our custom
edge label's into the right position!

```jsx
export default function CustomEdge({ id, sourceX, sourceY, targetX, targetY }) {
  const { setEdges } = useReactFlow();
  const [edgePath, labelX, labelY] = getStraightPath({ ... });

  return (
    ...
        <button
          style={{
            position: 'absolute',
            transform: `translate(-50%, -50%) translate(${labelX}px, ${labelY}px)`,
            pointerEvents: 'all',
          }}
          className="nodrag nopan"
          onClick={() => {
            setEdges((es) => es.filter((e) => e.id !== id));
          }}
        >
    ...
  );
}
```

<Callout type="info">
  To make sure our edge labels are interactive and not just for presentation, it
  is important to add `pointer-events: all` to the label's style. This will ensure
  that the label is clickable.

And just like with interactive controls in custom nodes, we need to remember
to add the `nodrag` and `nopan` classes to the label to stop mouse events from
controlling the canvas.

</Callout>

Here's an interactive example with our updated custom edge. Clicking the delete
button will remove that edge from the flow. Creating a new edge will use the
custom node.

<ExampleViewer
  codePath="api-flows/CustomEdge2"
  options={{ editorHeight: 500, editorWidthPercentage: 45, wrapContent: true }}
  additionalFiles={['CustomEdge.js']}
/>

----
customization/theming.mdx
---
title: Theming
description: React Flow comes with a minimal default theme. It's common to overwrite the default styles with your own CSS or use third-party libraries like TailwindCSS or Styled Components.
created_at: 2024-07-01
---

import { Callout } from 'nextra/components';
import ExampleViewer from '@/components/example-viewer';

# Theming

React Flow has been built with deep customization in mind. Many of our users
fully transform the look and feel of React Flow to match their own brand or design
system. This guide will introduce you to the different ways you can customize
React Flow's appearance.

## Default styles

React Flow's default styles are enough to get going with the built-in nodes. They
provide some sensible defaults for styles like padding, border radius, and animated
edges. You can see what they look like below:

<ExampleViewer
  codePath="example-flows/DefaultStyle"
  showEditor={false}
  options={{ wrapContent: true }}
  editorHeight={500}
/>

You'll typically load these default styles by importing them in you `App.jsx`
file or other entry point:

```js
import '@xyflow/react/dist/style.css';
```

Without dipping into [custom nodes](/examples/nodes/custom-node) and
[edges](/examples/edges/custom-edges), there are three ways you can style
React Flow's basic look:

- Passing inline styles through `style` props
- Overriding the built-in classes with custom CSS
- Overriding the CSS variables React Flow uses

### Built in dark and light mode

You can chose one of the built-in color modes by using the `colorMode` prop ('dark', 'light' or 'system') as seen in the [dark mode example](/examples/styling/dark-mode).

```jsx
import ReactFlow from '@xyflow/react';

export default function Flow() {
  return <ReactFlow colorMode="dark" nodes={[...]} edges={[...]} />
}
```

When you use the `colorMode` prop, React Flow adds a class to the root element (`.react-flow`) that you can use to style your flow based on the color mode:

```css
.dark .react-flow__node {
  background: #777;
  color: white;
}

.light .react-flow__node {
  background: white;
  color: #111;
}
```

### Customizing with `style` props

The easiest way to start customising the look and feel of your flows is to use
the `style` prop found on many of React Flow's components to inline your own
CSS.

```jsx
import ReactFlow from '@xyflow/react'

const styles = {
  background: 'red',
  width: '100%',
  height: 300,
};

export default function Flow() {
  return <ReactFlow style={styles} nodes={[...]} edges={[...]} />
}
```

### CSS variables

If you don't want to replace the default styles entirely but just want to tweak
the overall look and feel, you can override some of the CSS variables we use
throughout the library.

These variables are mostly self-explanatory. Below is a table of all the variables
you might want to tweak and their default values for reference:

| Variable name                                      | Default                             |
| :------------------------------------------------- | :---------------------------------- |
| `--edge-stroke-default`                            | `#b1b1b7`                           |
| `--edge-stroke-width-default`                      | `1`                                 |
| `--edge-stroke-selected-default`                   | `#555`                              |
| `--connectionline-stroke-default`                  | `#b1b1b7`                           |
| `--connectionline-stroke-width-default`            | `1`                                 |
| `--attribution-background-color-default`           | `rgba(255, 255, 255, 0.5)`          |
| `--minimap-background-color-default`               | `#fff`                              |
| `--background-pattern-dot-color-default`           | `#91919a`                           |
| `--background-pattern-line-color-default`          | `#eee`                              |
| `--background-pattern-cross-color-default`         | `#e2e2e2`                           |
| `--node-color-default`                             | `inherit`                           |
| `--node-border-default`                            | `1px solid #1a192b`                 |
| `--node-background-color-default`                  | `#fff`                              |
| `--node-group-background-color-default`            | `rgba(240, 240, 240, 0.25)`         |
| `--node-boxshadow-hover-default`                   | `0 1px 4px 1px rgba(0, 0, 0, 0.08)` |
| `--node-boxshadow-selected-default`                | `0 0 0 0.5px #1a192b`               |
| `--handle-background-color-default`                | `#1a192b`                           |
| `--handle-border-color-default`                    | `#fff`                              |
| `--selection-background-color-default`             | `rgba(0, 89, 220, 0.08)`            |
| `--selection-border-default`                       | `1px dotted rgba(0, 89, 220, 0.8)`  |
| `--controls-button-background-color-default`       | `#fefefe`                           |
| `--controls-button-background-color-hover-default` | `#f4f4f4`                           |
| `--controls-button-color-default`                  | `inherit`                           |
| `--controls-button-color-hover-default`            | `inherit`                           |
| `--controls-button-border-color-default`           | `#eee`                              |
| `--controls-box-shadow-default`                    | `0 0 2px 1px rgba(0, 0, 0, 0.08)`   |

These variables are used to define the _defaults_ for the various elements of
React Flow. This means they can still be overriden by inline styles or custom
classes on a per-element basis.

### Overriding built-in classes

Some consider heavy use of inline styles to be an anti-pattern. In that case,
you can override the built-in classes that React Flow uses with your own CSS.
There are many classes attached to all sorts of elements in React Flow, but the
ones you'll likely want to override are listed below:

| Class name                         | Description                                                                              |
| :--------------------------------- | :--------------------------------------------------------------------------------------- |
| `.react-flow`                      | The outermost container                                                                  |
| `.react-flow__renderer`            | The inner container                                                                      |
| `.react-flow__zoompane`            | Zoom & pan pane                                                                          |
| `.react-flow__selectionpane`       | Selection pane                                                                           |
| `.react-flow__selection`           | User selection                                                                           |
| `.react-flow__edges`               | The element containing all edges in the flow                                             |
| `.react-flow__edge`                | Applied to each [`Edge`](/api-reference/types/edge) in the flow                          |
| `.react-flow__edge.selected`       | Added to an [`Edge`](/api-reference/types/edge) when selected                            |
| `.react-flow__edge.animated`       | Added to an [`Edge`](/api-reference/types/edge) when its `animated` prop is `true`       |
| `.react-flow__edge.updating`       | Added to an [`Edge`](/api-reference/types/edge) while it gets updated via `onReconnect`  |
| `.react-flow__edge-path`           | The SVG `<path />` element of an [`Edge`](/api-reference/types/edge)                     |
| `.react-flow__edge-text`           | The SVG `<text />` element of an [`Edge`](/api-reference/types/edge) label               |
| `.react-flow__edge-textbg`         | The SVG `<text />` element behind an [`Edge`](/api-reference/types/edge) label           |
| `.react-flow__connection`          | Applied to the current connection line                                                   |
| `.react-flow__connection-path`     | The SVG `<path />` of a connection line                                                  |
| `.react-flow__nodes`               | The element containing all nodes in the flow                                             |
| `.react-flow__node`                | Applied to each [`Node`](/api-reference/types/node) in the flow                          |
| `.react-flow__node.selected`       | Added to a [`Node`](/api-reference/types/node) when selected.                            |
| `.react-flow__node-default`        | Added when [`Node`](/api-reference/types/node) type is `"default"`                       |
| `.react-flow__node-input`          | Added when [`Node`](/api-reference/types/node) type is `"input"`                         |
| `.react-flow__node-output`         | Added when [`Node`](/api-reference/types/node) type is `"output"`                        |
| `.react-flow__nodesselection`      | Nodes selection                                                                          |
| `.react-flow__nodesselection-rect` | Nodes selection rect                                                                     |
| `.react-flow__handle`              | Applied to each [`<Handle />`](/api-reference/components/handle) component               |
| `.react-flow__handle-top`          | Applied when a handle's [`Position`](/api-reference/types/position) is set to `"top"`    |
| `.react-flow__handle-right`        | Applied when a handle's [`Position`](/api-reference/types/position) is set to `"right"`  |
| `.react-flow__handle-bottom`       | Applied when a handle's [`Position`](/api-reference/types/position) is set to `"bottom"` |
| `.react-flow__handle-left`         | Applied when a handle's [`Position`](/api-reference/types/position) is set to `"left"`   |
| `.react-flow__handle-connecting`   | Applied when a connection line is above a handle.                                        |
| `.react-flow__handle-valid`        | Applied when a connection line is above a handle **and** the connection is valid         |
| `.react-flow__background`          | Applied to the [`<Background />`](/api-reference/components/background) component        |
| `.react-flow__minimap`             | Applied to the [`<MiniMap />`](/api-reference/components/minimap) component              |
| `.react-flow__controls`            | Applied to the [`<Controls />`](/api-reference/components/controls) component            |

<Callout type="warning">
  Be careful if you go poking around the source code looking for other classes
  to override. Some classes are used internally and are required in order for
  the library to be functional. If you replace them you may end up with
  unexpected bugs or errors!
</Callout>

## Third-party solutions

You can choose to opt-out of React Flow's default styling altogether and use a
third-party styling solution instead. If you want to do this, you must make sure
you still import the base styles.

```js
import '@xyflow/react/dist/base.css';
```

<Callout type="warning">
  These base styles are **required** for React Flow to function correctly. If
  you don't import them or you override them with your own styles, some things
  might not work as expected!
</Callout>

<ExampleViewer
  codePath="example-flows/BaseStyle"
  showEditor={false}
  editorHeight={500}
/>

### Styled Components

Many of the components you render directly, such as the
[`<MiniMap />`](/api-reference/components/minimap), accept both `className` and
`style` props. This means you can use any styling solution you like, such as
[Styled Components](https://styled-components.com/):

```jsx
import { MiniMap } from '@xyflow/react';

const StyledMiniMap = styled(MiniMap)`
  background-color: ${(props) => props.theme.bg};

  .react-flow__minimap-mask {
    fill: ${(props) => props.theme.minimapMaskBg};
  }

  .react-flow__minimap-node {
    fill: ${(props) => props.theme.nodeBg};
    stroke: none;
  }
`;
```

For a complete example of using Styled Components with React Flow, check out
[the example](/examples/styling/styled-components)!

### TailwindCSS

Custom nodes and edges are just React components, and you can use any styling
solution you'd like to style them. For example, you might want to use
[Tailwind](https://tailwindcss.com/) to style your nodes:

```jsx
function CustomNode({ data }) {
  return (
    <div className="px-4 py-2 shadow-md rounded-md bg-white border-2 border-stone-400">
      <div className="flex">
        <div className="rounded-full w-12 h-12 flex justify-center items-center bg-gray-100">
          {data.emoji}
        </div>
        <div className="ml-2">
          <div className="text-lg font-bold">{data.name}</div>
          <div className="text-gray-500">{data.job}</div>
        </div>
      </div>

      <Handle
        type="target"
        position={Position.Top}
        className="w-16 !bg-teal-500"
      />
      <Handle
        type="source"
        position={Position.Bottom}
        className="w-16 !bg-teal-500"
      />
    </div>
  );
}
```

<Callout type="warning">
  If you want to overwrite default styles, make sure to import Tailwinds entry
  point after React Flows base styles.
</Callout>

```js
import '@xyflow/react/dist/style.css';
import 'tailwind.css';
```

For a complete example of using Tailwind with React Flow, check out
[the example](/examples/styling/tailwind)!

----
troubleshooting/_meta.json
{
  "index": "Common Errors",
  "remove-attribution": "Remove Attribution",
  "migrate-to-v12": "Migrate to v12",
  "migrate-to-v11": "Migrate to v11",
  "migrate-to-v10": {
    "title": "Migrate to v10",
    "theme": {
      "pagination": false
    }
  }
}

----
troubleshooting/index.mdx
---
title: Troubleshooting
description: Troubleshooting and fixes for common issues with React Flow.
---

# Troubleshooting

import { Callout } from 'nextra/components';

This guide contains warnings and errors that can occur when using React Flow. We are also adding common questions and pitfalls that we collect from our [Discord Server](https://discord.gg/RVmnytFmGW), [Github Issues](https://github.com/xyflow/xyflow/issues) and [Github Discussions](https://github.com/xyflow/xyflow/discussions).

<div id="001" />
### Warning: Seems like you have not used zustand provider as an ancestor

This usually happens when:

**A:** You have two different version of @reactflow/core installed.<br />
**B:** You are trying to access the internal React Flow state outside of the React Flow context.

#### Solution for A

Update reactflow and @reactflow/node-resizer (in case you are using it), remove node_modules and package-lock.json and reinstall the dependencies.

#### Solution for B

A possible solution is to wrap your component with a [`<ReactFlowProvider />`](/api-reference/react-flow-provider) or move the code that is accessing the state inside a child of your React Flow instance.

<Callout type="error">This will cause an error:</Callout>

```jsx
import { ReactFlow } from '@xyflow/react';
import '@xyflow/react/dist/style.css';

function FlowWithoutProvider(props) {
  // cannot access the state here
  const reactFlowInstance = useReactFlow();

  return <ReactFlow {...props} />;
}

export default FlowWithoutProvider;
```

<Callout type="error">This will cause an error, too:</Callout>

```jsx
import { ReactFlow, ReactFlowProvider } from '@xyflow/react';
import '@xyflow/react/dist/style.css';

function Flow(props) {
  // still cannot access the state here
  // only child components of this component can access the state
  const reactFlowInstance = useReactFlow();

  return (
    <ReactFlowProvider>
      <ReactFlow {...props} />
    </ReactFlowProvider>
  );
}

export default FlowWithProvider;
```

<Callout type="info">This works:</Callout>

As soon as you want to access the internal state of React Flow (for example by using the `useReactFlow` hook), you need to wrap your component with a `<ReactFlowProvider />`. Here the wrapping is done outside of the component:

```jsx
import { ReactFlow, ReactFlowProvider } from '@xyflow/react';
import '@xyflow/react/dist/style.css';

function Flow(props) {
  // you can access the internal state here
  const reactFlowInstance = useReactFlow();

  return <ReactFlow {...props} />;
}

// wrapping with ReactFlowProvider is done outside of the component
function FlowWithProvider(props) {
  return (
    <ReactFlowProvider>
      <Flow {...props} />
    </ReactFlowProvider>
  );
}

export default FlowWithProvider;
```

<div id="002" />
### It looks like you have created a new nodeTypes or edgeTypes object. If this wasn't
on purpose please define the nodeTypes/edgeTypes outside of the component or memoize
them.

This warning appears when the `nodeTypes` or `edgeTypes` properties change after the initial render. The `nodeTypes` or `edgeTypes` should only be changed dynamically in very rare cases. Usually they are defined once with all the types that you are using in your application. It can happen easily that you are defining the nodeTypes or edgeTypes object inside of your component render function, which will cause React Flow to re-render every time your component re-renders.

<Callout type="error">Causes a warning:</Callout>

```jsx
import { ReactFlow } from '@xyflow/react';
import '@xyflow/react/dist/style.css';

import MyCustomNode from './MyCustomNode';

function Flow(props) {
  // new object being created on every render
  // causing unneccessary re-renders
  const nodeTypes = {
    myCustomNode: MyCustomNode,
  };

  return <ReactFlow nodeTypes={nodeTypes} />;
}

export default Flow;
```

<Callout type="info">Recommended implementation:</Callout>

```jsx
import { ReactFlow } from '@xyflow/react';
import MyCustomNode from './MyCustomNode';

// defined outside of the component
const nodeTypes = {
  myCustomNode: MyCustomNode,
};

function Flow(props) {
  return <ReactFlow nodeTypes={nodeTypes} />;
}

export default Flow;
```

<Callout type="info">Alternative implementation:</Callout>

You can use this if you want to change your nodeTypes dynamically without causing unneccessary re-renders.

```jsx
import { useMemo } from 'react';
import { ReactFlow } from '@xyflow/react';
import '@xyflow/react/dist/style.css';

import MyCustomNode from './MyCustomNode';

function Flow(props) {
  const nodeTypes = useMemo(
    () => ({
      myCustomNode: MyCustomNode,
    }),
    [],
  );

  return <ReactFlow nodeTypes={nodeTypes} />;
}

export default Flow;
```

<div id="003" />
### Node type not found. Using fallback type "default".

This usually happens when you are specifying a custom node type for one of your nodes but not passing the correct nodeTypes property to React Flow. The string for the type option of your custom node needs to be exactly the same as the key of the nodeTypes object.

<Callout type="error">Doesn't work:</Callout>

```jsx
import { ReactFlow } from '@xyflow/react';
import '@xyflow/react/dist/style.css';

import MyCustomNode from './MyCustomNode';

const nodes = [
  {
    id: 'mycustomnode',
    type: 'custom',
    // ...
  },
];

function Flow(props) {
  // nodeTypes property is missing, so React Flow cannot find the custom node component to render
  return <ReactFlow nodes={nodes} />;
}
```

<Callout type="error">Doesn't work either:</Callout>

```jsx
import { ReactFlow } from '@xyflow/react';
import '@xyflow/react/dist/style.css';

import MyCustomNode from './MyCustomNode';

const nodes = [
  {
    id: 'mycustomnode',
    type: 'custom',
    // ...
  },
];

const nodeTypes = {
  Custom: MyCustomNode,
};

function Flow(props) {
  // node.type and key in nodeTypes object are not exactly the same (capitalized)
  return <ReactFlow nodes={nodes} nodeTypes={nodeTypes} />;
}
```

<Callout type="info">This does work:</Callout>

```jsx
import { ReactFlow } from '@xyflow/react';
import '@xyflow/react/dist/style.css';

import MyCustomNode from './MyCustomNode';

const nodes = [
  {
    id: 'mycustomnode',
    type: 'custom',
    // ...
  },
];

const nodeTypes = {
  custom: MyCustomNode,
};

function Flow(props) {
  return <ReactFlow nodes={nodes} nodeTypes={nodeTypes} />;
}
```

<div id="004" />
### The React Flow parent container needs a width and a height to render the graph.

Under the hood, React Flow measures the parent DOM element to adjust the renderer. If you try to render React Flow in a regular div without a height, we cannot display the graph. If you encounter this warning, you need to make sure that your wrapper component has some CSS attached to it so that it gets a fixed height or inherits the height of its parent.

<Callout type="error">This will cause the warning:</Callout>

```jsx
import { ReactFlow } from '@xyflow/react';
import '@xyflow/react/dist/style.css';

function Flow(props) {
  return (
    <div>
      <ReactFlow {...props} />
    </div>
  );
}
```

<Callout type="info">Working example:</Callout>

```jsx
import { ReactFlow } from '@xyflow/react';

function Flow(props) {
  return (
    <div style={{ height: 800 }}>
      <ReactFlow {...props} />
    </div>
  );
}
```

<div id="005" />
### Only child nodes can use a parent extent.

This warning appears when you are trying to add the `extent` option to a node that does not have a parent node. Depending on what you are trying to do, you can remove the `extent` option or specify a `parentNode`.

<Callout type="error">Does show a warning:</Callout>

```jsx
import { ReactFlow } from '@xyflow/react';
import '@xyflow/react/dist/style.css';

const nodes = [
  {
    id: 'mycustomnode',
    extent: 'parent',
    // ...
  },
];

function Flow(props) {
  return <ReactFlow nodes={nodes} />;
}
```

<Callout type="info">Warning resolved:</Callout>

```jsx import { ReactFlow } from '@xyflow/react';
const nodes = [
  {
    id: 'mycustomnode',
    parentNode: 'someothernode',
    extent: 'parent',
    // ...
  },
];

function Flow(props) {
  return <ReactFlow nodes={nodes} />;
}
```

<div id="006" />
### Can't create edge. An edge needs a source and a target.

This happens when you do not pass a `source` and a `target` option to the edge object. Without the source and target, the edge cannot be rendered.

<Callout type="error">Will show a warning:</Callout>

```jsx
import { ReactFlow } from '@xyflow/react';
import '@xyflow/react/dist/style.css';

const nodes = [
  /* ... */
];

const edges = [
  {
    nosource: '1',
    notarget: '2',
  },
];

function Flow(props) {
  return <ReactFlow nodes={nodes} edges={edges} />;
}
```

<Callout type="info">This works:</Callout>

```jsx
import { ReactFlow } from '@xyflow/react';

const nodes = [
  /* ... */
];

const edges = [
  {
    source: '1',
    target: '2',
  },
];

function Flow(props) {
  return <ReactFlow nodes={nodes} edges={edges} />;
}
```

<div id="007" />
### The old edge with id="some-id" does not exist.

This can happen when you are trying to [reconnect an edge](/examples/edges/reconnect-edge) but the edge you want to update is already removed from the state. This is a very rare case. Please see the [Reconnect Edge example](/examples/edges/reconnect-edge) for implementation details.

<div id="008" />
### Couldn't create edge for source/target handle id: "some-id"; edge id: "some-id".

This can happen if you are working with multiple handles and a handle is not found by its `id` property or if you haven't [updated the node internals after adding or removing handles](/api-reference/hooks/use-update-node-internals) programmatically. Please see the [Custom Node Example](/examples/nodes/custom-node) for an example of working with multiple handles.

<div id="009" />
### Marker type doesn't exist.

This warning occurs when you are trying to specify a marker type that is not built into React Flow. The existing marker types are documented [here](/api-reference/types/edge#edgemarker).

<div id="010" />
### Handle: No node id found.

This warning occurs when you try to use a `<Handle />` component outside of a custom node component.

### I get an error when building my app with webpack 4.

If you're using webpack 4, you'll likely run into an error like this:

```
ERROR in /node_modules/@reactflow/core/dist/esm/index.js 16:19
Module parse failed: Unexpected token (16:19)
You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders
```

React Flow is a modern JavaScript code base and makes use of lots of newer
JavaScript features. By default, webpack 4 does not transpile your code and it
doesn't know how to handle React Flow.

You need to add a number of babel plugins to your webpack config to make it work:

```sh
$ npm i --save-dev babel-loader@8.2.5 @babel/preset-env @babel/preset-react @babel/plugin-proposal-optional-chaining @babel/plugin-proposal-nullish-coalescing-operator
```

and configure the loader like this:

```js
{
  test: /node_modules[\/\\]@?reactflow[\/\\].*.js$/,
  use: {
    loader: 'babel-loader',
    options: {
      presets: ['@babel/preset-env', "@babel/preset-react"],
      plugins: [
        "@babel/plugin-proposal-optional-chaining",
        "@babel/plugin-proposal-nullish-coalescing-operator",
      ]
    }
  }
}
```

<Callout type="info">
  If you're using webpack 5, you don't need to do anything! React Flow will work
  out of the box.
</Callout>

### Mouse events aren't working consistently when my nodes contain a `<canvas />` element.

If you're using a `<canvas />` element inside your custom node, you might run into
problems with seemingly-incorrect coordinates in mouse events from the cavnas.

React Flow uses CSS transforms to scale nodes as you zoom in and out. From the DOM's
perspective, however, the element is still the same size. This can cause problems
if you have event listeners that want to calcuate the mouse position relative to
the canvas element.

To remedy this in event handlers you control, you can scale your computed relative
position by `1 / zoom` where `zoom` is the current zoom level of the flow. To get
the current zoom level, you can use the `getZoom` method from the
[`useReactFlow`](/api-reference/hooks/use-react-flow) hook.

----
troubleshooting/remove-attribution.mdx
---
title: Remove Attribution
description: When and how to remove the React Flow attribution from your flows.
---

# Remove Attribution

This example demonstrates how you can remove the React Flow attribution from the renderer.

import { Callout } from 'nextra/components';

<Callout type="info">
If you’re considering removing the attribution, we’d first like to mention:

**If you’re using React Flow at your organization and making money from it**, we rely on your support to keep React Flow developed and maintained under an MIT License. Before you remove the attribution, [see the ways you can support React Flow to keep it running](https://reactflow.dev/pro).

**Are you using React Flow for a personal project?** Great! Go ahead and remove the attribution. You can support us by reporting any bugs you find, sending us screenshots of your projects, and starring us on [Github](https://github.com/xyflow/xyflow). If you start making money using React Flow or use it in an organization in the future, we would ask that you re-add the attribution or sign up for one of our subscriptions.

Thank you for supporting the React Flow team ✌🏻

-Hayleigh, Peter, Moritz, Christopher, and John

</Callout>

import ExampleViewer from '@/components/example-viewer';

<ExampleViewer
  codePath="api-flows/RemoveAttribution"
  applyStyles={false}
  options={{ editorHeight: 700, editorWidthPercentage: 45, wrapContent: true }}
  activeFile="index.js"
  additionalFiles={['initialElements.js']}
/>

----
troubleshooting/migrate-to-v11.mdx
---
title: Migrate to v11
description: Use this guide to migrate from React Flow v10 to v11.
---

# Migrate to v11

import { Callout } from 'nextra/components';

<Callout type="info">
  You can find the docs for old versions of React Flow here:
  [v11](https://v11.reactflow.dev), [v10](https://v10.reactflow.dev),
  [v9](https://v9.reactflow.dev)
</Callout>

A lot changed in v11 but this time we've tried to keep the breaking changes small. The biggest change is the new package name `reactflow` and the new repo structure. React Flow is now managed as a monorepo and separated into multiple packages that can be installed separately. In addition to that, there are some API changes and new APIs introduced in v11. This guide explains the changes in detail and helps you to migrate from v10 to v11.

<Callout>React Flow 11 only works with **React 17** or greater</Callout>

## New Features

- **Better [Accessibility](/learn/advanced-use/accessibility)**
  - Nodes and edges are focusable, selectable, moveable and deleteable with the keyboard.
  - `aria-` default attributes for all elements and controllable via `ariaLabel` options
  - Keyboard controls can be disabled with the new `disableKeyboardA11y` prop
- **Better selectable edges** via new edge option: `interactionWidth` - renders invisible edge that makes it easier to interact
- **Better routing for smoothstep and step edges**: https://twitter.com/reactflowdev/status/1567535405284614145
- **Nicer edge updating behaviour**: https://twitter.com/reactflowdev/status/1564966917517021184
- **Node origin**: The new `nodeOrigin` prop lets you control the origin of a node. Useful for layouting.
- **New background pattern**: `BackgroundVariant.Cross` variant
- **[`useOnViewportChange`](/api-reference/hooks/use-on-viewport-change) hook** - handle viewport changes within a component
- **[`use-on-selection-change`](/api-reference/hooks/use-on-selection-change) hook** - handle selection changes within a component
- **[`useNodesInitialized`](/api-reference/hooks/use-nodes-initialized) hook** - returns true if all nodes are initialized and if there is more than one node
- **Deletable option** for Nodes and edges
- **New Event handlers**: `onPaneMouseEnter`, `onPaneMouseMove` and `onPaneMouseLeave`
- **Edge `pathOptions`** for `smoothstep` and `default` edges
- **Nicer cursor defaults**: Cursor is grabbing, while dragging a node or panning
- **Pane moveable** with middle mouse button
- **Pan over nodes** when they are not draggable (`draggable=false` or `nodesDraggable` false)
  - you can disable this behaviour by adding the class name `nopan` to a wrapper of a custom node
- **[`<BaseEdge />`](/api-reference/components/base-edge) component** that makes it easier to build custom edges
- **[Separately installable packages](/learn/concepts/plugin-components)**
  - @reactflow/core
  - @reactflow/background
  - @reactflow/controls
  - @reactflow/minimap

## Breaking Changes

### 1. New npm package name

The package `react-flow-renderer` has been renamed to `reactflow`.

#### Old API

```js
// npm install react-flow-renderer
import ReactFlow from 'react-flow-renderer';
```

#### New API

```js
// npm install reactflow
import { ReactFlow } from '@xyflow/react';
```

### 2. Importing CSS is mandatory

We are not injecting CSS anymore. **React Flow won't work if you are not loading the styles!**

```js
// default styling
import '@xyflow/react/dist/style.css';

// or if you just want basic styles
import '@xyflow/react/dist/base.css';
```

#### 2.1. Removal of the nocss entrypoint

This change also means that there is no `react-flow-renderer/nocss` entry point anymore. If you used that, you need to adjust the CSS entry points as mentioned above.

### 3. `defaultPosition` and `defaultZoom` have been merged to `defaultViewport`

#### Old API

```jsx
import ReactFlow from 'react-flow-renderer';

const Flow = () => {
  return <ReactFlow defaultPosition={[10, 15]} defaultZoom={5} />;
};

export default Flow;
```

#### New API

```jsx
import { ReactFlow } from '@xyflow/react';

const defaultViewport: Viewport = { x: 10, y: 15, zoom: 5 };

const Flow = () => {
  return <ReactFlow defaultViewport={defaultViewport} />;
};

export default Flow;
```

### 4. Removal of `getBezierEdgeCenter`, `getSimpleBezierEdgeCenter` and `getEdgeCenter`

In v10 we had `getBezierEdgeCenter`, `getSimpleBezierEdgeCenter` and `getEdgeCenter` for getting the center of a certain edge type.
In v11 we changed the helper function for creating the path, so that it also returns the center / label position of an edge.

Let's say you want to get the path and the center / label position of a bezier edge:

#### Old API

```jsx
import { getBezierEdgeCenter, getBezierPath } from 'react-flow-renderer';

const path = getBezierPath(edgeParams);
const [centerX, centerY] = getBezierEdgeCenter(params);
```

#### New API

```jsx
import { getBezierPath } from '@xyflow/react';

const [path, labelX, labelY] = getBezierPath(edgeParams);
```

We avoid to call it `centerX` and `centerY` anymore, because it's actually the label position and not always the center for every edge type.

### 5. Removal of `onClickConnectStop` and `onConnectStop`

#### Old API

```jsx
import ReactFlow from 'react-flow-renderer';

const Flow = () => {
  const onConnectStop = () => console.log('on connect stop');

  return (
    <ReactFlow
      defaultNodes={defaultNodes}
      defaultEdges={defaultEdges}
      onConnectStop={onConnectStop}
      onClickConnectStop={onConnectStop}
    />
  );
};

export default Flow;
```

#### New API

```jsx
import { ReactFlow } from '@xyflow/react';

const Flow = () => {
  const onConnectEnd = () => console.log('on connect stop');

  return (
    <ReactFlow
      defaultNodes={defaultNodes}
      defaultEdges={defaultEdges}
      onConnectEnd={onConnectEnd}
      onClickConnectEnd={onConnectEnd}
    />
  );
};

export default Flow;
```

### 6. Pan over nodes

In the previous versions you couldn't pan over nodes even if they were not draggable. In v11, you can pan over nodes when `nodesDraggable=false` or node option `draggable=false`. If you want the old behaviour back, you can add the class name `nopan` to the wrappers of your custom nodes.

----
troubleshooting/migrate-to-v10.mdx
---
title: Migrate to v10
description: Use this guide to migrate from React Flow v9 to v10.
---

# Migrate to v10

import { Callout } from 'nextra/components';

<Callout type="info">
  You can find the docs for old versions of React Flow here:
  [v11](https://v11.reactflow.dev), [v10](https://v10.reactflow.dev),
  [v9](https://v9.reactflow.dev)
</Callout>

Welcome to React Flow v10! With the major version update, there are coming many new features but also some breaking changes.

## New Features

- [**Sub Flows**](/learn/layouting/sub-flows): You can now add nodes to a parent node and create groups and nested flows
- **Node Type 'group'**: A new node type without handles that can be used as a group node
- **Touch Device Support**: It is now possible to connect nodes on touch devices
- **Fit View on Init**: You can use the new `fitView` prop to fit the initial view
- **Key Handling**: Not only single keys but also multiple keys and key combinations are possible now
- [**useKeyPress hook**](/api-reference/hooks/use-key-press): A util hook for handling keyboard events
- [**useReactFlow hook**](/api-reference/hooks/use-react-flow): Returns a React Flow instance that exposes functions to manipulate the flow
- **[useNodes](/api-reference/hooks/use-nodes), [useEdges](/api-reference/hooks/use-edges) and [useViewport](/api-reference/hooks/use-viewport) hooks**: Hooks for receiving nodes, edges and the viewport
- **Edge Marker**: More options to configure the start and end markers of an edge

## Breaking Changes

TLDR:

- Split the `elements` array into `nodes` and `edges` arrays and implement `onNodesChange` and `onEdgesChange` handlers (detailed guide in the [core concepts section](/learn/concepts/core-concepts))
- Memoize your custom `nodeTypes` and `edgeTypes`
- Rename `onLoad` to `onInit`
- Rename `paneMoveable` to `panOnDrag`
- Rename `useZoomPanHelper` to `useReactFlow` (and `setTransform` to `setViewport`)
- Rename node and edge option `isHidden` to `hidden`

Detailed explanation of breaking changes:

### 1. ~~Elements~~ - Nodes and Edges

We saw that a lot of people struggle with the semi controlled `elements` prop. It was always a bit messy to sync the local user state with the internal state of React Flow. Some of you used the internal store that was never documented and always a kind of hacky solution. For the new version we offer two ways to use React Flow - uncontrolled and controlled.

### 1.1. Controlled `nodes` and `edges`

If you want to have the full control and use nodes and edges from your local state or your store, you can use the `nodes`, `edges` props in combination with the `onNodesChange` and `onEdgesChange` handlers. You need to implement these handlers for an interactive flow (if you are fine with just pan and zoom you don't need them). You'll receive a change when a node(s) gets initialized, dragged, selected or removed. This means that you always know the exact position and dimensions of a node or if it's selected for example. We export the helper functions `applyNodeChanges` and `applyEdgeChanges` that you should use to apply the changes.

#### Old API

```jsx
import { useState, useCallback } from 'react';
import { ReactFlow, removeElements, addEdge } from 'react-flow-renderer';

const initialElements = [
  { id: '1', data: { label: 'Node 1' }, position: { x: 250, y: 0 } },
  { id: '2', data: { label: 'Node 2' }, position: { x: 150, y: 100 } },
  { id: 'e1-2', source: '1', target: '2' },
];

const BasicFlow = () => {
  const [elements, setElements] = useState(initialElements);
  const onElementsRemove = useCallback(
    (elementsToRemove) =>
      setElements((els) => removeElements(elementsToRemove, els)),
    [],
  );
  const onConnect = useCallback((connection) =>
    setElements((es) => addEdge(connection, es)),
  );

  return (
    <ReactFlow
      elements={elements}
      onElementsRemove={onElementsRemove}
      onConnect={onConnect}
    />
  );
};

export default BasicFlow;
```

#### New API

```jsx
import { useState, useCallback } from 'react';
import {
  ReactFlow,
  applyNodeChanges,
  applyEdgeChanges,
  addEdge,
} from 'react-flow-renderer';

const initialNodes = [
  { id: '1', data: { label: 'Node 1' }, position: { x: 250, y: 0 } },
  { id: '2', data: { label: 'Node 2' }, position: { x: 150, y: 100 } },
];

const initialEdges = [{ id: 'e1-2', source: '1', target: '2' }];

const BasicFlow = () => {
  const [nodes, setNodes] = useState(initialNodes);
  const [edges, setEdges] = useState(initialEdges);

  const onNodesChange = useCallback(
    (changes) => setNodes((ns) => applyNodeChanges(changes, ns)),
    [],
  );
  const onEdgesChange = useCallback(
    (changes) => setEdges((es) => applyEdgeChanges(changes, es)),
    [],
  );
  const onConnect = useCallback((connection) =>
    setEdges((eds) => addEdge(connection, eds)),
  );

  return (
    <ReactFlow
      nodes={nodes}
      edges={edges}
      onNodesChange={onNodesChange}
      onEdgesChange={onEdgesChange}
      onConnect={onConnect}
    />
  );
};

export default BasicFlow;
```

You can also use the new hooks `useNodesState` and `useEdgesState` for a quick start:

```js
const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);
const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);
```

related changes:

- `onElementsClick` ->`onNodeClick` and `onEdgeClick`
- `onElementsRemove` -> replaced by the `onNodesChange` and `onEdgesChange` handler

### 1.2 Uncontrolled `defaultNodes` and `defaultEdges`

The easiest way to get started is to use the `defaultNodes` and `defaultEdges` props. When you set these props, all actions are handled internally. You don't need to add any other handlers to get a fully interactive flow with the ability to drag nodes, connect nodes and remove nodes and edges:

#### New API

```jsx
import ReactFlow from 'react-flow-renderer';

const defaultNodes = [
  { id: '1', data: { label: 'Node 1' }, position: { x: 250, y: 0 } },
  { id: '2', data: { label: 'Node 2' }, position: { x: 150, y: 100 } },
];

const defaultEdges = [{ id: 'e1-2', source: '1', target: '2' }];

const BasicFlow = () => {
  return <ReactFlow defaultNodes={defaultNodes} defaultEdges={defaultEdges} />;
};

export default BasicFlow;
```

If you want to add, remove or update a node or edge you can only do this by using the [ReactFlow instance](/api-reference/types/react-flow-instance) that you can receive either with the new `useReactFlow` hook or by using the `onInit` handler that gets the instance as a function param.

### 2. Memoize your custom `nodeTypes` and `edgeTypes`

Whenever you pass new node or edge types, we create wrapped node or edge component types in the background. This means that you should not create a new `nodeType` or `edgeType` object on every render. **Memoize your nodeTypes and edgeTypes or define them outside of the component when they don't change**.

**Don't do this:**

This creates a new object on every render and leads to bugs and performance issues:

```jsx
// this is bad! Don't do it.
<ReactFlow
  nodes={[]}
  nodeTypes={{
    specialType: SpecialNode, // bad!
  }}
/>
```

**Do this:**

```jsx
function Flow() {
  const nodeTypes = useMemo(() => ({ specialType: SpecialNode }), []);

  return <ReactFlow nodes={[]} nodeTypes={nodeTypes} />;
}
```

or create the types outside of the component when they don't change:

```jsx
const nodeTypes = { specialType: SpecialNode };

function Flow() {
  return <ReactFlow nodes={[]} nodeTypes={nodeTypes} />;
}
```

### 3. ~~Redux~~ - Zustand

We switched our state management library from Redux to [Zustand](https://github.com/pmndrs/zustand). With this change we could remove about 300LOC from our state related code. If you need to access the internal store, you can use the [`useStore` hook](/api-reference/hooks/use-store):

#### Old API

```jsx
import { useStoreState, useStoreActions } from 'react-flow-renderer';

...

const transform = useStoreState((store) => store.transform);
```

#### New API

```jsx
import { useStore } from 'react-flow-renderer';

...
const transform = useStore((store) => store.transform);
```

You still need to wrap your component with the `<ReactFlowProvider />` if you want to access the internal store.

We are also exporting `useStoreApi` if you need to get the store in an event handler for example without triggering re-renders.

```js
import { useStoreApi } from 'react-flow-renderer';

...

const store = useStoreApi();

...
// in an event handler
const [x, y, zoom] = store.getState().transform;
```

### 4. ~~onLoad~~ - onInit

The `onLoad` callback has been renamed to `onInit` and now fires when the nodes are initialized.

#### Old API

```jsx
const onLoad = (reactFlowInstance: OnLoadParams) => reactFlowInstance.zoomTo(2);
...
<ReactFlow
   ...
  onLoad={onLoad}
/>
```

#### New API

```jsx
const onInit = (reactFlowInstance: ReactFlowInstance) => reactFlowInstance.zoomTo(2);
...
<ReactFlow
   ...
  onInit={onInit}
/>
```

### 5. ~~paneMoveable~~ - panOnDrag

This is more consistent with the rest of the API (`panOnScroll`, `zoomOnScroll`, etc.)

#### Old API

```jsx
<ReactFlow
   ...
  paneMoveable={false}
/>
```

#### New API

```jsx
<ReactFlow
   ...
  panOnDrag={false}
/>
```

### 6. ~~useZoomPanHelper transform~~ - unified in `useReactFlow`

As "transform" is also the variable name of the transform in the store and it's not clear that `transform` is a setter we renamed it to `setViewport`. This is also more consistent with the other functions. Also, all `useZoomPanHelper` functions have been moved to the [React Flow instance](/api-reference/types/react-flow-instance) that you get from the [`useReactFlow` hook](/api-reference/hooks/use-react-flow) or the `onInit` handler.

#### Old API

```js
const { transform, setCenter, setZoom  } = useZoomPanHelper();
...
transform({ x: 100, y: 100, zoom: 2 });
```

#### New API

```js
const { setViewport, setCenter, setZoom } = useReactFlow();
...
setViewport({ x: 100, y: 100, zoom: 2 });
```

New viewport functions:

- `getZoom`
- `getViewport`

### 7. ~~isHidden~~ - hidden

We mixed prefixed (`is...`) and non-prefixed boolean option names. All node and edge options are not prefixed anymore. So it's `hidden`, `animated`, `selected`, `draggable`, `selectable` and `connectable`.

#### Old API

```js
const hiddenNode = { id: '1', isHidden: true, position: { x: 50, y: 50 } };
```

#### New API

```js
const hiddenNode = { id: '1', hidden: true, position: { x: 50, y: 50 } };
```

### 8. ~~arrowHeadType~~ ~~markerEndId~~ - markerStart / markerEnd

We improved the API for customizing the markers for an edge. With the new API you are able to set individual markers at the start and the end of an edge as well as customizing them with colors, strokeWidth etc. You still have the ability to set a markerEndId but instead of using different properties, the `markerStart` and `markerEnd` property accepts either a string (id for the svg marker that you need to define yourself) or a configuration object for using the built in arrowclosed or arrow markers.

#### Old API

```js
const markerEdge = { source: '1', target: '2', arrowHeadType: 'arrow' };
```

#### New API

```js
const markerEdge = {
  source: '1',
  target: '2',
  markerStart: 'myCustomSvgMarker',
  markerEnd: { type: 'arrow', color: '#f00' },
};
```

### 9. ~~ArrowHeadType~~ - MarkerType

This is just a wording change for making the marker API more consistent. As we are now able to set markers for the start of the edge, the name type ArrowHeadType has been renamed to MarkerType. In the future, this can also not only contain arrow shapes but others like circles, diamonds etc.

### 10. Attribution

This is not really a breaking change to the API but a little change in the general appearance of React Flow. We added a tiny "React Flow" attribution to the bottom right (the position is configurable via the `attributionPosition` prop). This change comes with the new "React Flow Pro" subscription model. If you want to remove the attribution in a commercial application, please subscribe to ["React Flow Pro"](https://reactflow.dev/pro).

----
troubleshooting/migrate-to-v12.mdx
---
title: Migrate to React Flow 12
description: Use this guide to migrate from React Flow 11 to 12.
created_at: 2024-07-09
---

import { Tabs, Tab } from 'nextra/components';
import { Emoji } from '@xyflow/xy-ui';

# Migrate to React Flow 12

import { Callout } from 'nextra/components';

<Callout type="info">
  You can find the docs for old versions of React Flow here:
  [v11](https://v11.reactflow.dev), [v10](https://v10.reactflow.dev),
  [v9](https://v9.reactflow.dev)
</Callout>

Before you can use the **[new features](#new-features)** that come with React Flow 12 like server side rendering, computing flows, and dark mode, here are the breaking changes you'll have to address first. We tried to keep the breaking changes to a minimum, but some of them were necessary to implement the new features.

## Migration guide

Before you start to migrate, you need to install the new package.

<Tabs items={['npm', 'pnpm', 'yarn']}>
  <Tab>

```bash
npm install @xyflow/react
```

  </Tab>
  <Tab>

```bash
pnpm add @xyflow/react
```

  </Tab>
  <Tab>

```bash
yarn add @xyflow/react
```

  </Tab>
</Tabs>

{/* this is a workaround to hide headlines from the TOC */}
{<h3>1. A new npm package name</h3>}

The package `reactflow` has been renamed to `@xyflow/react` and it's not a default import anymore. You also need to adjust the style import. Before v12, Rreact Flow was divided into multiple packages. That's not the case anymore. If you just used the core, you now need to install the `@xyflow/react` package.

{<h4>Old API</h4>}

```js
// npm install reactflow
import ReactFlow from 'reactflow';
```

{<h4>New API</h4>}

```js
// npm install @xyflow/react
import { ReactFlow } from '@xyflow/react';

// you also need to adjust the style import
import '@xyflow/react/dist/style.css';

// or if you just want basic styles
import '@xyflow/react/dist/base.css';
```

{<h3>2. Node `measured` attribute for measured `width` and `height`</h3>}

All measured node values are now stored in `node.measured`. Besides the new package name, this is the biggest change. After React Flow measures your nodes, it writes the dimesions to `node.measured.width` and `node.measured.height`. If you are using any layouting library like dagre or elk, you now need to take the dimesions from `node.measured` instead of `node`. If you are using `width` and `height`, those values will now be used as inline styles to specify the node dimensions.

{<h4>Old API</h4>}

```js
// getting the measured width and height
const nodeWidth = node.width;
const nodeHeight = node.height;
```

{<h4>New API</h4>}

```js
// getting the measured width and height
const nodeWidth = node.measured?.width;
const nodeHeight = node.measured?.height;
```

{<h3>3. New dimension handling `node.width` / `node.height` vs `node.measured.width` / `node.measured.height`</h3>}

In order to support server side rendering we had to restructure the API a bit, so that users can pass node dimensions more easily. For this we changed the behaviour of the `node.width` and `node.height` attributes. In React Flow 11, those attributes were measured values and only used as a reference. In React Flow 12 those attributes are used as inline styles to specify the node dimensions. If you load nodes from a database, you probably want to remove the `width` and `height` attributes from your nodes, because the bahaviour is slightly different now. Using `width` and `height` now means that the dimensions are not dynamic based on the content but fixed.

{<h4>Old API</h4>}

```js
// in React Flow 11 you might used node.style to set the dimensions
const nodes = [
  {
    id: '1',
    type: 'input',
    data: { label: 'input node' },
    position: { x: 250, y: 5 },
    style: { width: 180, height: 40 },
  },
];
```

{<h4>New API</h4>}

```js
// in React Flow 12 you can used node.width and node.height to set the dimensions
const nodes = [
  {
    id: '1',
    type: 'input',
    data: { label: 'input node' },
    position: { x: 250, y: 5 },
    width: 180,
    height: 40,
  },
];
```

If you want to read more about how to configure React Flow for server side rendering, you can read about it in the [server side rendering guide](/learn/advanced-use/ssr-ssg-configuration).

{<h3>4. Updating nodes and edges</h3>}

We are not supporting node and edge updates with object mutations anymore. If you want to update a certain attribute, you need to create a new node / edge.

{<h4>Old API</h4>}

```js
setNodes((currentNodes) =>
  currentNodes.map((node) => {
    node.hidden = true;
    return node;
  }),
);
```

{<h4>New API</h4>}

```js
setNodes((currentNodes) =>
  currentNodes.map((node) => ({
    ...node,
    hidden: true,
  })),
);
```

{<h3>5. Rename `onEdgeUpdate` (and related APIs) to `onReconnect`</h3>}

We renamed the `onEdgeUpdate` function to `onReconnect` and all related APIs (mentioned below). The new name is more descriptive and makes it clear that the function is used to reconnect edges.

`updateEdge` => `reconnectEdge`
`onEdgeUpdateStart` => `onReconnectStart`
`onEdgeUpdate` => `onReconnect`
`onEdgeUpdateEnd` => `onReconnectEnd`
`edgeUpdaterRadius` => `reconnectRadius`
`edge.updatable` => `edge.reconnectable`
`edgesUpdatable` => `edgesReconnectable`

{<h4>Old API</h4>}

```js
<ReactFlow
  onEdgeUpdate={onEdgeUpdate}
  onEdgeUpdateStart={onEdgeUpdateStart}
  onEdgeUpdateEnd={onEdgeUpdateEnd}
/>
```

{<h4>New API</h4>}

```js
<ReactFlow
  onReconnect={onReconnect}
  onReconnectStart={onReconnectStart}
  onReconnectEnd={onReconnectEnd}
/>
```

{<h3>6. Rename `parentNode` to `parentId`</h3>}

If you are working with subflows, you need to rename `node.parentNode` to `node.parentId`. The `parentNode` attribute was a bit misleading, because it was not a reference to the parent node, but the `id` of the parent node.

{<h4>Old API</h4>}

```js
const nodes = [
  // some nodes ...
  {
    id: 'xyz-id',
    position: { x: 0, y: 0 },
    type: 'default',
    data: {},
    parentNode: 'abc-id',
  },
];
```

{<h4>New API</h4>}

```js
const nodes = [
  // some nodes ...
  {
    id: 'xyz-id',
    position: { x: 0, y: 0 },
    type: 'default',
    data: {},
    parentId: 'abc-id',
  },
];
```

{<h3>7. Custom node props</h3>}

We renamed the `posX` and `posY` props to `positionAbsoluteX` and `positionAbsoluteY`

{<h4>Old API</h4>}

```js
function CustomNode({ posX, posY }) {
  ...
}
```

{<h4>New API</h4>}

```js
function CustomNode({ positionAbsoluteX, positionAbsoluteY }) {
  ...
}
```

{<h3>8. `getNodesBounds` options</h3>}

The type of the second param changed from `nodeOrigin` to `options.nodeOrigin` / `options.useRelativePosition`

{<h4>Old API</h4>}

```js
const bounds = getNodesBounds(nodes: Node[], nodeOrigin)
```

{<h4>New API</h4>}

```js
const bounds = getNodesBounds(nodes: Node[], { nodeOrigin })
```

{<h3>9. Typescript changes for defining nodes and edges</h3>}

We simplified types and fixed issues about functions where users could pass a NodeData generic. The new way is to define your own node type with a union of all your nodes. With this change, you can now have multiple node types with different data structures and always be able to distinguish by checking the `node.type` attribute.

{<h4>New API</h4>}

```js
type NumberNode = Node<{ value: number }, 'number'>;
type TextNode = Node<{ text: string }, 'text'>;
type AppNode = NumberNode | TextNode;
```

You can then use the `AppNode` type as the following:

```js
const nodes: AppNode[] = [
  { id: '1', type: 'number', data: { value: 1 }, position: { x: 100, y: 100 } },
  { id: '2', type: 'text', data: { text: 'Hello' }, position: { x: 200, y: 200 } },
];
```

```js
const onNodesChange: onNodesChange<AppNode> = useCallback((changes) => setNodes(nds => applyChanges(changes, nds)), []);
```

You can read more about this in the [Typescript guide](/learn/advanced-use/typescript).

{<h3>10. Rename `nodeInternals`</h3>}

If you are using `nodeInternals` you need to rename it to `nodeLookup`.

{<h4>Old API</h4>}

```js
const node = useStore((s) => s.nodeInternals.get(id));
```

{<h4>New API</h4>}

```js
const node = useStore((s) => s.nodeLookup.get(id));
```

{<h3>11. Removal of deprecated functions</h3>}

We removed the following deprecated functions:

- `getTransformForBounds` (replaced by `getViewportForBounds`)
- `getRectOfNodes` (replaced by `getNodesBounds`)
- `project` (replaced by `screenToFlowPosition`)
- `getMarkerEndId`
- `updateEdge` (replaced by `reconnectEdge`)

{<h3>12. Custom `applyNodeChanges` and `applyEdgeChanges`</h3>}

If you wrote your own function for applying changes, you need to handle the new "replace" event. We removed the "reset" event and added a "replace" event that replaces specific nodes or edges.

## New features

Now that you successfully migrated to v12, you can use all the fancy features. As mentioned above, the biggest updates for v12 are:

{<h3>1. Server side rendering</h3>}

You can define `width`, `height` and `handles` for the nodes. This makes it possible to render a flow on the server and hydrate on the client: [server side rendering guide](/learn/advanced-use/ssr-ssg-configuration).

- **Details:** In v11, `width` and `height` were set by the library as soon as the nodes got measured. This still happens, but we are now using `measured.width` and `measured.height` to store this information. In the previous versions there was always a lot of confusion about `width` and `height`. It’s hard to understand, that you can’t use it for passing an actual width or height. It’s also not obvious that those attributes get added by the library. We think that the new implementation solves both of the problems: `width` and `height` are optional attributes that can be used to define dimensions and everything that is set by the library, is stored in `measured`.

{<h3>2. Computing flows</h3>}

The new hooks [`useHandleConnections`](/api-reference/hooks/use-handle-connections) and [`useNodesData`](/api-reference/hooks/use-nodes-data) and the new [`updateNode`](/api-reference/hooks/use-react-flow#update-node) and [`updateNodeData`](/api-reference/hooks/use-react-flow#update-node-data) functions (both are part of `useReactFlow`) can be used to manage the data flow between your nodes: [computing flows guide](/learn/advanced-use/computing-flows). We also added those helpers for edges (`updateEdge` and `updateEdgeData`)!

- **Details:** Working with flows where one node data relies on another node is super common. You update node A and want to react on those changes in the connected node B. Until now everyone had to come up with a custom solution. With this version we want to change this and give you performant helpers to handle use cases like this.

{<h3>3. Dark mode and CSS variables</h3>}

React Flow now comes with a built-in dark mode, that can be toggled by using the new [`colorMode`](/api-reference/react-flow#color-mode) prop (”light”, “dark” or “system”): [dark mode example](/examples/styling/dark-mode)

- **Details:** With this version we want to make it easier to switch between dark and light modes and give you a better starting point for dark flows. If you pass `colorMode="dark"`, we add the class name "dark" to the wrapper and use it to adjust the styling. To make the implementation for this new feature easier on our ends, we switched to CSS variables for most of the styles. These variables can also be used in user land to customize a flow.

{<h3>4. A better DX with TSDoc</h3>}

We started to use TSDoc for a better DX. While developing your IDE will now show you the documentation for the props and hooks. This is a big step for us to make the library more accessible and easier to use. We will also use TSDoc in the near future to generate the documentation.

{<h3>More features and updates</h3>}

There is more! Besides the new main features, we added some minor things that were on our list for a long time:

- **[`useConnection` hook](/api-reference/hooks/use-connection):** With this hook you can access the ongoing connection. For example, you can use it for colorizing handles styling a custom connection line based on the current start / end handles.
- **Controlled `viewport`:** This is an advanced feature. Possible use cases are to animate the viewport or round the transform for lower res screens for example. This features brings two new props: [`viewport`](/api-reference/react-flow#viewport) and [`onViewportChange`](/api-reference/react-flow#on-viewport-change).
- **[`ViewportPortal`](/api-reference/components/viewport-portal) component:** This makes it possible to render elements in the viewport without the need to implement a custom node.
- **[`onDelete`](/api-reference/react-flow#on-delete) handler**: We added a combined handler for `onDeleteNodes` and `onDeleteEdges` to make it easier to react to deletions.
- **[`onBeforeDelete`](/api-reference/react-flow#on-before-delete) handler**: With this handler you can prevent/ manage deletions.
- **[`isValidConnection`](/api-reference/react-flow#is-valid-connection) prop:** This makes it possible to implement one validation function for all connections. It also gets called for programmatically added edges.
- **[`autoPanSpeed`](/api-reference/react-flow#autoPanSpeed) prop:** For controlling the speed while auto panning.
- **[`paneClickDistance`](/api-reference/react-flow#paneClickDistance) prop:** max distance between mousedown/up that will trigger a click.
- **Background component**: add [`patternClassName`](/api-reference/components/background#pattern-class-name) prop to be able to style the background pattern by using a class name. This is useful if you want to style the background pattern with Tailwind for example.
- **`onMove` callback** gets triggered for library-invoked viewport updates (like fitView or zoom-in)
- **`deleteElements`** now returns deleted nodes and deleted edges
- add **`origin` attribute** for nodes
- add **`selectable` attribute** for edges
- **Node Resizer updates**: child nodes don't move when the group is resized, extent and expand is recognized correctly
- Correct types for `BezierEdge`, `StepEdge`, `SmoothStepEdge` and `StraightEdge` components
- New edges created by the library only have `sourceHandle` and `targetHandle` attributes when those attributes are set. (We used to pass `sourceHandle: null` and `targetHandle: null`)
- Edges do not mount/unmount when their z-index change
- connection line knows about the target handle position so that the path is drawn correctly
- `nodeDragThreshold` is 1 by default instead of 0
- a better selection box usability (capture while dragging out of the flow)
- add `selectable`, `deletable`, `draggable` and `parentId` to `NodeProps`
- add a warning when styles not loaded

{<h3>Internal changes</h3>}

These changes are not really user-facing, but it could be important for folks who are working with the internal React Flow store:

- The biggest internal change is that we created a new package **@xyflow/system with framework agnostic helpers** that can be used by React Flow and Svelte Flow
  - **XYDrag** for handling dragging node(s) and selection
  - **XYPanZoom** for controlling the viewport panning and zooming
  - **XYHandle** for managing new connections
- We renamed `nodeInternals` to `nodeLookup`. That map serves as a lookup, but we are not creating a new map object on any change so it’s really only useful as a lookup.
- We removed the internal "reset" event and added a "replace" event to be able to update specific nodes.
- We removed `connectionNodeId`, `connectionHandleId`, `connectionHandleType` from the store and added `connection.fromHandle.nodeId`, `connection.fromHandle.id`, …
- add `data-id` to edges
- `onNodeDragStart`, `onNodeDrag` and `onNodeDragStop` also get called when user drags a selection (in addition to `onSelectionDragStart`, `onSelectionDrag`, `onSelectionDragStop`)

----
getting-started/_meta.json
{
  "installation-and-requirements": "Installation",
  "building-a-flow": "Building a Flow",
  "adding-interactivity": "Adding Interactivity"
}

----
getting-started/adding-interactivity.mdx
---
title: Adding Interactivity
description: This guide will show you how to add basic interactivity to your flow.
---

# Adding Interactivity

import ExampleViewer from '@/components/example-viewer';
import { Callout } from 'nextra/components';

Let's make it so we can select, drag, and remove nodes and edges.

<Callout type="info">
  In this Getting Started tutorial, we are going to use a ["controlled
  component"](https://reactjs.org/docs/forms.html#controlled-components), which
  is typically the best and most flexible way to use React Flow in your own
  applications. You can also use React Flow in an [uncontrolled
  way](/docs/guides/uncontrolled-flow/).
</Callout>

## Handle Change Events

First let's import a few things. To manage the changes in React Flow, we'll be using `useState` and the two helper function `applyEdgeChanges` and `applyNodeChanges` from React Flow.

```js
import { useState, useCallback } from 'react';
import { ReactFlow, applyEdgeChanges, applyNodeChanges } from '@xyflow/react';
```

We're going to set up states for both the nodes and edges:

```js
const [nodes, setNodes] = useState(initialNodes);
const [edges, setEdges] = useState(initialEdges);
```

Directly beneath that, we'll add these two functions:

```js
const onNodesChange = useCallback(
  (changes) => setNodes((nds) => applyNodeChanges(changes, nds)),
  [],
);
const onEdgesChange = useCallback(
  (changes) => setEdges((eds) => applyEdgeChanges(changes, eds)),
  [],
);
```

When you drag or select a node, the `onNodeChange` handler gets called. With help of the `applyNodeChanges` function you can then apply those changes to your current node state. Putting everything together, it should look like this:

<ExampleViewer
  codePath="api-flows/MakeItInteractive1"
  applyStyles={false}
  options={{ editorHeight: 400, editorWidthPercentage: 45, wrapContent: true }}
/>

Now if you run your application, you'll be able to click and drag the components, and the UI will update based on those movements.

## Handle Connections

One last piece is missing: connecting nodes manually. For this we need to implement an `onConnect` handler and pass it to the `<ReactFlow />` component as well:

<ExampleViewer
  codePath="api-flows/MakeItInteractive2"
  applyStyles={false}
  options={{ editorHeight: 400, editorWidthPercentage: 45, wrapContent: true }}
/>

Try to connect the two nodes by dragging from on handle to another one. That's it. You've built a fully interactive flow.

That's it for now :) You made it! If you want to move on, we recommend to check out the ["Custom Nodes" guide](/learn/customization/custom-nodes).

----
getting-started/installation-and-requirements.mdx
---
title: Installation and Requirements
description: You can install React Flow using npm, pnpm, or yarn.
---

# Installation and Requirements

For this set-up we assume you already have node.js and npm, yarn or pnpm already installed.
The React Flow package is published under [`@xyflow/react`](https://www.npmjs.com/package/@xyflow/react) on npm and installable via:

import { Tab, Tabs } from 'nextra/components';

<Tabs items={['npm', 'pnpm', 'yarn', 'bun']}>
<Tab>

```bash copy
npm install @xyflow/react
```

  </Tab>
  <Tab >

```bash copy
pnpm add @xyflow/react
```

  </Tab>
    <Tab>

```bash copy
yarn add @xyflow/react
```

  </Tab>
  <Tab>

```bash copy
bun add @xyflow/react
```

</Tab>
</Tabs>

Now you can import the React Flow component and the styles in your application:

```js
import { ReactFlow } from '@xyflow/react';
import '@xyflow/react/dist/style.css';
```

## Hit the ground running

To get folks building quickly, we have a template repository on GitHub that uses
Vite and TypeScript – we use this set up for all our own React Flow work! You can
find the template [here](https://github.com/xyflow/vite-react-flow-template).

To use it, you can either create a new repository from the template, or use `degit`
to grab the template's files without the git history:

```bash
npx degit xyflow/vite-react-flow-template your-app-name
```

## Prior Experience Needed

React Flow is a React library. That means React developers will feel comfortable
using it. If basic React terms and concepts like states, props, components, and
hooks are unfamiliar to you, you might need to learn more about React before being
able to use React Flow fully. If you’ve never used React before, we recommend
first getting to start on React through tutorials like
[Codecademy](https://www.notion.so/John-s-Guide-to-React-Flow-b7a435289bed481f8c73f9a4e112b8d6)
or [Reactjs.org](https://reactjs.org/tutorial/tutorial.html).

----
getting-started/building-a-flow.mdx
---
title: Building a Flow
description: Learn how to build your first static flow with React Flow.
---

# Building a Flow

import ExampleViewer from '@/components/example-viewer';

In this section we are explaining how to create a controlled flow component. Now that you've installed React Flow into your React project, all files are in place to start using React Flow.

## Getting Started

Let's create an empty flow with a controls panel and a background. For this we need to import the components from the `reactflow` package:

```js
import { ReactFlow, Background, Controls } from '@xyflow/react';
```

We can now use the components to render an empty flow:

<ExampleViewer
  codePath="api-flows/GettingStarted1"
  applyStyles={false}
  options={{ editorHeight: 400, editorWidthPercentage: 45, wrapContent: true }}
/>

There are three important things to keep in mind here:

1. You need to **import the styles**. Otherwise React Flow won't work.
2. The **parent container needs a width and a height**, because React Flow uses its parent dimensions.
3. If you have **multiple flows on one page**, you need to pass a unique `id` prop to each component to make React Flow work properly.

## Adding Nodes

Now that the flow is set up, let's add some nodes. To do this, you need to create an array with [node objects](/api-reference/types/node) like this:

```js
const nodes = [
  {
    id: '1', // required
    position: { x: 0, y: 0 }, // required
  },
];
```

These nodes can now be added to the flow:

<ExampleViewer
  codePath="api-flows/GettingStarted2"
  applyStyles={false}
  options={{ editorHeight: 400, editorWidthPercentage: 45, wrapContent: true }}
/>

Let's add another node, configure labels and use the node type `input` for the first node.

```js
const nodes = [
  {
    id: '1',
    position: { x: 0, y: 0 },
    data: { label: 'Hello' },
    type: 'input',
  },
  {
    id: '2',
    position: { x: 100, y: 100 },
    data: { label: 'World' },
  },
];
```

<ExampleViewer
  codePath="api-flows/GettingStarted3"
  applyStyles={false}
  options={{ editorHeight: 400, editorWidthPercentage: 45, wrapContent: true }}
/>

There are plenty of ways to configure nodes. You can see the full list of options on the [node option site](/api-reference/types/node).

This looks good. Let's attach these two nodes.

## Adding an Edge

Now that we have two nodes, let's connect them with an edge.

To make an edge, we need to specify two attributes: the source node (where the edge begins) and the target node (where the edge ends). We use the `id` of the two nodes to specify this (in our example, our two nodes have ids of "1" and "2"):

```js
const edges = [{ id: '1-2', source: '1', target: '2' }];
```

<ExampleViewer
  codePath="api-flows/GettingStarted4"
  applyStyles={false}
  options={{ editorHeight: 400, editorWidthPercentage: 45, wrapContent: true }}
/>

Let's give this edge two properties that are built into React Flow, a `label` and a different `type`.

<ExampleViewer
  codePath="api-flows/GettingStarted5"
  applyStyles={false}
  options={{ editorHeight: 400, editorWidthPercentage: 45, wrapContent: true }}
/>

You made your first edge, nice work! You might have realised that you can't drag or select nodes. In the next part you'll learn how to make the flow interactive.

----
concepts/_meta.json
{
  "introduction": "Introduction",
  "terms-and-definitions": "Terms and Definitions",
  "core-concepts": "Core Concepts",
  "the-viewport": "The Viewport",
  "plugin-components": "Plugin Components"
}

----
concepts/the-viewport.mdx
---
title: Panning and Zooming
description: Learn how to customize the panning and zooming behaviour of React Flow.
---

# Panning and Zooming

The default pan and zoom behaviour of React Flow is inspired by [slippy maps](https://wiki.openstreetmap.org/wiki/Slippy_map). You pan by dragging and zoom by scrolling. You can customize this behaviour easily with the provided props:

- `panOnDrag`: default: `true`
- `selectionOnDrag`: default: `false` (available since 11.4.0)
- `panOnScroll`: default: `false` (Overwrites `zoomOnScroll`)
- `panOnScrollSpeed`: default: `0.5`
- `panOnScrollMode`: default: `'free'`. `'free'` (all directions), `'vertical'` (only vertical) or `'horizontal'` (only horizontal)
- `zoomOnScroll`: default: `true`
- `zoomOnPinch`: default: `true`
- `zoomOnDoubleClick`: default: `true`
- `preventScrolling`: default: `true` (browser scroll behaviour is prevented)
- `zoomActivationKeyCode`: default `'Meta'`
- `panActivationKeyCode`: default `'Space'` (available since 11.4.0)

## Default Viewport Controls

As mentioned above, the default controls are:

- pan: drag mouse
- zoom: scroll
- create selection: Shift + drag

import ExampleViewer from '@/components/example-viewer';

<ExampleViewer
  codePath="api-flows/ZoomPan"
  additionalFiles={['nodes.js', 'edges.js']}
  editorOptions={{
    editorHeight: 500,
    editorWidthPercentage: 45,
    wrapContent: true,
  }}
/>

## Figma-like Viewport Controls

If you prefer figma/sketch/design tool controls you can set `panOnScroll={true}` and `selectionOnDrag={true}`:

- pan: Space + drag mouse, scroll, middle or right mouse
- zoom: pitch or cmd + scroll
- create selection: drag mouse

<ExampleViewer
  codePath="api-flows/ZoomPan2"
  additionalFiles={['nodes.js', 'edges.js']}
  editorOptions={{
    editorHeight: 500,
    editorWidthPercentage: 45,
    wrapContent: true,
  }}
/>

In this example we also set `selectionMode={SelectionMode.Partial}` to be able to add nodes to a selection that are only partially selected.

----
concepts/introduction.mdx
---
title: Introduction
description: React Flow is a library for building node-based applications from static diagrams to complex editors. It comes with built-in plugins like a mini map and graph controls, and nodes and edges are highly customizable.
---

import { ReactPlayer } from 'xy-shared';
import { Emoji } from '@xyflow/xy-ui';

# Introduction

React Flow is a library for building node-based applications. These can be anything
from simple static diagrams to data visualisations to complex visual editors. You
can implement custom node types and edges and it comes with components like a
minimap and viewport controls out of the box.

If you're looking to get started quickly check out the [quickstart guide](/learn),
otherwise, let's take a look at React Flow's key features.

## Key Features

**<Emoji content="👌" /> Easy to use**: React Flow already comes with many of the features you want out of the box. Dragging
nodes around, zooming and panning, selecting multiple nodes and edges, and
adding/removing edges are all built-in.

**<Emoji content="🎨" /> Customizable**: React Flow supports custom node types and edge types. Because custom nodes are just
React components, you can implement anything you need: you're not locked in to
the built-in node types. Custom edges let you add labels, controls, and bespoke
logic to node edges.

**<Emoji content="⚡️" /> Fast rendering**: React Flow only renders nodes that have changed, and makes sures only those that
are in the viewport are displayed at all.

**<Emoji content="🧩" /> Built-in plugins**: We ship React Flow with a few plugins out of the box:

- The [`<Background />`](/api-reference/components/background) plugin implements some basic customisable background patterns.
- The [`<MiniMap />`](/api-reference/components/minimap) plugin displays a small version of the graph in the corner of the screen.
- The [`<Controls />`](/api-reference/components/controls) plugin adds controls to zoom, center, and lock the viewport.
- The [`<Panel />`](/api-reference/components/panel) plugin makes it easy to position content on top of the viewport.
- The [`<NodeToolbar />`](/api-reference/components/node-toolbar) plugin lets you render a toolbar attached to a node.
- The [`<NodeResizer />`](/api-reference/components/node-resizer) plugin makes it easy to add resize funtionality to your nodes.

**<Emoji content="💪" /> Reliable:** React Flow is entirely written in TypeScript to catch bugs early and make fixes
easy. For everything else, we have a robust cypress test suite so you can depend
on React Flow with confidence .

## Moving on

Now that you have a better idea of what React Flow is all about, the next page
will walk through some common terminology that you will see repeated throughout
the documentation: nodes, edges, and handles.

----
concepts/plugin-components.mdx
---
title: Plugin Components
description: React Flow comes with several additional components. Here's an overview of the minimap, controls, background, and panel components.
---

# Plugin Components

React Flow comes with several additional plugin components. In this guide we show you how to use them. We are using our [previous example code](/learn/concepts/core-concepts) here.

## MiniMap

If your flow gets bigger, you might want to get an overview quickly. For this we have built the [`MiniMap` component](/api-reference/components/minimap). You can easily add it to your flow by adding it as a children:

import ExampleViewer from '@/components/example-viewer';

<ExampleViewer
  codePath="api-flows/MiniMap"
  applyStyles={false}
  options={{ editorHeight: 500, editorWidthPercentage: 45, wrapContent: true }}
  additionalFiles={['nodes.js', 'edges.js']}
/>

## Controls

React Flow comes with a customizable controls bar, that you can use by importing the [`Controls` component](/api-reference/components/controls)

<ExampleViewer
  codePath="api-flows/Controls"
  applyStyles={false}
  options={{ editorHeight: 500, editorWidthPercentage: 45, wrapContent: true }}
  additionalFiles={['nodes.js', 'edges.js']}
/>

## Background

If you want to display the pattern background, you can use the [`Background` component](/api-reference/components/background)

<ExampleViewer
  codePath="api-flows/Background"
  applyStyles={false}
  options={{ editorHeight: 500, editorWidthPercentage: 45, wrapContent: true }}
  additionalFiles={['nodes.js', 'edges.js']}
/>

## Panel

A helper component to display content on top of the React Flow viewport. [`Panel` component](/api-reference/components/panel)

<ExampleViewer
  codePath="api-flows/Panel"
  applyStyles={false}
  options={{ editorHeight: 500, editorWidthPercentage: 45, wrapContent: true }}
  additionalFiles={['style.css']}
/>

----
concepts/core-concepts.mdx
---
title: Core Concepts
description: We'll show you the basic functionality of React Flow including connecting nodes and making controlled and uncontrolled flows.
---

# Core Concepts

In the following part we will introduce you to the core concepts of React Flow and explain how to create an interactive flow. A flow consists of nodes and edges (or just nodes). You can pass arrays of `nodes` and `edges` as props to the ReactFlow component. Hereby all node and edge ids need to be unique. A node needs a position and a label (this could be different if you are using [custom nodes](/learn/customization/custom-nodes)) and an edge needs a source (node id) and a target (node id). You can read more about the options in the [Node options](/api-reference/types/node) and [Edge options](/api-reference/types/edge) sections.

## Controlled or Uncontrolled

With React Flow you have two ways to setup a flow. You can either create a controlled or an [uncontrolled one](/learn/advanced-use/uncontrolled-flow).
We recommend to use a controlled one but for simpler use cases you can also setup an uncontrolled flow. **In the following part we will setup a controlled flow.** Let's start by adding some nodes and edges to the ReactFlow component:

import { Callout } from 'nextra/components';

<Callout type="warning">
  The dimensions of your React Flow component depend on the parent dimensions.
  That means that the parent needs a width and height to render React Flow
  properly.
</Callout>

import ExampleViewer from '@/components/example-viewer';

<ExampleViewer
  codePath="api-flows/IntroductionFlow"
  applyStyles={false}
  options={{
    editorHeight: 500,
    editorWidthPercentage: 45,
    wrapContent: true,
  }}
/>

## Basic Functionality

By default React Flow doesn't do any internal state updates besides handling the viewport when you setup a controlled flow. As with an `<input />` component you need to pass handlers to apply the changes that are triggered by React Flow to your nodes and edges. In order to **select**, **drag** and **remove** nodes and edges you need to implement an `onNodesChange` and an `onEdgesChange` handler:

<ExampleViewer
  codePath="api-flows/IntroductionFlow2"
  applyStyles={false}
  options={{
    editorHeight: 500,
    editorWidthPercentage: 45,
    wrapContent: true,
  }}
  additionalFiles={['nodes.js', 'edges.js']}
/>

What is happening here? Whenever React Flow triggers a change (node init, node drag, edge select, etc.), the `onNodesChange` handler gets called. We export an `applyNodeChanges` handler so that you don't need to handle the changes by yourself. The `applyNodeChanges` handler returns an updated array of nodes that is your new nodes array. You now have an interactive flow with the following kinds of interactions:

- selectable nodes and edges
- draggable nodes
- removable nodes and edges - (press Backspace to remove a selected node or edge, can be adjusted with the `deleteKeyCode` prop)
- multi-selection area by pressing Shift (that's the default `selectionKeyCode`)
- multi-selection by pressing command (that's the default `multiSelectionKeyCode`)

For convenience we export the helper hooks `useNodesState` and `useEdgesState` that you can use to create the nodes and edges state:

```js
const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);
const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);
```

## Connecting Nodes

The last piece that is missing to get the full interactivity is the `onConnect` handler. You need to implement it, in order to handle new connections.

<ExampleViewer
  codePath="api-flows/IntroductionFlow3"
  applyStyles={false}
  options={{
    editorHeight: 500,
    editorWidthPercentage: 45,
    wrapContent: true,
  }}
  additionalFiles={['nodes.js', 'edges.js']}
/>

In this example we are using the `addEdge` handler that returns an array of edges with the newly created one. If you want to set a certain edge option whenever an edge gets created you pass your options like this:

```js
const onConnect = useCallback(
  (connection) =>
    setEdges((eds) => addEdge({ ...connection, animated: true }, eds)),
  [setEdges],
);
```

or use the `defaultEdgeOptions` prop:

```jsx
const defaultEdgeOptions = { animated: true };
...
<ReactFlow
  nodes={nodes}
  edges={edges}
  onNodesChange={onNodesChange}
  onEdgesChange={onEdgesChange}
  onConnect={onConnect}
  defaultEdgeOptions={defaultEdgeOptions}
/>;
```

----
concepts/terms-and-definitions.mdx
---
title: Terms and Definitions
description: Learn about the basic terms and definitions of React Flow
---

# Terms and Definitions

import NodesFlow from '@/components/example-viewer/basic-terms/nodes';

In this part of the docs we are explaining some basic React Flow terms and definition. Three things you’ll be using a lot in React Flow are nodes, edges, and handles.

## Nodes

<NodesFlow />

A node in React Flow is a React component. That means it can render anything you like. Each node has an x- and y-coordinate, which tells it where it is placed in the viewport. By default, a node looks like in the example above. You can find all the options for customizing your nodes in the [Node options](/api-reference/types/node) documentation.

### Custom Nodes

This is where the magic of React Flow happens. You can customize nodes to look and act however you would like. Much of the functionality that you might create is not built-in to React Flow. Some of the things you might do with a custom node are:

- Render form elements
- Visualize data
- Support multiple handles

Please refer to the [custom node docs](/learn/customization/custom-nodes) for further information.

## Handles

import HandlesFlow from '@/components/example-viewer/basic-terms/handles';

<HandlesFlow />{' '}

A handle (also called “port” in other libraries) is the place where an edge attaches to a node. The handle can be placed anywhere, and styled as you like. It’s just a div element. By default, it appears as a grey circle on the top, bottom, left, or right of the node. When creating a custom node, you can have as many handles as you need in your node. More information can be found in the [handle docs](/api-reference/components/handle).

## Edges

import EdgesFlow from '@/components/example-viewer/basic-terms/edges';

<EdgesFlow />

An edge connects two nodes. Every edge needs a target and a source node. React Flow comes with four built-in [edges types](/examples/edges/edge-types): default (bezier), smoothstep, step and straight. An edge is SVG path that can be styled with CSS and is completely customizable. If you are using multiple handles, you can reference them individually to create multiple connections for a node.

### Custom Edges

Like custom nodes, you can also customize edges. Things that people do with custom edges are:

- Add a button to remove an edge
- Custom routing behaviour
- Complex styling or interactions that cannot be solved with just one SVG path

You can find more information on the [custom edges api](/api-reference/types/edge-props) site.

## Connection Line

React Flow has built-in functionality to click-and-drag from one handle to another in order to create a new edge. While dragging, the placeholder edge is called a connection line. The connection line also comes with four types built-in and is customizable. You can find the props for configuring the connection line in the [props section](/api-reference/react-flow#connection-line).

## Viewport

import ViewportFlow from '@/components/example-viewer/basic-terms/viewport';

<ViewportFlow />

All of React Flow exists inside of the viewport. The viewport has a x, y and zoom value. When you drag the pane, you change the x and y coordinates and when you zoom in or out you alter the zoom level.

----
layouting/_meta.json
{
  "layouting": "Layouting Libraries",
  "sub-flows": "Sub-Flows"
}

----
layouting/layouting.mdx
---
title: Layouting
description: React Flow doesn't include any layouting algorithms out of the box. This guide surveys some of the options out there and shows you how to use them with React Flow.
---

# Layouting

import { Callout } from 'nextra/components';
import ExampleViewer from '@/components/example-viewer';

We regularly get asked how to handle layouting in React Flow. While we could build
some basic layouting into React Flow, we believe that **you know your app's
requirements best** and with so many options out there we think it's better you
choose the best right tool for the job (not to mention it'd be a whole bunch of
work for us).

That doesn't help very much if you don't know what the options _are_, so this
guide is here to help! We'll split things up into resources for layouting nodes
and resources for routing edges.

To start let's put together a simple example flow that we can use as a base for
testing out the different layouting options.

<ExampleViewer
  codePath="api-flows/LayoutingFlow1-Empty"
  options={{ editorHeight: '50vh' }}
  applyStyles={true}
  additionalFiles={['nodes-edges.js']}
/>

Each of the examples that follow will be built on this empty flow. Where possible
we've tried to keep the examples confined to just one `index.js` file so it's easy
for you to compare how they're set up.

## Layouting Nodes

For layouting nodes, there are a few third-party libraries that we think are worth
checking out:

| Library                                            | Dynamic node sizes | Sub-flow layouting | Edge routing | Bundle size                                                                                                                                   |
| -------------------------------------------------- | ------------------ | ------------------ | ------------ | --------------------------------------------------------------------------------------------------------------------------------------------- |
| [Dagre](https://github.com/dagrejs/dagre)          | Yes                | Yes¹               | No           | <a href="https://pkg-size.dev/@dagrejs/dagre"><img src="https://pkg-size.dev/badge/bundle/39882" title="Bundle size for @dagrejs/dagre"/></a> |
| [D3-Hierarchy](https://github.com/d3/d3-hierarchy) | No                 | No                 | No           | <a href="https://pkg-size.dev/d3-hierarchy"><img src="https://pkg-size.dev/badge/bundle/14697" title="Bundle size for d3-hierarchy"/></a>     |
| [D3-Force](https://github.com/d3/d3-force)         | Yes                | No                 | No           | <a href="https://pkg-size.dev/d3-force"><img src="https://pkg-size.dev/badge/bundle/15623" title="Bundle size for d3-force"/></a>             |
| [ELK](https://github.com/kieler/elkjs)             | Yes                | Yes                | Yes          | <a href="https://pkg-size.dev/elkjs"><img src="https://pkg-size.dev/badge/bundle/1455420" title="Bundle size for elkjs"/></a>                 |

¹ Dagre currently has an [open issue](https://github.com/dagrejs/dagre/issues/238)
that prevents it from laying out sub-flows correctly if any nodes in the sub-flow
are connected to nodes outside the sub-flow.

We've loosely ordered these options from simplest to most complex, where dagre
is largely a drop-in solution and elkjs is a full-blown highly configurable
layouting engine. Below, we'll take a look at a brief example of how each of these
libraries can be used with React Flow. For dagre and elkjs specifically, we have
some separate examples you can refer back to [here](/examples/layout/dagre)
and [here](/examples/layout/elkjs).

### Dagre

- Repo: https://github.com/dagrejs/dagre
- Docs: https://github.com/dagrejs/dagre/wiki#configuring-the-layout

Dagre is a simple library for layouting directed graphs. It has minimal configuration
options and a focus on speed over choosing the most optimal layout. If you need
to organise your flows into a tree, _we highly recommend dagre_.

<ExampleViewer
  codePath="api-flows/LayoutingFlow2-Dagre"
  options={{ editorHeight: '50vh' }}
  applyStyles={false}
  additionalFiles={['nodes-edges.js']}
  dependencies={{ '@dagrejs/dagre': 'latest' }}
/>

With no effort at all we get a well-organised tree layout! Whenever
`getLayoutedElements` is called, we'll reset the dagre graph and set the graph's
direction (either left-to-right or top-to-bottom) based on the `direction` prop.
Dagre needs to know the dimensions of each node in order to lay them out, so we
iterate over our list of nodes and add them to dagre's internal graph.

After laying out the graph, we'll return an object with the layouted nodes and
edges. We do this by mapping over the original list of nodes and updating each
node's position according to node stored in the dagre graph.

Documentation for dagre's configuration options can be found
[here](https://github.com/dagrejs/dagre/wiki#configuring-the-layout), including
properties to set for spacing and alignment.

### D3-Hierarchy

- Repo: https://github.com/d3/d3-hierarchy
- Docs: https://d3js.org/d3-hierarchy

When you know your graph is a tree with a single root node, d3-hierarchy can
provide a handful of interesting layouting options. While the library can layout
a simple tree just fine, it also has layouting algorithms for tree maps, partition
layouts, and enclosure diagrams.

<ExampleViewer
  codePath="api-flows/LayoutingFlow3-D3-Hierarchy"
  options={{ editorHeight: '50vh' }}
  applyStyles={false}
  additionalFiles={['nodes-edges.js']}
  dependencies={{ 'd3-hierarchy': 'latest' }}
/>

<Callout>
  D3-hierarchy expects your graphs to have a single root node, so it won't work
  in all cases. It's also important to note that d3-hierarchy assigns the same
  width and height to _all_ nodes when calculating the layout, so it's not the
  best choice if you're displaying lots of different node types.
</Callout>

### D3-Force

- Repo: https://github.com/d3/d3-force
- Docs: https://d3js.org/d3-force

Force something more interesting than a tree, a force-directed layout might be
the way to go. D3-Force is a physics-based layouting library that can be used
position nodes by applying different forces to them.

As a consequence, it's a little more complicated to configure and use compared to
dagre and d3-hierarchy. Importantly, d3-force's layouting algorithm is iterative,
so we need a way to keep computing the layout across multiple renders.

First, let's see what it does:

<ExampleViewer
  codePath="api-flows/LayoutingFlow4-D3-Force"
  options={{ editorHeight: '50vh' }}
  applyStyles={false}
  additionalFiles={['nodes-edges.js', 'collide.js']}
  dependencies={{ 'd3-force': 'latest', 'd3-quadtree': 'latest' }}
/>

We've changed our `getLayoutedElements` to a hook called `useLayoutedElements`
instead. Additonally, instead of passing in the nodes and edges explicitly, we'll
use get `getNodes` and `getEdges` functions from the `useReactFlow` hook. This
is important when combined with the store selector in `initialised` because it
will prevent us from reconfiguring the simulation any time the nodes update.

The simulation is configured with a number of different forces applied so you
can see how they interact: play around in your own code to see how you want to
configure those forces. You can find the documentation and some different examples
of d3-force [here](https://d3js.org/d3-force).

<Callout>
  <strong>Rectangular collisions</strong>
  D3-Force has a built-in collision force, but it assumes nodes are circles. We've
  thrown together a custom force in `collision.js` that uses a similar algorithm
  but accounts for our rectangular nodes instead. Feel free to steal it or let us
  know if you have any suggestions for improvements!
</Callout>

The tick function progresses the simulation by one step and then updates React
Flow with the new node positions. We've also included a demonstration on how to
handle node dragging while the simulation is running: if your flow isn't interactive
you can ignore that part!

<Callout>
  For larger graphs, computing the force layout every render forever is going to
  incur a big performance hit. In this example we have a simple toggle to turn
  the layouting on and off, but you might want to come up with some other
  approach to only compute the layout when necessary.
</Callout>

### Elkjs

- Repo: https://github.com/kieler/elkjs
- Docs: https://eclipse.dev/elk/reference.html (good luck!)

Elkjs is certainly the most configurable option available, but it's also the most
complicated. Elkjs is a Java library that's been ported to JavaScript, and it
provides a huge number of options for configuring the layout of your graph.

<ExampleViewer
  codePath="api-flows/LayoutingFlow6-Elkjs"
  options={{ editorHeight: '50vh' }}
  applyStyles={false}
  additionalFiles={['nodes-edges.js']}
  dependencies={{ elkjs: 'latest' }}
/>

At it's most basic we can compute layouts similar to dagre, but because the layouting
algorithm runs asynchronously we need to create a `useLayoutedElements` hook similar
to the one we created for d3-force.

<Callout>
  <strong>The ELK reference is your new best friend</strong>
  We don't often recommend elkjs because it's complexity makes it difficult for us
  to support folks when they need it. If you do decide to use it, you'll want to
  keep the original [Java API reference](https://eclipse.dev/elk/reference.html)
  handy.
</Callout>

We've also included a few examples of some of the other layouting algorithms
available, including a non-interactive force layout.

### Honourable Mentions

Of course, we can't go through every layouting library out there: we'd never work
on anything else! Here are some other libraries we've come across that might be
worth taking a look at:

- If you want to use dagre or d3-hierarchy but need to support nodes with different
  dimensions, both [d3-flextree](https://github.com/klortho/d3-flextree) and
  [entitree-flex](https://github.com/codeledge/entitree-flex) look promising.

  You can find an example of how to use entitree-flex with React Flow
  [here](/examples/layout/entitree-flex).

- [Cola.js](https://github.com/tgdwyer/WebCola) looks like a promising option for
  so-called "constraint-based" layouts. We haven't had time to properly investigate
  it yet, but it looks like you can achieve results similar to d3-force but with
  a lot more control.

## Routing Edges

If you don't have any requirements for edge routing, you can use one of the
layouting libraries above to position nodes and let the edges fall wherever they
may. Otherwise, you'll want to look into some libraries and techniques for edge
routing.

Your options here are more limited than for node layouting, but here are some
resources we thought looked promising:

- [react-flow-smart-edge](https://github.com/tisoap/react-flow-smart-edge)
- [Routing Orthogonal Diagram Connectors in JavaScript](https://medium.com/swlh/routing-orthogonal-diagram-connectors-in-javascript-191dc2c5ff70)

If you do explore some custom edge routing options, consider contributing back to
the community by writing a blog post or creating a library!

Our [editable edge Pro Example](/examples/edges/editable-edge) could also be used
as a starting point for implementing a custom edge that can be routed along a
specific path.

----
layouting/sub-flows.mdx
---
title: Sub Flows
description: Learn how to use sub flows to group nodes together in a flow.
---

import { Callout } from 'nextra/components';

# Sub Flows

<Callout type="info">
  **Deprecation of `parentNode` property!** We have renamed the `parentNode`
  option to `parentId` in version 11.11.0. The old property is still supported
  but will be removed in version 12.
</Callout>

A sub flow is a flow inside a node. It can be a separate flow or a flow that is connected with other nodes outside of its parent. This feature can also be used for grouping nodes. In this part of the docs we are going to build a flow with sub flows and show you the child node specific options.

<Callout type="warning">
  <strong>Order of Nodes</strong>
  It's important that your parent nodes appear before their children in the `nodes`/
  `defaultNodes` array to get processed correctly.
</Callout>

### Adding Child Nodes

If you want to add a node as a child of another node you need to use the `parentId` (this was called `parentNode` in previous versions) option (you can find a list of all options in the [node options section](/api-reference/types/node)). Once we do that, the child node is positioned relative to its parent. A position of `{ x: 0, y: 0 }` is the top left corner of the parent.

In this example we are setting a fixed width and height of the parent node by passing the style option. Additionally, we set the child extent to `'parent'` so that we can't move the child nodes out of the parent node.

import ExampleViewer from '@/components/example-viewer';

<ExampleViewer
  codePath="api-flows/SubFlows"
  applyStyles={false}
  options={{ editorHeight: 500, editorWidthPercentage: 45, wrapContent: true }}
  activeFile="nodes.js"
  additionalFiles={['nodes.js', 'edges.js']}
/>

### Using Child Specific Options

When you move the parent node you can see that the child nodes move, too. Adding a node to another node with the `parentId` option, just does one thing: It positions it relatively to its parent. The child node is not really a child markup-wise. You can drag or position the child outside of its parent (when the `extent: 'parent'` option is not set) but when you move the parent, the child moves with it.

In the example above we are using the `group` type for the parent node but you can use any other type as well. The `group` type is just a convenience node type that has no handles attached.

Now we are going to add some more nodes and edges. As you can see, we can connect nodes within a group and create connections that go from a sub flow to an outer node:

<ExampleViewer
  codePath="api-flows/SubFlows2"
  applyStyles={false}
  options={{ editorHeight: 500, editorWidthPercentage: 45, wrapContent: true }}
  activeFile="nodes.js"
  additionalFiles={['nodes.js', 'edges.js']}
/>

### Using a Default Node Type as a Parent

Let's remove the label of node B and add some child nodes. In this example you can see that you can use one of the default node types as parents, too. We also set the child nodes to `draggable: false` so that they are not draggable anymore.

<ExampleViewer
  codePath="api-flows/SubFlows3"
  applyStyles={false}
  options={{ editorHeight: 500, editorWidthPercentage: 45, wrapContent: true }}
  activeFile="nodes.js"
  additionalFiles={['nodes.js', 'edges.js']}
/>

----
tutorials/_meta.json
{
  "*": {
    "theme": {
      "toc": true,
      "sidebar": true,
      "pagination": false,
      "layout": "full"
    }
  },
  "index": {
    "title": "Tutorials",
    "display": "hidden",
    "theme": {
      "layout": "raw"
    }
  },
  "react-flow-and-the-web-audio-api": "Web Audio API",
  "mind-map-app-with-react-flow": "Mind Map App"
}

----
tutorials/react-flow-and-the-web-audio-api.mdx
---
title: 'Integrating React Flow and the Web Audio API'
intro: "Today we'll be looking at how to create an interactive audio playground using React Flow and the Web Audio API. We'll start from scratch, first learning about the Web Audio API before looking at how to handle many common scenarios in React Flow: state management, implementing custom nodes, and adding interactivity."
date: 2023/04/14
authors: ['hayleigh']
tags: ['react-flow', 'web-audio-api', 'how-to']
image: /img/tutorials/webaudio/web-audio-blog-thumb.png
---

import { Callout, Tab, Tabs } from 'nextra/components';
import { Bleed } from 'nextra-theme-docs';
import { Embed, Image } from 'xy-shared';
import { Emoji } from '@xyflow/xy-ui';

import { BlogExampleViewer } from '@/components/example-viewer/blog-embed';
import { TutorialLayout } from '@/layouts/tutorial-with-frontmatter';

<TutorialLayout>
Today we'll be looking at how to create an interactive audio playground using React
Flow and the Web Audio API. We'll start from scratch, first learning about the Web
Audio API before looking at how to handle many common scenarios in React Flow:
state management, implementing custom nodes, and adding interactivity.

<Bleed>
  <Image
    src="/img/tutorials/webaudio/bleep-cafe.png"
    alt="A screenshot of bleep.cafe, a visual audio programming environment. In it,
    there are four nodes connected together: an xy pad, an oscillator node, a
    volume node, and a master output."
    wide
    caption="This is bleep.cafe. We're going to learn everything we need to know to
    build something just like it!"
  />
</Bleed>

A while back I shared a project I was working on to the React Flow
[discord server](https://discord.com/invite/RVmnytFmGW). It's called
[bleep.cafe](https://bleep.cafe) and it's a little web app for learning digital
synthesis all inside the browser. A lot of folks were interested to see how something
like that was put together: most people don't even know **their browser has a whole
synth engine built in!**

This tutorial will take us step-by-step to build something similar. We may skip
over some bits here and there, but for the most part if you're new to React Flow
_or_ the Web Audio API you should be able to follow along and have something
working by the end.

If you're already a React Flow wizard you might want to read the first section
covering the Web Audio API and then jump to the third to see how things are tied
together!

But first...

## A demo!

<Bleed>
  <Embed src="https://xyflow.github.io/react-flow-web-audio/" />
</Bleed>

<Callout type="warning">
This and other examples in this tutorial _make sound_.

To avoid creating an avant-garde masterpiece, remember to mute each example before
moving on!

</Callout>

## The Web Audio API

Before we get stuck in to React Flow and interactive node editor goodness, we need
to take a crash course on the [Web Audio API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API).
Here are the highlights you need to know:

- The Web Audio API provides a variety of different audio nodes, including sources
  (e.g. [OscillatorNode](https://developer.mozilla.org/en-US/docs/Web/API/OscillatorNode),
  [MediaElementAudioSourceNode](https://developer.mozilla.org/en-US/docs/Web/API/MediaElementAudioSourceNode)),
  effects (e.g. [GainNode](https://developer.mozilla.org/en-US/docs/Web/API/GainNode),
  [DelayNode](https://developer.mozilla.org/en-US/docs/Web/API/DelayNode),
  [ConvolverNode](https://developer.mozilla.org/en-US/docs/Web/API/ConvolverNode)),
  and outputs (e.g. [AudioDestinationNode](https://developer.mozilla.org/en-US/docs/Web/API/AudioDestinationNode)).
- Audio nodes can be connected together to form a (potentially cyclic) graph.
  We tend to call this the audio-processing graph, signal graph, or signal chain.
- Audio processing is handled in a separate thread by native code. This means we
  can keep generating sounds even when the main UI thread is busy or blocked.
- An [AudioContext](https://developer.mozilla.org/en-US/docs/Web/API/AudioContext)
  acts as the brain of an audio-processing graph. We can use it to create new audio
  nodes and suspend or resume audio processing entirely.

### Hello, sound!

Let's see some of this stuff in action and build our first Web Audio app! We won't
be doing anything too wild: we'll make a simple mouse
[theremin](http://www.thereminworld.com/Article/14232/what-s-a-theremin-). We'll
use React for these examples and everything else moving forward (we're called React
Flow after all!) and [`vite`](https://vitejs.dev) to handle bundling and hot
reloading.

If you prefer another bundler like parcel or Create React App that's cool too, they
all do largely the same thing. You could also choose to use TypeScript instead
of JavaScript. To keep things simple we won't use it today, but React Flow is
fully typed (and written entirely in TypeScript) so it's a breeze to use!

```bash
npm create vite@latest -- --template react
```

Vite will scaffold out a simple React application for us, but can delete the assets
and jump right into `App.jsx`. Remove the demo component generated for us and start
by creating a new AudioContext and putting together the nodes we need. We want
an OscillatorNode to generate some tones and a GainNode to control the volume.

```js filename="./src/App.jsx"
// Create the brain of our audio-processing graph
const context = new AudioContext();

// Create an oscillator node to generate tones
const osc = context.createOscillator();

// Create a gain node to control the volume
const amp = context.createGain();

// Pass the oscillator's output through the gain node and to our speakers
osc.connect(amp);
amp.connect(context.destination);

// Start generating those tones!
osc.start();
```

<Callout type="info">
Oscillator nodes need to be started.

Don't forget that call to `osc.start`. The oscillator won't start generating
tones without it!

</Callout>

For our app, we'll track the mouse's position on the screen and use that to set
the pitch of the oscillator node and the volume of the gain node.

```jsx filename="./src/App.jsx" {12-27}
import React from 'react';

const context = new AudioContext();
const osc = context.createOscillator();
const amp = context.createGain();

osc.connect(amp);
amp.connect(context.destination);

osc.start();

const updateValues = (e) => {
  const freq = (e.clientX / window.innerWidth) * 1000;
  const gain = e.clientY / window.innerHeight;

  osc.frequency.value = freq;
  amp.gain.value = gain;
};

export default function App() {
  return (
    <div
      style={{ width: '100vw', height: '100vh' }}
      onMouseMove={updateValues}
    />
  );
}
```

<Callout type="info">
`osc.frequency.value`, `amp.gain.value`...

The Web Audio API makes a distinction between simple object properties and audio
node _parameters_. That distinction appears in the form of an `AudioParam`. You
can read up on them in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/API/AudioParam)
but for now it's enough to know that you need to use `.value` to set the value
of an `AudioParam` rather than just assigning a value to the property directly.

</Callout>

If you try this example as it is, you'll probably find that nothing happens. An
AudioContext often starts in a suspended state in an attempt to avoid ads hijacking
our speakers. We can fix that easily by adding a click handler on the `<div />`
to resume the context if it's suspended.

```jsx filename="./src/App.jsx" {1-7,12}
const toggleAudio = () => {
  if (context.state === 'suspended') {
    context.resume();
  } else {
    context.suspend();
  }
};

export default function App() {
  return (
    <div ...
      onClick={toggleAudio}
    />
  );
};
```

And that's everything we need to start making some sounds with the Web Audio API!
Here's what we put together, in case you weren't following along at home:

<Bleed>
  <BlogExampleViewer
    codePath="blog-flows/webaudio/MouseTheremin"
    additionalFiles={['index.css']}
    showEditor={false}
  />
</Bleed>

Now let's put this knowledge to one side and take a look at how to build a React
Flow project from scratch.

<Callout type="info">
  Already a React Flow pro? If you're already familiar with React Flow, you can
  comfortably skip over the next section and head straight on over to [making
  some sounds](#do-sound-to-it). For everyone else, let's take a look at how to
  build a React Flow project from scratch.
</Callout>

## Scaffolding a React Flow project

Later on we'll take what we've learned about the Web Audio API, oscillators, and
gain nodes and use React Flow to interactively build audio-processing graphs.
For now though, we need to put together an empty React Flow app.

We already have a React app set up with Vite, so we'll keep using that. If you
skipped over the last section, we ran `npm create vite@latest -- --template react`
to get started. You can use whatever bundler and/or dev server you like, though.
Nothing here is vite specific.

We only need three additional dependencies for this project: `@xyflow/react` for our
UI (obviously!), `zustand` as our simple state management library (that's what we use
under the hood at React Flow) and `nanoid` as a lightweight id generator.

```bash
npm install @xyflow/react zustand nanoid
```

We're going to remove everything from our Web Audio crash course and start from
scratch. Start by modifying `main.jsx` to match the following:

```jsx filename="./src/main.jsx"
import App from './App';
import React from 'react';
import ReactDOM from 'react-dom/client';
import { ReactFlowProvider } from '@xyflow/react';

// 👇 Don't forget to import the styles!
import '@xyflow/react/dist/style.css';
import './index.css';

const root = document.querySelector('#root');

ReactDOM.createRoot(root).render(
  <React.StrictMode>
    {/* React flow needs to be inside an element with a known height and width to work */}
    <div style={{ width: '100vw', height: '100vh' }}>
      <ReactFlowProvider>
        <App />
      </ReactFlowProvider>
    </div>
  </React.StrictMode>,
);
```

There are three important things to pay attention to here:

1. You need to remember to **import the React Flow CSS styles** to make sure everything
   works correctly.
2. The React Flow renderer needs to be inside an element with a known height and width,
   so we've set the containing `<div />` to take up the entire screen.
3. To use some of the hooks React Flow provides, your components need to be inside a
   `<ReactFlowProvider />` or inside the `<ReactFlow />` component itself, so we've
   wrapped the entire app in the provider to be sure.

Next, hop into `App.jsx` and create an empty flow:

```jsx filename="./src/App.jsx"
import React from 'react';
import { ReactFlow, Background } from '@xyflow/react';

export default function App() {
  return (
    <ReactFlow>
      <Background />
    </ReactFlow>
  );
}
```

We'll expand and add on to this component over time. For now, we've added one of
React Flow's plugins - [`<Background />`](/api-reference/components/background) -
to check if everything is setup correctly. Go ahead and run `npm run dev` (or
whatever you need to do to spin up a dev server if you didn't choose vite) and
check out your browser. You should see an empty flow:

<Image
  src="/img/tutorials/webaudio/empty-flow.png"
  alt="Screenshot of an empty React Flow graph"
/>

Leave the dev server running. We can keep checking back on our progress as we add
new bits and bobs.

### 1. State management with Zustand

A Zustand store will hold all the UI state for our application. In practical terms
that means it'll hold the nodes and edges of our React Flow graph, a few other
pieces of state, and a handful of _actions_ to update that state.

To get a basic interactive React Flow graph going we need three actions:

1. `onNodesChange` to handle nodes being moved around or deleted.
2. `onEdgesChange` to handle _edges_ being moved around or deleted.
3. `addEdge` to connect two nodes in the graph.

Go ahead and create a new file, `store.js`, and add the following:

```js filename="./src/store.js"
import { applyNodeChanges, applyEdgeChanges } from '@xyflow/react';
import { nanoid } from 'nanoid';
import { create } from 'zustand';

export const useStore = create((set, get) => ({
  nodes: [],
  edges: [],

  onNodesChange(changes) {
    set({
      nodes: applyNodeChanges(changes, get().nodes),
    });
  },

  onEdgesChange(changes) {
    set({
      edges: applyEdgeChanges(changes, get().edges),
    });
  },

  addEdge(data) {
    const id = nanoid(6);
    const edge = { id, ...data };

    set({ edges: [edge, ...get().edges] });
  },
}));
```

Zustand is dead simple to use. We create a function that receives both a `set` and
a `get` function and returns an object with our initial state along with the actions
we can use to update that state. Updates happen immutably and we can use the `set`
function for that. The `get` function is how we read the current state. And...
that's it for zustand.

The `changes` argument in both `onNodesChange` and `onEdgesChange` represents
events like a node or edge being moved or deleted. Fortunately, React Flow provides
some [helper](/api-reference/utils/apply-node-changes)
[functions](/api-reference/utils/apply-edge-changes) to apply those changes
for us. We just need to update the store with the new array of nodes.

`addEdge` will be called whenever two nodes get connected. The `data` argument is
_almost_ a valid edge, it's just missing an id. Here we're getting nanoid to
generate a 6 character random id and then adding the edge to our graph, nothing
exciting.

If we hop back over to our `<App />` component we can hook React Flow up to our
actions and get something working.

```jsx filename="./src/App.jsx" {3,5,7-13,16,20-24}
import React from 'react';
import { ReactFlow, Background } from '@xyflow/react';
import { shallow } from 'zustand/shallow';

import { useStore } from './store';

const selector = (store) => ({
  nodes: store.nodes,
  edges: store.edges,
  onNodesChange: store.onNodesChange,
  onEdgesChange: store.onEdgesChange,
  addEdge: store.addEdge,
});

export default function App() {
  const store = useStore(selector, shallow);

  return (
    <ReactFlow
      nodes={store.nodes}
      edges={store.edges}
      onNodesChange={store.onNodesChange}
      onEdgesChange={store.onEdgesChange}
      onConnect={store.addEdge}
    >
      <Background />
    </ReactFlow>
  );
}
```

So what's this `selector` thing all about? Zustand let's us supply a selector
function to pluck out the exact bits of state we need from the store. Combined
with the `shallow` equality function, this means we typically don't have re-renders
when state we don't care about changes.

Right now, our store is small and we actually want everything from it to help
render our React Flow graph, but as we expand on it this selector will make sure
we're not re-rendering _everything_ all the time.

This is everything we need to have an interactive graph: we can move nodes around,
connect them together, and remove them. To demonstrate, _temporarily_ add some
dummy nodes to your store:

```js filename="./store.jsx" {2-6}
const useStore = create((set, get) => ({
  nodes: [
    { id: 'a', data: { label: 'oscillator' }, position: { x: 0, y: 0 } },
    { id: 'b', data: { label: 'gain' }, position: { x: 50, y: 50 } },
    { id: 'c', data: { label: 'output' }, position: { x: -50, y: 100 } }
  ],
  ...
}));
```

<Bleed>
  <BlogExampleViewer
    codePath="blog-flows/webaudio/StateManagement"
    additionalFiles={['store.js']}
    dependencies={{ nanoid: 'latest', zustand: '4.3.6' }}
    showEditor={true}
  />
</Bleed>

### 2. Custom nodes

OK great, we have an interactive React Flow instance we can start playing with.
We added some dummy nodes but they're just the default unstyled ones right now.
In this step we'll add three custom nodes with interactive controls:

1. An oscillator node and controls for the pitch and waveform type.
2. A gain node and a control for the volume
3. An output node and a button to toggle audio processing on and off.

Let's create a new folder, `nodes/`, and create a file for each custom node we
want to create. Starting with the oscillator we need two controls and a source
handle to connect the output of the oscillator to other nodes.

```jsx filename="./src/nodes/Osc.jsx"
import React from 'react';
import { Handle } from '@xyflow/react';

import { useStore } from '../store';

export default function Osc({ id, data }) {
  return (
    <div>
      <div>
        <p>Oscillator Node</p>

        <label>
          <span>Frequency</span>
          <input
            className="nodrag"
            type="range"
            min="10"
            max="1000"
            value={data.frequency} />
          <span>{data.frequency}Hz</span>
        </label>

        <label>
          <span>Waveform</span>
          <select className="nodrag" value={data.type}>
            <option value="sine">sine</option>
            <option value="triangle">triangle</option>
            <option value="sawtooth">sawtooth</option>
            <option value="square">square</option>
          </select>
      </div>

      <Handle type="source" position="bottom" />
    </div>
  );
};
```

<Callout type="info">
"nodrag" is important.

Pay attention to the `"nodrag"` class being added to both the `<input />` and
`<select />` elements. It's _super important_ that you remember to add this class
otherwise you'll find that React Flow intercepts the mouse events and you'll be
stuck dragging the node around forever!

</Callout>

If we try rendering this custom node we'll find that the inputs don't do anything.
That's because the input values are fixed by `data.frequency` and `data.type` but
we have no event handlers listening to changes and no mechanism to update a node's
data!

To fix the situation we need to jump back to our store and add an `updateNode` action:

```js filename="./src/store.js"
export const useStore = create((set, get) => ({
  ...

  updateNode(id, data) {
    set({
      nodes: get().nodes.map(node =>
        node.id === id
          ? { ...node, data: { ...node.data, ...data } }
          : node
      )
    });
  },

  ...
}));
```

This action will handle partial data updates, such that if we only want to update a
node's `frequency`, for example, we could just call `updateNode(id, { frequency: 220 }`.
Now we just need to bring the action into our `<Osc />` component and call it
whenever an input changes.

```jsx filename="./src/nodes/Osc.jsx" {3,7-10,13,28,35}
import React from 'react';
import { Handle } from '@xyflow/react';
import { shallow } from 'zustand/shallow';

import { useStore } from '../store';

const selector = (id) => (store) => ({
  setFrequency: (e) => store.updateNode(id, { frequency: +e.target.value }),
  setType: (e) => store.updateNode(id, { type: e.target.value }),
});

export default function Osc({ id, data }) {
  const { setFrequency, setType } = useStore(selector(id), shallow);

  return (
    <div>
      <div>
        <p>Oscillator Node</p>

        <label>
          <span>Frequency:</span>
          <input
            className="nodrag"
            type="range"
            min="10"
            max="1000"
            value={data.frequency}
            onChange={setFrequency}
          />
          <span>{data.frequency}Hz</span>
        </label>

        <label>
          <span>Waveform:</span>
          <select className="nodrag" value={data.type} onChange={setType}>
            <option value="sine">sine</option>
            <option value="triangle">triangle</option>
            <option value="sawtooth">sawtooth</option>
            <option value="square">square</option>
          </select>
        </label>
      </div>

      <Handle type="source" position="bottom" />
    </div>
  );
}
```

Hey, that `selector` is back! Notice how this time we're using it to derive
two event handlers, `setFrequency` and `setType`, from the general `updateNode`
action.

The last piece of the puzzle is to tell React Flow how to render our custom node.
For that we need to create a `nodeTypes` object: the keys should correspond to a
node's `type` and the value will be the React component to render.

```jsx filename="./src/App.jsx" {5,16-18,26}
import React from 'react';
import { ReactFlow } from '@xyflow/react';
import { shallow } from 'zustand/shallow';

import { useStore } from './store';
import Osc from './nodes/Osc';

const selector = (store) => ({
  nodes: store.nodes,
  edges: store.edges,
  onNodesChange: store.onNodesChange,
  onEdgesChange: store.onEdgesChange,
  addEdge: store.addEdge,
});

const nodeTypes = {
  osc: Osc,
};

export default function App() {
  const store = useStore(selector, shallow);

  return (
    <ReactFlow
      nodes={store.nodes}
      nodeTypes={nodeTypes}
      edges={store.edges}
      onNodesChange={store.onNodesChange}
      onEdgesChange={store.onEdgesChange}
      onConnect={store.addEdge}
    >
      <Background />
    </ReactFlow>
  );
}
```

<Callout type="info">
Avoid unnecessary renders.

It's important to define `nodeTypes` outside of the `<App />` component (or use
React's [`useMemo`](https://react.dev/reference/react/useMemo)) to avoid recomputing
it every render.

</Callout>

If you've got the dev server running, don't panic if things haven't changed yet!
None of our temporary nodes have been given the right type yet, so React Flow
just falls back to rendering the default node. If we change one of those nodes to
be an `osc` with some initial values for `frequency` and `type` we should see
our custom node being rendered.

```js title"./src/store.js"
const useStore = create((set, get) => ({
  nodes: [
    { type: 'osc',
      id: 'a',
      data: { frequency: 220, type: 'square' },
      position: { x: 0, y: 0 }
    },
    ...
  ],
  ...
}));
```

<Bleed>
  <BlogExampleViewer
    codePath="blog-flows/webaudio/CustomNode"
    additionalFiles={['store.js', 'nodes/Osc.js']}
    dependencies={{ nanoid: 'latest', zustand: '4.3.6', twind: 'latest' }}
    showEditor={false}
  />
</Bleed>

<Callout type="info">
Stuck on styling?

If you're just implementing the code from this post as you go along, you'll
see that your custom node doesn't look like the one in the preview above. To keep
things easy to digest, we've left out styling in the code snippets.

To learn how to style your custom nodes, check out our docs on
[theming](/learn/customization/theming) or our example using
[Tailwind](/examples/styling/tailwind).

</Callout>

Implementing a gain node is pretty much the same process, so we'll leave that one
to you. Instead, we'll turn our attention to the output node. This node will
have no parameters control, but we do want to toggle signal processing on and off.
That's a bit difficult right now when we haven't implemented any audio code yet,
so in the meantime we'll add just a flag to our store and an action to toggle it.

```js filename="./src/store.js"
const useStore = create((set, get) => ({
  ...

  isRunning: false,

  toggleAudio() {
    set({ isRunning: !get().isRunning });
  },

  ...
}));
```

The custom node itself is then pretty simple:

```jsx filename="./src/nodes/Out.jsx"
import React from 'react';
import { Handle } from '@xyflow/react';
import { shallow } from 'zustand/shallow';
import { useStore } from '../store';

const selector = (store) => ({
  isRunning: store.isRunning,
  toggleAudio: store.toggleAudio,
});

export default function Out({ id, data }) {
  const { isRunning, toggleAudio } = useStore(selector, shallow);

  return (
    <div>
      <Handle type="target" position="top" />

      <div>
        <p>Output Node</p>

        <button onClick={toggleAudio}>
          {isRunning ? (
            <span role="img" aria-label="mute">
              🔇
            </span>
          ) : (
            <span role="img" aria-label="unmute">
              🔈
            </span>
          )}
        </button>
      </div>
    </div>
  );
}
```

Things are starting to shape up quite nicely!

<Bleed>
  <BlogExampleViewer
    codePath="blog-flows/webaudio/CustomNodes"
    additionalFiles={[
      'store.js',
      'nodes/Osc.js',
      'nodes/Out.js',
      'nodes/Amp.js',
    ]}
    dependencies={{ nanoid: 'latest', zustand: '4.3.6', twind: 'latest' }}
    showEditor={false}
  />
</Bleed>

The next step, then, is to…

## Do sound to it

We have an interactive graph and we're able to update node data, now let's add
in what we know about the Web Audio API. Start by creating a new file, `audio.js`,
and create a new audio context and an empty `Map`.

```js filename="./src/audio.js"
const context = new AudioContext();
const nodes = new Map();
```

The way we'll manage our audio graph is by hooking into the different actions in
our store. So we might connect two audio nodes when the `addEdge` action is called,
or update an audio node's properties when `updateNode` is called, and so on.

<Callout type="warning">
Hardcoded nodes

We hardcoded a couple of nodes in our store earlier on in this post but our audio
graph doesn't know anything about them! For the finished project we can do away
with all these hardcoded bits, but for now it's **really important** that we also
hardcode some audio nodes.

Here's how we did it:

```js filename="./src/audio.js" {4-7,9-10,12,14-16}
const context = new AudioContext();
const nodes = new Map();

const osc = context.createOscillator();
osc.frequency.value = 220;
osc.type = 'square';
osc.start();

const amp = context.createGain();
amp.gain.value = 0.5;

const out = context.destination;

nodes.set('a', osc);
nodes.set('b', amp);
nodes.set('c', out);
```

</Callout>

### 1. Node changes

Right now, there are two types of node changes that can happen in our graph and
that we need to respond to: updating a node's `data`, and removing a node from the
graph. We already have an action for the former, so let's handle that first.

In `audio.js` we'll define a function, `updateAudioNode`, that we'll call with a
node's id and a partial `data` object and use it to update an existing node in
the `Map`:

```js filename="./src/audio.js"
export function updateAudioNode(id, data) {
  const node = nodes.get(id);

  for (const [key, val] of Object.entries(data)) {
    if (node[key] instanceof AudioParam) {
      node[key].value = val;
    } else {
      node[key] = val;
    }
  }
}
```

<Callout type="info">
  Remember that properties on an audio node may be special `AudioParams` that
  must be updated differently to regular object properties.
</Callout>

Now we'll want to update our `updateNode` action in the store to call this function
as part of the update:

```js filename="./src/store.js"
import { updateAudioNode } from './audio';

export const useStore = create((set, get) => ({
  ...

  updateNode(id, data) {
    updateAudioNode(id, data);
    set({ nodes: ... });
  },

  ...
}));

```

The next change we need to handle is removing a node from the graph. If you select
a node in the graph and hit backspace, React Flow will remove it. This is implicitly
handled for us by the `onNodesChange` action we hooked up, but now we want some
additional handling we'll need to wire up a new action to React Flow's `onNodesDelete`
event.

This is actually pretty simple, so I'll save you some reading and present the next
three snippets of code without comment.

<Tabs items={['./src/audio.js', ',/src/store.js', './src/App.jsx']}>
  <Tab>

```js
export function removeAudioNode(id) {
  const node = nodes.get(id);

  node.disconnect();
  node.stop?.();

  nodes.delete(id);
}
```

  </Tab>
  <Tab>

```js
import { ..., removeAudioNode } from './audio';

export const useStore = create((set, get) => ({
  ...

  removeNodes(nodes) {
    for (const { id } of nodes) {
      removeAudioNode(id)
    }
  },

  ...
}));
```

  </Tab>
  <Tab>

```jsx
const selector = store => ({
  ...,
  onNodesDelete: store.removeNodes
});

export default function App() {
  const store = useStore(selector, shallow);

  return (
    <ReactFlow
      onNodesDelete={store.onNodesDelete}
      ...
    >
      <Background />
    </ReactFlow>
  )
};
```

  </Tab>
</Tabs>

The only thing to note is that `onNodesDelete` calls the provided callback with
an _array_ of deleted nodes, because it is possible to delete more than one node
at once!

### 2. Edge changes

We're getting super close to actually making some sounds! All that's left is to
handle changes to our graph's edges. Like with node changes, we already have an
action to handle creating new edges and we're also implicitly handling removed
edges in `onEdgesChange`.

To handle new connections, we just need the `source` and `target` ids from the
edge created in our `addEdge` action. Then we can just look up the two nodes in
our `Map` and connect them up.

<Tabs items={["./src/audio.js", "./src/store.js"]}>
  <Tab >

```js
export function connect(sourceId, targetId) {
  const source = nodes.get(sourceId);
  const target = nodes.get(targetId);

  source.connect(target);
}
```

  </Tab>
  <Tab >

```js
import { ..., connect } from './audio';

export const useStore = create((set, get) => ({
  ...

  addEdge(data) {
    ...

    connect(data.source, data.target);
  },

  ...
}));
```

  </Tab>
</Tabs>

We saw React Flow accepted an `onNodesDelete` handler and wouldn't you know it,
there's an `onEdgesDelete` handler too! The approach we'd take to implement `disconnect`
and hook it up to our store and React Flow instance is pretty much the same as
before, so we'll leave that one down to you as well!

### 3. Switching the speakers on

You'll remember that our `AudioContext` probably begins in a suspended state to
prevent potentially annoying autoplay issues. We already faked the data and actions
we need for our `<Out />` component in the store, now we just need to replace
them with the real context's state and resume/suspend methods.

```js filename="./src/audio.js"
export function isRunning() {
  return context.state === 'running';
}

export function toggleAudio() {
  return isRunning() ? context.suspend() : context.resume();
}
```

Although we haven't been returning anything from our audio functions up until now,
we need to return from `toggleAudio` because those methods are
asynchronous and we don't want to update the store prematurely!

```js filename="./src/store.js"
import { ..., isRunning, toggleAudio } from './audio'

export const useStore = create((set, get) => ({
  ...

  isRunning: isRunning(),

  toggleAudio() {
    toggleAudio().then(() => {
      set({ isRunning: isRunning() });
    });
  }
}));
```

Et voilà, we did it! We've now put enough together to actually _make sounds_!
Let's see what we have in action.

<Bleed>
  <BlogExampleViewer
    codePath="blog-flows/webaudio/HardcodedAudio"
    additionalFiles={[
      'store.js',
      'audio.js',
      'nodes/Osc.js',
      'nodes/Amp.js',
      'nodes/Out.js',
    ]}
    dependencies={{ nanoid: 'latest', zustand: '4.3.6', twind: 'latest' }}
    showEditor={false}
  />
</Bleed>

### 4. Creating new nodes

Up until now we have been dealing with a hard-coded set of nodes in our graph.
This has been fine for prototyping but for it to actually be useful we'll want a
way to add new nodes to the graph dynamically. Our final task will be adding this
functionality: we'll work backwards starting with the audio code and ending by
creating a basic toolbar.

Implementing a `createAudioNode` function will be simple enough. All we need is
an id for the new node, the type of node to create, and its initial data:

```js filename="./src/audio.js"
export function createAudioNode(id, type, data) {
  switch (type) {
    case 'osc': {
      const node = context.createOscillator();
      node.frequency.value = data.frequency;
      node.type = data.type;
      node.start();

      nodes.set(id, node);
      break;
    }

    case 'amp': {
      const node = context.createGain();
      node.gain.value = data.gain;

      nodes.set(id, node);
      break;
    }
  }
}
```

Next we'll need a `createNode` function in our store. The node id will be generated
by nanoid and we'll hardcode some initial data for each of the node types, so the
only thing we need to pass in is the type of node to create:

```js filename="./src/store.js"
import { ..., createAudioNode } from './audio';

export const useStore = create((set, get) => ({
  ...

  createNode(type) {
    const id = nanoid();

    switch(type) {
      case 'osc': {
        const data = { frequency: 440, type: 'sine' };
        const position = { x: 0, y: 0 };

        createAudioNode(id, type, data);
        set({ nodes: [...get().nodes, { id, type, data, position }] });

        break;
      }

      case 'amp': {
        const data = { gain: 0.5 };
        const position = { x: 0, y: 0 };

        createAudioNode(id, type, data);
        set({ nodes: [...get().nodes, { id, type, data, position }] });

        break;
      }
    }
  }
}));
```

We could be a bit smarter about calculating the position of the new node, but
to keep things simple we'll just hardcode it to `{ x: 0, y: 0 }` for now.

The final piece of the puzzle is to create a toolbar component that can trigger
the new `createNode` action. To do that we'll jump back to `App.jsx` and make use
of the [`<Panel />`](https://reactflow.dev/docs/api/plugin-components/panel/)
plugin component.

```jsx filename="./src/App.jsx"
...
import { ReactFlow,  Panel } from '@xyflow/react';
...

const selector = (store) => ({
  ...,
  createNode: store.createNode,
});

export default function App() {
  const store = useStore(selector, shallow);

  return (
    <ReactFlow>
      <Panel position="top-right">
        ...
      </Panel>
      <Background />
    </ReactFlow>
  );
};
```

We don't need anything fancy here, just a couple of buttons that trigger the
`createNode` action with the appropriate type:

```jsx filename="./src/App.jsx"
<Panel position="top-right">
  <button onClick={() => store.createNode('osc')}>osc</button>
  <button onClick={() => store.createNode('amp')}>amp</button>
</Panel>
```

And that's... everything! We've now got a fully functional audio graph editor
that can:

- Create new audio nodes
- Update node data with some UI controls
- Connect nodes together
- Delete nodes and connections
- Start and stop audio processing

Here's the demo from the beginning, but this time you can see the source code to
make sure you haven't missed anything.

<Bleed>
  <BlogExampleViewer
    codePath="blog-flows/webaudio/Demo"
    additionalFiles={[
      'store.js',
      'audio.js',
      'nodes/Osc.js',
      'nodes/Amp.js',
      'nodes/Out.js',
    ]}
    dependencies={{ nanoid: 'latest', zustand: '4.3.6', twind: 'latest' }}
    showEditor={true}
  />
</Bleed>

## Final thoughts

Whew that was a long one, but we made it! For our efforts we've come out the other
side with a fun little interactive audio playground, learned a little bit about
the Web Audio API along the way, and have a better idea of one approach to "running"
a React Flow graph.

If you've made it this far and are thinking "Hayleigh, I'm never going to write
a Web Audio app. Did I learn _anything_ useful?" Then you're in luck, because you
did! You could take our approach to connecting to the Web Audio API and apply it
to some other graph-based computation engine like [behave-graph](https://github.com/bhouston/behave-graph).
In fact, some has done just that and created [behave-flow](https://github.com/beeglebug/behave-flow)!

There are still plenty of ways to expand on this project. If you'd like to keep
working on it, here are some ideas:

- Add more node types.
- Allow nodes to connect to `AudioParams` on other nodes.
- Use the [`AnalyserNode`](https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode)
  to visualize the output of a node or signal.
- Anything else you can think of!

And if you're looking for inspiration, there are quite a few projects out in the
wild that are using node-based UIs for audio things. Some of my favourites are
[Max/MSP](https://cycling74.com/products/max/),
[Reaktor](https://www.native-instruments.com/en/products/komplete/synths/reaktor-6/),
and [Pure Data](https://puredata.info/). Max and Reaktor are closed-source commercial
software, but you can still steal some ideas from them <Emoji content="🕵️" />.

You can use the completed [source code](https://github.com/xyflow/react-flow-web-audio)
as a starting point, or you can just keep building on top of what we've made today.
We'd love to see what you build so please share it with us over on our
[Discord server](https://discord.com/invite/RVmnytFmGW)
or [Twitter](https://twitter.com/reactflowdev).

React Flow is an independent company financed by its users. If you want to support
us you can [sponsor us on Github](https://github.com/sponsors/xyflow) or
[subscribe to one of our Pro plans](https://reactflow.dev/pro/).

</TutorialLayout>

----
tutorials/mind-map-app-with-react-flow.mdx
---
title: 'Build a Mind Map App with React Flow'
intro: "In this tutorial, you will learn to create a simple mind map tool with React Flow that can be used for brainstorming, organizing an idea, or mapping your thoughts in a visual way. To build this app, we'll be using state management, custom nodes and edges, and more."
date: 2023/01/10
authors: ['moritz']
tags: ['react-flow', 'how-to', 'mind-map']
image: /img/tutorials/mindmap/mindmap.png
---

import { Callout, Tab, Tabs } from 'nextra/components';
import { Bleed } from 'nextra-theme-docs';
import { Emoji } from '@xyflow/xy-ui';

import { BlogExampleViewer } from '@/components/example-viewer/blog-embed';
import { TutorialLayout } from '@/layouts/tutorial-with-frontmatter';

<TutorialLayout>
In this tutorial, you will learn to create a simple mind map tool with React Flow that can be used for brainstorming, organizing an idea, or mapping your thoughts in a visual way. To build this app, we'll be using state management, custom nodes and edges, and more.

## <Emoji content="🎬" /> It's Demo Time!

Before we get our hands dirty, I want to show you the mindmapping tool we'll have by the end of this tutorial:

<Bleed>
  <BlogExampleViewer
    codePath="blog-flows/mindmap/App"
    additionalFiles={[
      'index.css',
      'MindMapNode.tsx',
      'MindMapEdge.tsx',
      'store.ts',
    ]}
    dependencies={{ nanoid: 'latest', zustand: '4.3.1' }}
    showEditor={false}
    isTypescript
  />
</Bleed>

If you'd like to live dangerously and dive right into the code, you can find the source code on [Github](https://github.com/xyflow/react-flow-mindmap-app).

## <Emoji content="👩🏻‍💻" /> Getting started

To do this tutorial you will need some knowledge of [React](https://reactjs.org/docs/getting-started.html) and [React Flow](/learn/concepts/terms-and-definitions) (hi, that's us! <Emoji content="😁" /> it's an open source library for building node-based UIs like workflow tools, ETL pipelines, and [more](https://reactflow.dev/showcase/).)

We'll be using [Vite](https://vitejs.dev/) to develop our app, but you can also use [Create React App](https://create-react-app.dev/) or any other tool you like. To scaffold a new React app with Vite you need to do:

```bash
npm create vite@latest reactflow-mind-map -- --template react
```

if you would like to use Typescript:

```bash
npm create vite@latest reactflow-mind-map -- --template react-ts
```

After the initial setup, you need to install some packages:

```bash
npm install reactflow zustand classcat nanoid
```

We are using [Zustand](https://github.com/pmndrs/zustand) for managing the state of our application. It's a bit like Redux but way smaller and there's less boilerplate code to write. React Flow also uses Zustand, so the installation comes with no additional cost. (For this tutorial we are using Typescript but you can also use plain Javascript.)

To keep it simple we are putting all of our code in the `src/App` folder. For this you need to create the `src/App` folder and add an index file with the following content:

#### src/App/index.tsx

```tsx
import { ReactFlow, Controls, Panel } from '@xyflow/react';

// we have to import the React Flow styles for it to work
import '@xyflow/react/dist/style.css';

function Flow() {
  return (
    <ReactFlow>
      <Controls showInteractive={false} />
      <Panel position="top-left">React Flow Mind Map</Panel>
    </ReactFlow>
  );
}

export default Flow;
```

This will be our main component for rendering the mind map. There are no nodes or edges yet, but we added the React Flow [`Controls`](/api-reference/components/controls) component and a [`Panel`](/api-reference/components/panel) to display the title of our app.

To be able to use React Flow hooks, we need to wrap the application with the [`ReactFlowProvider`](/api-reference/react-flow-provider) component in our main.tsx (entry file for vite). We are also importing the newly created `App/index.tsx` and render it inside the `ReactFlowProvider.` Your main file should look like this:

#### src/main.tsx

```tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import { ReactFlowProvider } from '@xyflow/react';

import App from './App';

import './index.css';

ReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(
  <React.StrictMode>
    <ReactFlowProvider>
      <App />
    </ReactFlowProvider>
  </React.StrictMode>,
);
```

The parent container of the React Flow component needs a width and a height to work properly. Our app is a fullscreen app, so we add these rules to the `index.css` file:

#### src/index.css

```css
body {
  margin: 0;
}

html,
body,
#root {
  height: 100%;
}
```

We are adding all styles of our app to the `index.css` file (you could also use a CSS-in-JS library like [Styled Components](/examples/styling/styled-components) or [Tailwind](/examples/styling/tailwind)). Now you can start the development server with `npm run dev` and you should see the following:

<Bleed>
  <BlogExampleViewer
    codePath="blog-flows/mindmap/GettingStarted"
    additionalFiles={['index.css']}
    dependencies={{ nanoid: 'latest', zustand: '4.3.1' }}
    isTypescript
  />
</Bleed>

## <Emoji content="🏪" /> A store for nodes and edges

As mentioned above, we are using Zustand for state management. For this, we create a new file in our `src/App` folder called `store.ts`:

#### src/App/store.ts

```ts
import {
  Edge,
  EdgeChange,
  Node,
  NodeChange,
  OnNodesChange,
  OnEdgesChange,
  applyNodeChanges,
  applyEdgeChanges,
} from '@xyflow/react';
import { createWithEqualityFn } from 'zustand/traditional';

export type RFState = {
  nodes: Node[];
  edges: Edge[];
  onNodesChange: OnNodesChange;
  onEdgesChange: OnEdgesChange;
};

const useStore = createWithEqualityFn<RFState>((set, get) => ({
  nodes: [
    {
      id: 'root',
      type: 'mindmap',
      data: { label: 'React Flow Mind Map' },
      position: { x: 0, y: 0 },
    },
  ],
  edges: [],
  onNodesChange: (changes: NodeChange[]) => {
    set({
      nodes: applyNodeChanges(changes, get().nodes),
    });
  },
  onEdgesChange: (changes: EdgeChange[]) => {
    set({
      edges: applyEdgeChanges(changes, get().edges),
    });
  },
}));

export default useStore;
```

It seems like a lot of code, but it's mostly types <Emoji content="😇" /> The store keeps track of the nodes and edges and handles the change events. When a user drags a node, React Flow fires a change event, the store then applies the changes and the updated nodes get rendered. (You can read more about this in our [state management library guide](/api-reference/hooks/use-store).)

As you can see we start with one initial node placed at `{ x: 0, y: 0 }` of type 'mindmap'. To connect the store with our app, we use the `useStore` hook:

#### src/App/index.tsx

```tsx
import { ReactFlow, Controls, Panel, NodeOrigin } from '@xyflow/react';
import { shallow } from 'zustand/shallow';

import useStore, { RFState } from './store';

// we have to import the React Flow styles for it to work
import '@xyflow/react/dist/style.css';

const selector = (state: RFState) => ({
  nodes: state.nodes,
  edges: state.edges,
  onNodesChange: state.onNodesChange,
  onEdgesChange: state.onEdgesChange,
});

// this places the node origin in the center of a node
const nodeOrigin: NodeOrigin = [0.5, 0.5];

function Flow() {
  // whenever you use multiple values, you should use shallow to make sure the component only re-renders when one of the values changes
  const { nodes, edges, onNodesChange, onEdgesChange } = useStore(
    selector,
    shallow,
  );

  return (
    <ReactFlow
      nodes={nodes}
      edges={edges}
      onNodesChange={onNodesChange}
      onEdgesChange={onEdgesChange}
      nodeOrigin={nodeOrigin}
      fitView
    >
      <Controls showInteractive={false} />
      <Panel position="top-left">React Flow Mind Map</Panel>
    </ReactFlow>
  );
}

export default Flow;
```

We access the nodes, edges and change handlers from the store and pass them to the React Flow component. We also use the `fitView` prop to make sure that the initial node is centered in the view and set the node origin to `[0.5, 0.5]` to set the origin to the center of a node. After this, your app should look like this:

<Bleed>
  <BlogExampleViewer
    codePath="blog-flows/mindmap/StoreNodesEdges"
    additionalFiles={['store.ts', 'index.css']}
    dependencies={{ nanoid: 'latest', zustand: '4.3.1' }}
    isTypescript
  />
</Bleed>

You can move the node around and zoom in and out, we are getting somewhere <Emoji content="🚀" /> Now let's add some more functionality.

## <Emoji content="✨" /> Custom nodes and edges

We want to use a custom type called 'mindmap' for our nodes. We need to add a new component for this. Let's create a new folder called `MindMapNode` with an index file under `src/App` with the following content:

#### src/App/MindMapNode/index.tsx

```tsx
import { Handle, NodeProps, Position } from '@xyflow/react';

export type NodeData = {
  label: string;
};

function MindMapNode({ id, data }: NodeProps<NodeData>) {
  return (
    <>
      <input defaultValue={data.label} />

      <Handle type="target" position={Position.Top} />
      <Handle type="source" position={Position.Bottom} />
    </>
  );
}

export default MindMapNode;
```

We are using an input for displaying and editing the labels of our mind map nodes, and two handles for connecting them. This is necessary for React Flow to work; the handles are used as the start and end position of the edges.

We also add some CSS to the `index.css` file to make the nodes look a bit prettier:

#### src/index.css

```css
.react-flow__node-mindmap {
  background: white;
  border-radius: 2px;
  border: 1px solid transparent;
  padding: 2px 5px;
  font-weight: 700;
}
```

(For more on this, you can read the [guide to custom nodes](/learn/customization/custom-nodes) in our docs.)

Let's do the same for the custom edge. Create a new folder called `MindMapEdge` with an index file under `src/App`:

#### src/App/MindMapEdge/index.tsx

```tsx
import { BaseEdge, EdgeProps, getStraightPath } from '@xyflow/react';

function MindMapEdge(props: EdgeProps) {
  const { sourceX, sourceY, targetX, targetY } = props;

  const [edgePath] = getStraightPath({
    sourceX,
    sourceY,
    targetX,
    targetY,
  });

  return <BaseEdge path={edgePath} {...props} />;
}

export default MindMapEdge;
```

I will get into more detail about the custom nodes and edges in the next section. For now it's important that we can use the new types in our app, by adding the following to our `Flow` component:

```tsx
import MindMapNode from './MindMapNode';
import MindMapEdge from './MindMapEdge';

const nodeTypes = {
  mindmap: MindMapNode,
};

const edgeTypes = {
  mindmap: MindMapEdge,
};
```

and then pass the newly created types to the React Flow component.

<BlogExampleViewer
  codePath="blog-flows/mindmap/CustomNodesEdges"
  additionalFiles={[
    'store.ts',
    'MindMapNode.tsx',
    'MindMapEdge.tsx',
    'index.css',
  ]}
  dependencies={{ nanoid: 'latest', zustand: '4.3.1' }}
  isTypescript
/>

Nice! We can already change the labels of our nodes by clicking in the input field and typing something.

## <Emoji content="🆕" /> New nodes

We want to make it super quick for a user to create a new node. The user should be able to add a new node by clicking on a node and drag to the position where a new node should be placed. This functionality is not built into React Flow, but we can implement it by using the [`onConnectStart` and `onConnectEnd`](/api-reference/react-flow#onconnectstart) handlers.

We are using the start handler to remember the node that was clicked and the end handler to create the new node:

#### Add to src/App/index.tsx

```tsx
const connectingNodeId = useRef<string | null>(null);

const onConnectStart: OnConnectStart = useCallback((_, { nodeId }) => {
  connectingNodeId.current = nodeId;
}, []);

const onConnectEnd: OnConnectEnd = useCallback((event) => {
  // we only want to create a new node if the connection ends on the pane
  const targetIsPane = (event.target as Element).classList.contains(
    'react-flow__pane',
  );

  if (targetIsPane && connectingNodeId.current) {
    console.log(`add new node with parent node ${connectingNodeId.current}`);
  }
}, []);
```

Since our nodes are managed by the store, we create an action to add a new node and its edge. This is how our `addChildNode` action looks:

#### New action in src/store.ts

```ts
addChildNode: (parentNode: Node, position: XYPosition) => {
  const newNode = {
    id: nanoid(),
    type: 'mindmap',
    data: { label: 'New Node' },
    position,
    parentNode: parentNode.id,
  };

  const newEdge = {
    id: nanoid(),
    source: parentNode.id,
    target: newNode.id,
  };

  set({
    nodes: [...get().nodes, newNode],
    edges: [...get().edges, newEdge],
  });
};
```

We are using the passed node as a parent. Normally this feature is used to implement [grouping](/examples/nodes/dynamic-grouping) or [sub flows](/examples/layout/sub-flows). Here we are using it to move all child nodes when their parent is moved. It enables us to clean up and re-order the mind map so that we don't have to move all child nodes manually. Let's use the new action in our `onConnectEnd` handler:

#### Adjustments in src/App/index.tsx

```tsx
const store = useStoreApi();

const onConnectEnd: OnConnectEnd = useCallback(
  (event) => {
    const { nodeLookup } = store.getState();
    const targetIsPane = (event.target as Element).classList.contains(
      'react-flow__pane',
    );

    if (targetIsPane && connectingNodeId.current) {
      const parentNode = nodeLookup.get(connectingNodeId.current);
      const childNodePosition = getChildNodePosition(event, parentNode);

      if (parentNode && childNodePosition) {
        addChildNode(parentNode, childNodePosition);
      }
    }
  },
  [getChildNodePosition],
);
```

First we are getting the `nodeLookup` from the React Flow store via `store.getState()`. `nodeLookup` is a map that contains all nodes and their current state. We need it to get the position and dimensions of the clicked node. Then we check if the target of the onConnectEnd event is the React Flow pane. If it is, we want to add a new node. For this we are using our `addChildNode` and the newly created `getChildNodePosition` helper function.

#### Helper function in src/App/index.tsx

```tsx
const getChildNodePosition = (event: MouseEvent, parentNode?: Node) => {
  const { domNode } = store.getState();

  if (
    !domNode ||
    // we need to check if these properites exist, because when a node is not initialized yet,
    // it doesn't have a positionAbsolute nor a width or height
    !parentNode?.computed?.positionAbsolute ||
    !parentNode?.computed?.width ||
    !parentNode?.computed?.height
  ) {
    return;
  }

  const panePosition = screenToFlowPosition({
    x: event.clientX,
    y: event.clientY,
  });

  // we are calculating with positionAbsolute here because child nodes are positioned relative to their parent
  return {
    x:
      panePosition.x -
      parentNode.computed?.positionAbsolute.x +
      parentNode.computed?.width / 2,
    y:
      panePosition.y -
      parentNode.computed?.positionAbsolute.y +
      parentNode.computed?.height / 2,
  };
};
```

This function returns the position of the new node we want to add to our store. We are using the [`project` function](/api-reference/types/react-flow-instance#project) to convert screen coordinates into React Flow coordinates. As mentioned earlier, child nodes are positioned relative to their parents. That's why we need to subtract the parent position from the child node position. That was a lot to take in, let's see it in action:

<Bleed>
  <BlogExampleViewer
    codePath="blog-flows/mindmap/CreateNodes"
    additionalFiles={[
      'store.ts',
      'MindMapNode.tsx',
      'MindMapEdge.tsx',
      'index.css',
    ]}
    dependencies={{ nanoid: 'latest', zustand: '4.3.1' }}
    isTypescript
  />
</Bleed>

To test the new functionality you can start a connection from a handle and then end it on the pane. You should see a new node being added to the mind map.

## <Emoji content="🤝" /> Keep data in sync

We can already update the labels but we are not updating the nodes data object. This is important to keep our app in sync and if we want to save our nodes on the server for example. To achieve this we add a new action called `updateNodeLabel` to the store. This action takes a node id and a label. The implementation is pretty straight forward: we iterate over the existing nodes and update the matching one with the passed label:

#### src/store.ts

```ts
updateNodeLabel: (nodeId: string, label: string) => {
  set({
    nodes: get().nodes.map((node) => {
      if (node.id === nodeId) {
        // it's important to create a new object here, to inform React Flow about the changes
        node.data = { ...node.data, label };
      }

      return node;
    }),
  });
},
```

Let's use the new action in our `MindmapNode` component:

#### src/App/MindmapNode/index.tsx

```tsx
import { Handle, NodeProps, Position } from '@xyflow/react';

import useStore from '../store';

export type NodeData = {
  label: string;
};

function MindMapNode({ id, data }: NodeProps<NodeData>) {
  const updateNodeLabel = useStore((state) => state.updateNodeLabel);

  return (
    <>
      <input
        // from now on we can use value instead of defaultValue
        // this makes sure that the input always shows the current label of the node
        value={data.label}
        onChange={(evt) => updateNodeLabel(id, evt.target.value)}
        className="input"
      />

      <Handle type="target" position={Position.Top} />
      <Handle type="source" position={Position.Top} />
    </>
  );
}

export default MindMapNode;
```

That was quick! The input fields of the custom nodes now display the current label of the nodes. You could take your nodes data, save it on the server and then load it again.

## <Emoji content="💅" /> Simpler UX and nicer styling

Functionality-wise we are finished with our mind map app! We can add new nodes, update their labels and move them around. But the UX and styling could use some improvements. Let's make it easier to drag the nodes and to create new nodes!

### 1. A node as handle

Let's use the whole node as a handle, rather than displaying the default handles. This makes it easier to create nodes, because the area where you can start a new connection gets bigger. We need to style the source handle to be the size of the node and hide the target handle visually. React Flow still needs it to connect the nodes but we don't need to display it since we are creating new nodes by dropping an edge on the pane. We use plain old CSS to hide the target handle and position it in the center of the node:

#### src/index.css

```css
.react-flow__handle.target {
  top: 50%;
  pointer-events: none;
  opacity: 0;
}
```

In order to make the whole node a handle, we also update the style of the source:

#### src/index.css

```css
.react-flow__handle.source {
  top: 0;
  left: 0;
  transform: none;
  background: #f6ad55;
  height: 100%;
  width: 100%;
  border-radius: 2px;
  border: none;
}
```

<Bleed>
  <BlogExampleViewer
    codePath="blog-flows/mindmap/NodeAsHandle"
    additionalFiles={[
      'index.css',
      'MindMapNode.tsx',
      'MindMapEdge.tsx',
      'store.ts',
    ]}
    dependencies={{ nanoid: 'latest', zustand: '4.3.1' }}
    isTypescript
  />
</Bleed>

This works but we can't move the nodes anymore because the source handle is now the whole node and covers the input field. We fix that by using the [`dragHandle` node option](/api-reference/types/node#drag-handle). It allows us to specify a selector for a DOM element that should be used as a drag handle. For this we adjust the custom node a bit:

#### src/App/MindmapNode/index.tsx

```tsx
import { Handle, NodeProps, Position } from '@xyflow/react';

import useStore from '../store';

export type NodeData = {
  label: string;
};

function MindMapNode({ id, data }: NodeProps<NodeData>) {
  const updateNodeLabel = useStore((state) => state.updateNodeLabel);

  return (
    <>
      <div className="inputWrapper">
        <div className="dragHandle">
          {/* icon taken from grommet https://icons.grommet.io */}
          <svg viewBox="0 0 24 24">
            <path
              fill="#333"
              stroke="#333"
              strokeWidth="1"
              d="M15 5h2V3h-2v2zM7 5h2V3H7v2zm8 8h2v-2h-2v2zm-8 0h2v-2H7v2zm8 8h2v-2h-2v2zm-8 0h2v-2H7v2z"
            />
          </svg>
        </div>
        <input
          value={data.label}
          onChange={(evt) => updateNodeLabel(id, evt.target.value)}
          className="input"
        />
      </div>

      <Handle type="target" position={Position.Top} />
      <Handle type="source" position={Position.Top} />
    </>
  );
}

export default MindMapNode;
```

We add a wrapper div with the class name `inputWrapper` and a div with the class name `dragHandle` that acts as the drag handle (surprise!). Now we can style the new elements:

#### src/index.css

```css
.inputWrapper {
  display: flex;
  height: 20px;
  z-index: 1;
  position: relative;
}

.dragHandle {
  background: transparent;
  width: 14px;
  height: 100%;
  margin-right: 4px;
  display: flex;
  align-items: center;
}

.input {
  border: none;
  padding: 0 2px;
  border-radius: 1px;
  font-weight: 700;
  background: transparent;
  height: 100%;
  color: #222;
}
```

<Bleed>
  <BlogExampleViewer
    codePath="blog-flows/mindmap/NodeAsHandle2"
    additionalFiles={[
      'index.css',
      'MindMapNode.tsx',
      'MindMapEdge.tsx',
      'store.ts',
    ]}
    dependencies={{ nanoid: 'latest', zustand: '4.3.1' }}
    isTypescript
  />
</Bleed>

### 2. Activate input on focus

We are almost there but we need to adjust some more details. We want to start our new connection from the center of the node. For this we set the pointer events of the input to "none" and check if the user releases the button on top of the node. Only then we want to activate the input field. We can use our `onConnectEnd` function to achieve this:

#### src/App/index.tsx

```tsx
const onConnectEnd: OnConnectEnd = useCallback(
  (event) => {
    const { nodeLookup } = store.getState();
    const targetIsPane = (event.target as Element).classList.contains(
      'react-flow__pane',
    );
    const node = (event.target as Element).closest('.react-flow__node');

    if (node) {
      node.querySelector('input')?.focus({ preventScroll: true });
    } else if (targetIsPane && connectingNodeId.current) {
      const parentNode = nodeLookup.get(connectingNodeId.current);
      const childNodePosition = getChildNodePosition(event, parentNode);

      if (parentNode && childNodePosition) {
        addChildNode(parentNode, childNodePosition);
      }
    }
  },
  [getChildNodePosition],
);
```

As you see we are focusing the input field if the user releases the mouse button on top of a node. We can now add some styling so that the input field is activated (pointerEvents: all) only when it's focused:

```css
/* we want the connection line to be below the node */
.react-flow .react-flow__connectionline {
  z-index: 0;
}

/* pointer-events: none so that the click for the connection goes through */
.inputWrapper {
  display: flex;
  height: 20px;
  position: relative;
  z-index: 1;
  pointer-events: none;
}

/* pointer-events: all so that we can use the drag handle (here the user cant start a new connection) */
.dragHandle {
  background: transparent;
  width: 14px;
  height: 100%;
  margin-right: 4px;
  display: flex;
  align-items: center;
  pointer-events: all;
}

/* pointer-events: none by default */
.input {
  border: none;
  padding: 0 2px;
  border-radius: 1px;
  font-weight: 700;
  background: transparent;
  height: 100%;
  color: #222;
  pointer-events: none;
}

/* pointer-events: all when it's focused so that we can type in it */
.input:focus {
  border: none;
  outline: none;
  background: rgba(255, 255, 255, 0.25);
  pointer-events: all;
}
```

<Bleed>
  <BlogExampleViewer
    codePath="blog-flows/mindmap/NodeAsHandle3"
    additionalFiles={[
      'index.css',
      'MindMapNode.tsx',
      'MindMapEdge.tsx',
      'store.ts',
    ]}
    dependencies={{ nanoid: 'latest', zustand: '4.3.1' }}
    isTypescript
  />
</Bleed>

### 3. Dynamic width and auto focus

Almost done! We want to have a dynamic width for the nodes based on the length of the text. To keep it simple we do a calculation based on the length of text for this:

#### Added effect in src/app/MindMapNode.tsx

```jsx
useLayoutEffect(() => {
  if (inputRef.current) {
    inputRef.current.style.width = `${data.label.length * 8}px`;
  }
}, [data.label.length]);
```

We also want to focus / activate a node right after it gets created:

#### Added effect in src/app/MindMapNode.tsx

```jsx
useEffect(() => {
  setTimeout(() => {
    if (inputRef.current) {
      inputRef.current.focus({ preventScroll: true });
    }
  }, 1);
}, []);
```

<Bleed>
  <BlogExampleViewer
    codePath="blog-flows/mindmap/NodeAsHandle4"
    additionalFiles={[
      'index.css',
      'MindMapNode.tsx',
      'MindMapEdge.tsx',
      'store.ts',
    ]}
    dependencies={{ nanoid: 'latest', zustand: '4.3.1' }}
    activeFile="MindMapNode.tsx"
    isTypescript
  />
</Bleed>

Now when you adjust a node label, the width of the node will adjust accordingly. You can also create a new node and it will be focused right away.

### 4. Centered edges and styling details

You may have noticed that the edges are not centered. We created a custom edge at the beginning for this, and now we can adjust it a bit so that the edge starts in the center of the node and not at the top of the handle (the default behavior):

#### src/App/MindMapEdge.tsx

```tsx
import { BaseEdge, EdgeProps, getStraightPath } from '@xyflow/react';

function MindMapEdge(props: EdgeProps) {
  const { sourceX, sourceY, targetX, targetY } = props;

  const [edgePath] = getStraightPath({
    sourceX,
    sourceY: sourceY + 20,
    targetX,
    targetY,
  });

  return <BaseEdge path={edgePath} {...props} />;
}

export default MindMapEdge;
```

We are passing all props to the [`getStraightPath`](/api-reference/utils/get-straight-path) helper function but adjust the sourceY so that it is in the center of the node.

More over we want the title to be a bit more subtle and choose a color for our background. We can do this by adjusting the color of the panel (we added the class name `"header"`) and the background color of the body element:

```css
body {
  margin: 0;
  background-color: #f8f8f8;
  height: 100%;
}

.header {
  color: #cdcdcd;
}
```

Nicely done! <Emoji content="💯" /> You can find the final code here:

<Bleed>
  <BlogExampleViewer
    codePath="blog-flows/mindmap/NodeAsHandle4"
    additionalFiles={[
      'index.css',
      'MindMapNode.tsx',
      'MindMapEdge.tsx',
      'store.ts',
    ]}
    dependencies={{ nanoid: 'latest', zustand: '4.3.1' }}
    activeFile="MindMapNode.tsx"
    isTypescript
  />
</Bleed>

## <Emoji content="👋" /> Final thoughts

What a trip! We started with an empty pane and ended with a fully functional mind map app. If you want to move on you could work on some of the following features:

- Add new nodes by clicking on the pane
- Save and restore button to store current state to local storage
- Export and import UI
- Collaborative editing

I hope you enjoyed this tutorial and learned something new! If you have any questions or feedback, feel free to reach out to me on [Twitter](https://twitter.com/moklick) or join our [Discord server](https://discord.com/invite/RVmnytFmGW). React Flow is an independent company financed by its users. If you want to support us you can [sponsor us on Github](https://github.com/sponsors/xyflow) or [subscribe to one of our Pro plans](https://reactflow.dev/pro/).

</TutorialLayout>

----
advanced-use/_meta.json
{
  "accessibility": "Accessibility",
  "testing": "Testing",
  "typescript": "TypeScript",
  "uncontrolled-flow": "Uncontrolled Flows",
  "state-management": "State Management",
  "computing-flows": "Computing Flows",
  "ssr-ssg-configuration": "Server Side Rendering",
  "devtools-and-debugging": "Devtools"
}

----
advanced-use/computing-flows.mdx
---
title: Computing Flows
description: Learn how to extend React Flow to compute data going through flow graphs.
created_at: 2024-07-01
---

# Computing Flows

import { Callout } from 'nextra/components';
import ExampleViewer from '@/components/example-viewer';

<Callout type="info">
  For this guide we assume that you already know about the [core
  concepts](/learn/concepts/core-concepts) of React Flow and how to implement
  [custom nodes](/learn/customization/custom-nodes).
</Callout>

Usually with React Flow, developers handle their data outside of React Flow by sending it somewhere else, like on a server or a database. Instead, in this guide we'll show you how to compute data flows directly inside of React Flow. You can use this for updating a node based on connected data, or for building an app that runs entirely inside the browser.

## What are we going to build?

By the end of this guide, you will build an interactive flow graph that generates a color out of three separate number input fields (red, green and blue), and determines whether white or black text would be more readable on that background color.

<ExampleViewer
  codePath="api-flows/Computing6"
  editorHeight={500}
  applyStyles={false}
  showEditor={false}
  options={{
    editorHeight: 500,
  }}
  additionalFiles={[
    'NumberInput.js',
    'ColorPreview.js',
    'Lightness.js',
    'Log.js',
    'style.css',
  ]}
/>

## Creating custom nodes

Let's start by creating a custom input node (`NumberInput.js`) and add three instances of it. We will be using a controlled `<input type="number" />` and limit it to integer numbers between 0 - 255 inside the `onChange` event handler.

```jsx
import { useCallback, useState } from 'react';
import { Handle, Position } from '@xyflow/react';

function NumberInput({ id, data }) {
  const [number, setNumber] = useState(0);

  const onChange = useCallback((evt) => {
    const cappedNumber = Math.round(
      Math.min(255, Math.max(0, evt.target.value)),
    );
    setNumber(cappedNumber);
  }, []);

  return (
    <div className="number-input">
      <div>{data.label}</div>
      <input
        id={`number-${id}`}
        name="number"
        type="number"
        min="0"
        max="255"
        onChange={onChange}
        className="nodrag"
        value={number}
      />
      <Handle type="source" position={Position.Right} />
    </div>
  );
}

export default NumberInput;
```

Next, we'll add a new custom node (`ColorPreview.js`) with one target handle for each color channel and a background that displays the resulting color. We can use `mix-blend-mode: 'difference';` to make the text color always readable.

<Callout type="info">
  Whenever you have multiple handles of the same kind on a single node, don't
  forget to give each one a seperate id!
</Callout>
Let's also add edges going from the input nodes to the color node to our `initialEdges`
array while we are at it.

<ExampleViewer
  activeFile="ColorPreview.js"
  codePath="api-flows/Computing"
  applyStyles={false}
  options={{ editorHeight: 500, editorWidthPercentage: 45, wrapContent: true }}
  additionalFiles={['NumberInput.js', 'ColorPreview.js', 'style.css']}
  editorHeight={500}
/>

## Computing data

How do we get the data from the input nodes to the color node? This is a two step process that involves two hooks created for this exact purpose:

1. Store each number input value inside the node's `data` object with help of the [`updateNodeData`](/api-reference/types/react-flow-instance#update-node-data) callback.
2. Find out which nodes are connected by using [`useHandleConnections`](/api-reference/hooks/use-handle-connections) and then use [`useNodesData`](/api-reference/hooks/use-nodes-data) for receiving the data from the connected nodes.

### Step 1: Writing values to the data object

First let's add some initial values for the input nodes inside the `data` object in our `initialNodes` array and use them as an initial state for the input nodes.
Then we'll grab the function [`updateNodeData`](/api-reference/types/react-flow-instance#update-node-data) from the [`useReactFlow`](/api-reference/hooks/use-react-flow) hook and use it to update the `data` object of the node with a new value whenever the input changes.

<Callout type="info">
By default, the data you pass to [`updateNodeData`](/api-reference/types/react-flow-instance#update-node-data) will be merged with the old data object. This makes it easier to do partial updates and saves you in case you forget to add `{...data}`. You can pass `{ replace: true }` as an option to replace the object instead.
</Callout>

<ExampleViewer
  activeFile="NumberInput.js"
  codePath="api-flows/Computing2"
  applyStyles={false}
  options={{ editorHeight: 500, editorWidthPercentage: 45, wrapContent: true }}
  additionalFiles={['NumberInput.js', 'ColorPreview.js', 'style.css']}
  editorHeight={500}
/>

<Callout type="warning">
  <b>
    When dealing with input fields you don't want to use a nodes `data` object
    as UI state directly.
  </b>
  There is a delay in updating the data object and the cursor might jump around erraticly
  and lead to unwanted inputs.
</Callout>

### Step 2: Getting data from connected nodes

We start by determining all connections for each handle with the [`useHandleConnections`](/api-reference/hooks/use-handle-connections) hook and then fetching the data for the first connected node with [`updateNodeData`](/api-reference/types/react-flow-instance#update-node-data).

<Callout type="info">
  Note that each handle can have multiple nodes connected to it and you might
  want to restrict the number of connections to a single handle inside your
  application. Check out the [connection limit
  example](/examples/nodes/connection-limit) to see how to do that.
</Callout>

<b>And there you go!</b> Try changing the input values and see the color change in
real time.

<ExampleViewer
  activeFile="ColorPreview.js"
  codePath="api-flows/Computing3"
  applyStyles={false}
  options={{ editorHeight: 500, editorWidthPercentage: 45, wrapContent: true }}
  additionalFiles={['NumberInput.js', 'ColorPreview.js', 'style.css']}
  editorHeight={500}
/>

### Improving the code

It might seem awkward to get the connections first, and then the data seperately for each handle. For nodes with multiple handles like these, you should consider creating a custom handle component that isolates connection states and node data binding. We can create one inline.

```jsx filename="ColorPreview.js"
// {...}
function CustomHandle({ id, label, onChange }) {
  const connections = useHandleConnections({
    type: 'target',
    id,
  });

  const nodeData = useNodesData(connections?.[0].source);

  useEffect(() => {
    onChange(nodeData?.data ? nodeData.data.value : 0);
  }, [nodeData]);

  return (
    <div>
      <Handle
        type="target"
        position={Position.Left}
        id={id}
        className="handle"
      />
      <label htmlFor="red" className="label">
        {label}
      </label>
    </div>
  );
}
```

We can promote color to local state and declare each handle like this:

```jsx filename="ColorPreview.js"
// {...}
function ColorPreview() {
  const [color, setColor] = useState({ r: 0, g: 0, b: 0 });

  return (
    <div
      className="node"
      style={{
        background: `rgb(${color.r}, ${color.g}, ${color.b})`,
      }}
    >
      <CustomHandle
        id="red"
        label="R"
        onChange={(value) => setColor((c) => ({ ...c, r: value }))}
      />
      <CustomHandle
        id="green"
        label="G"
        onChange={(value) => setColor((c) => ({ ...c, g: value }))}
      />
      <CustomHandle
        id="blue"
        label="B"
        onChange={(value) => setColor((c) => ({ ...c, b: value }))}
      />
    </div>
  );
}

export default ColorPreview;
```

## Getting more complex

Now we have a simple example of how to pipe data through React Flow. What if we want to do something more complex, like transforming the data along the way? Or even take different paths? We can do that too!

### Continuing the flow

Let's extend our flow. Start by adding an output `<Handle type="source" position={Position.Right} />` to the color node and remove the local component state.

<Callout type="info">
  Because there are no inputs fields on this node, we don't need to keep a local
  state at all. We can just read and update the node's `data` object directly.
</Callout>

Next, we add a new node (`Lightness.js`) that takes in a color object and determines if it is either a light or dark color. We can use the [relative luminance formula](https://en.wikipedia.org/wiki/Relative_luminance#Relative_luminance_and_%22gamma_encoded%22_colorspaces)
`luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b`
to calculate the perceived brightness of a color (0 being the darkest and 255 being the brightest). We can assume everything >= 128 is a light color.

<ExampleViewer
  activeFile="Lightness.js"
  codePath="api-flows/Computing4"
  applyStyles={false}
  options={{ editorHeight: 500, editorWidthPercentage: 45, wrapContent: true }}
  additionalFiles={[
    'NumberInput.js',
    'ColorPreview.js',
    'Lightness.js',
    'style.css',
  ]}
  editorHeight={500}
/>

### Conditional branching

What if we would like to take a different path in our flow based on the perceived lightness? Let's give our lightness node two source handles `light` and `dark` and separate the node `data` object by source handle IDs. This is needed if you have multiple source handles to distinguish between each source handle's data.

But what does it mean to "take a different route"? One solution would be to assume that `null` or `undefined` data hooked up to a target handle is considered a "stop". In our case we can write the incoming color into `data.values.light` if it's a light color and into `data.values.dark` if it's a dark color and set the respective other value to `null`.

Don't forget to add `flex-direction: column;` and `align-items: end;` to reposition the handle labels.

<ExampleViewer
  activeFile="Lightness.js"
  codePath="api-flows/Computing5"
  applyStyles={false}
  editorHeight={500}
  options={{ editorHeight: 500, editorWidthPercentage: 45, wrapContent: true }}
  additionalFiles={[
    'NumberInput.js',
    'ColorPreview.js',
    'Lightness.js',
    'style.css',
  ]}
/>

Cool! Now we only need a last node to see if it actually works... We can create a custom debugging node (`Log.js`) that displays the hooked up data, and we're done!

<ExampleViewer
  activeFile="Log.js"
  codePath="api-flows/Computing6"
  applyStyles={false}
  editorHeight={500}
  options={{ editorHeight: 500, editorWidthPercentage: 45, wrapContent: true }}
  additionalFiles={[
    'NumberInput.js',
    'ColorPreview.js',
    'Lightness.js',
    'Log.js',
    'style.css',
  ]}
/>

## Summary

You have learned how to move data through the flow and transform it along the way.
All you need to do is

1. store data inside the node's `data` object with help of [`updateNodeData`](/api-reference/types/react-flow-instance#update-node-data) callback.
2. find out which nodes are connected by using [`useHandleConnections`](/api-reference/hooks/use-handle-connections) and then use [`useNodesData`](/api-reference/hooks/use-nodes-data) for receiving the data from the connected nodes.

You can implement branching for example by interpreting incoming data that is undefined as a "stop". As a side note, most flowgraphs that also have a branching usually seperate the triggering of nodes from the actual data hooked up to the nodes. Unreal Engines Blueprints are a good example for this.

<Callout type="info">
  One last note before you go: you should find a consistent way of structuring
  all your node data, instead of mixing ideas like we did just now. This means
  for example, if you start working with splitting data by handle ID you should
  do it for all nodes, regardless whether they have multiple handles or not.
  Being able to make assumptions about the structure of your data throughout
  your flow will make life a lot easier.
</Callout>

----
advanced-use/testing.mdx
---
title: Testing
description: How to test React Flow applications with Cypress, Playwright or Jest.
---

# Testing

There are plenty of options to test a React application. If you want to test a React Flow application, we recommend to use [Cypress](https://www.cypress.io/) or [Playwright](https://playwright.dev/). React Flow needs to measure nodes in order to render edges and for that relies on rendering DOM elements.

## Using Cypress or Playwright

If you are using Cypress or Playwright no additional setup is needed. You can refer to the getting started guide for [Cypress here](https://docs.cypress.io/guides/getting-started/installing-cypress) and for [Playwright here](https://playwright.dev/docs/intro).

## Using Jest

If you are using [Jest](https://jestjs.io/), you need to mock some features in order to be able to run your tests. You can do that by adding this file to your project. Calling `mockReactFlow()` in a `setupTests` file (or inside a `beforeEach`) will trigger the necessary overrides.

```ts
// To make sure that the tests are working, it's important that you are using
// this implementation of ResizeObserver and DOMMatrixReadOnly
class ResizeObserver {
  callback: globalThis.ResizeObserverCallback;

  constructor(callback: globalThis.ResizeObserverCallback) {
    this.callback = callback;
  }

  observe(target: Element) {
    this.callback([{ target } as globalThis.ResizeObserverEntry], this);
  }

  unobserve() {}

  disconnect() {}
}

class DOMMatrixReadOnly {
  m22: number;
  constructor(transform: string) {
    const scale = transform?.match(/scale\(([1-9.])\)/)?.[1];
    this.m22 = scale !== undefined ? +scale : 1;
  }
}

// Only run the shim once when requested
let init = false;

export const mockReactFlow = () => {
  if (init) return;
  init = true;

  global.ResizeObserver = ResizeObserver;

  // @ts-ignore
  global.DOMMatrixReadOnly = DOMMatrixReadOnly;

  Object.defineProperties(global.HTMLElement.prototype, {
    offsetHeight: {
      get() {
        return parseFloat(this.style.height) || 1;
      },
    },
    offsetWidth: {
      get() {
        return parseFloat(this.style.width) || 1;
      },
    },
  });

  (global.SVGElement as any).prototype.getBBox = () => ({
    x: 0,
    y: 0,
    width: 0,
    height: 0,
  });
};
```

If you want to test mouse events with jest (for example inside your custom nodes), you need to disable `d3-drag` as it does not work outside of the browser:

```js
<ReactFlow nodesDraggable={false} {...rest} />
```

----
advanced-use/state-management.mdx
---
title: Using a State Management Library
description: Learn how to use React Flow with a state management library like Zustand, Redux, Recoil or Jotai.
---

# Using a State Management Library

import { Callout } from 'nextra/components';

<Callout type="info">
  For this guide we assume that you already know about the [core
  concepts](/learn/concepts/core-concepts) of React Flow and how to implement
  [custom nodes](/learn/customization/custom-nodes). You should also be familiar
  with the concepts of state management libraries and how to use them.
</Callout>

In this guide we are explaining how you could use React Flow with the state management library [Zustand](https://github.com/pmndrs/zustand). We will build a little app where every node has a color chooser that updates its background color. In this guide we are are using Zustand, because we are already using it internally for React Flow, but of course you can use any other library like [Redux](https://redux.js.org/), [Recoil](https://recoiljs.org/) or [Jotai](https://jotai.org/) as well.

As you might have seen in the previous guides and examples, React Flow can easily be used with a local component state for handling the nodes and edges of your diagram. When your app grows and you want to alter your state from within your nodes for example, things can get more complex. To avoid passing down functions through the node data field, you could use a [React context](https://reactjs.org/docs/context.html) or add a state management library as explained in this guide.

## Install Zustand

As mentioned above we are using Zustand in this example. Zustand is a bit like Redux: you have a central store with actions to alter your state and hooks to access your state. You can install Zustand via:

import { Tab, Tabs } from 'nextra/components';

<Tabs items={['npm', 'pnpm', 'yarn', 'bun']}>
<Tab>

```bash copy
npm install --save zustand
```

  </Tab>
  <Tab>

```bash copy
pnpm add zustand
```

  </Tab>
  <Tab>

```bash copy
yarn add zustand
```

  </Tab>
  <Tab>

```bash copy
bun add zustand
```

</Tab>
</Tabs>

## Create a Store

Zustand lets you create a hook for accessing the values and functions of your store. We put the `nodes` and `edges` and the `onNodesChange`, `onEdgesChange`, `onConnect`, `setNodes` and `setEdges` functions in the store to get the basic interactivity for our graph:

import ExampleViewer from '@/components/example-viewer';

<ExampleViewer
  activeFile="store.ts"
  codePath="api-flows/StateManagement"
  applyStyles={false}
  editorHeight={500}
  options={{ editorWidthPercentage: 45, wrapContent: true }}
  additionalFiles={['store.ts', 'nodes.ts', 'edges.ts', 'types.ts']}
  isTypescript
/>

That's the basic setup. We now have a store with nodes and edges that can handle the changes (dragging, selecting or removing a node or edge) triggered by React Flow. When you take a look at the `App.tsx` file, you can see that it's kept nice and clean. All the data and actions are now part of the store and can be accessed with the `useStore` hook.

## Implement a Color Change Action

We add a new `updateNodeColor` action to update the `data.color` field of a specific node. For this we pass the node id and the new color to the action, iterate over the nodes and update the matching one with the new color:

```ts
updateNodeColor: (nodeId: string, color: string) => {
  set({
    nodes: get().nodes.map((node) => {
      if (node.id === nodeId) {
        // it's important to create a new object here, to inform React Flow about the changes
        return { ...node, data: { ...node.data, color } };
      }

      return node;
    }),
  });
};
```

This new action can now be used in a React component like this:

```tsx
const updateNodeColor = useStore((s) => s.updateNodeColor);
...
<button onClick={() => updateNodeColor(nodeId, color)} />;
```

## Add a Color Chooser Node

In this step we implement the `ColorChooserNode` component and call the `updateNodeColor` when the user changes the color. The custom part of the color chooser node is the color input.

```jsx
<input
  type="color"
  defaultValue={data.color}
  onChange={(evt) => updateNodeColor(id, evt.target.value)}
  className="nodrag"
/>
```

We add the `nodrag` class name so that the user doesn't drag the node by mistake when changing the color and call the `updateNodeColor` in the `onChange` event handler.

<ExampleViewer
  activeFile="ColorChooserNode.tsx"
  codePath="api-flows/StateManagement2"
  applyStyles={false}
  editorHeight={500}
  options={{ editorWidthPercentage: 45, wrapContent: true }}
  additionalFiles={[
    'ColorChooserNode.tsx',
    'store.ts',
    'nodes.ts',
    'edges.ts',
    'types.ts',
  ]}
  isTypescript
/>

You can now click on a color chooser and change the background of a node.

----
advanced-use/devtools-and-debugging.mdx
---
title: Devtools and Debugging
description: Copy pastable devtools for React Flow
created_at: 2024-04-09
---

import ExampleViewer from '@/components/example-viewer';
import { Callout } from 'nextra/components';

# Devtools and Debugging

<Callout type="info">
  This is an ongoing experiment on implementing our own React Flow devtools.
  While we are working on the actual package, we'd love to hear about your
  feedback and ideas on [Discord](https://discord.gg/Bqt6xrs) or via mail at
  info@xyflow.com.
</Callout>

React Flow can often seem like a magic black box, but in reality you can reveal
quite a lot about its internal state if you know where to look. In this guide we
will show you three different ways to reveal the internal state of your flow:

- A `<ViewportLogger />` component that shows the current position and zoom level
  of the viewport.
- A `<NodeInspector />` component that reveals the state of each node.
- A `<ChangeLogger />` that wraps your flow's `onNodesChange` handler and logs
  each change as it is dispatched.

While we find these tools useful for making sure React Flow is working properly,
you might also find them useful for debugging your applications as your flows and
their interactions become more complex.

<div className="nestedSandpack">
  <ExampleViewer
    codePath="api-flows/Devtools"
    options={{
      editorHeight: 500,
      editorWidthPercentage: 45,
      wrapContent: true,
    }}
    additionalFiles={[
      'Devtools.tsx',
      'ChangeLogger.tsx',
      'NodeInspector.tsx',
      'ViewportLogger.tsx',
      'style.css',
    ]}
    isTypescript
    editorHeight={400}
    orientation="vertical"
  />
</div>

We encourage you to copy any or all of the components from this example into your
own projects and modify them to suit your needs: each component works independently!

## Node Inspector

The `<NodeInspector />` component makes use of our [`useNodes`](/api-reference/hooks/use-names)
hook to access all the nodes in the flow. Typically we discourage using this hook
because it will trigger a re-render any time _any_ of your nodes change, but that's
exactly what makes it so useful for debugging!

The `width` and `height` properties are added to each node by React Flow after it has measured
the node's dimensions. We pass those dimensions, as well as other information like
the node's id and type, to a custom `<NodeInfo />` component.

We make use of the [`<EdgeLabelRenderer />`](/api-reference/components/edge-label-renderer)
component to let us render the inspector into React Flow's viewport. That means
it's content will be positioned and transformed along with the rest of the flow
as the user pans and zooms.

## Change Logger

Any change to your nodes and edges that originates from React Flow itself is
communicated to you through the `onNodesChange` and `onEdgesChange` callbacks.
If you are working with a controlled flow (that means you're managing the nodes
and edges yourself), you need to apply those changes to your state in order to
keep everything in sync.

The `<ChangeLogger />` component wraps your user-provided `onNodesChange` handler
with a custom function that intercepts and logs each change as it is dispatched.
We can do this by using the [`useStore`](/api-reference/hooks/use-store) and
[`useStoreApi`](/api-reference/hooks/use-store-api) hooks to access the store and
and then update React Flow's internal state accordingly. These two hooks give you
powerful access to React Flow's internal state and methods.

Beyond debugging, using the `<ChangeLogger />` can be a great way to learn more
about how React Flow works and get you thinking about the different functionality
you can build on top of each change.

You can find documentation on the [`NodeChange`](/api-reference/types/node-change)
and [`EdgeChange`](/api-reference/types/edge-change) types in the API reference.

## Viewport Logger

The `<ViewportLogger />` is the simplest example of what state you can pull out
of React Flow's store if you know what to look for. The state of the viewport is
stored internally under the `transform` key (a name we inherited from
[d3-zoom](https://d3js.org/d3-zoom#zoomTransform)). This component extracts the
`x`, `y`, and `zoom` components of the transform and renders them into a
[`<Panel />`](/api-reference/components/panel) component.

## Let us know what you think

As mentioned above, if you have any feedback or ideas on how to improve the devtools,
please let us know on [Discord](https://discord.gg/Bqt6xrs) or via mail at
info@xyflow.com. If you build your own devtools using these ideas, we'd love to
hear about it!

----
advanced-use/uncontrolled-flow.mdx
---
title: Uncontrolled Flow
description: Uncontrolled inputs in React manage their own state internally. This guide shows you how to set up and use an uncontrolled flow.
---

# Uncontrolled Flow

There are two ways to use React Flow - controlled or uncontrolled. Controlled means, that you are in control of the state of the nodes and edges. In an uncontrolled flow the state of the nodes and edges is handled by React Flow internally. In this part we will show you how to work with an uncontrolled flow.

An implementation of an uncontrolled flow is simpler, because you don't need to pass any handlers:

import ExampleViewer from '@/components/example-viewer';
import { Callout } from 'nextra/components';

<ExampleViewer
  codePath="api-flows/Uncontrolled"
  applyStyles={false}
  options={{ editorHeight: 500, editorWidthPercentage: 45, wrapContent: true }}
  additionalFiles={['nodes.js', 'edges.js']}
/>

As you can see, we are passing `defaultEdgeOptions` to define that edges are animated. This is helpful, because you can't use the `onConnect` handler anymore to pass custom options to a newly created edge. Try to connect "Node B" with "Node C" and you see that the new edge is animated.

## Updating Nodes and Edges

Since you don't have nodes and edges in your local state, you can't update them directly. To do so, you need to use the [React Flow instance](/api-reference/types/react-flow-instance) that comes with functions for updating the internal state. You can receive the instance via the `onInit` callback or better by using the [`useReactFlow` hook](/api-reference/hooks/use-react-flow). Let's create a button that adds a new node at a random position. For this, we are wrapping our flow with the [`ReactFlowProvider`](/api-reference/react-flow-provider) and use the [`addNodes` function](/api-reference/types/react-flow-instance#nodes-and-edges).

<Callout>
  The `Flow` component in this example is wrapped with the `ReactFlowProvider`
  to use the `useReactFlow` hook.
</Callout>

<ExampleViewer
  codePath="api-flows/Uncontrolled2"
  applyStyles={false}
  options={{ editorHeight: 500, editorWidthPercentage: 45, wrapContent: true }}
  additionalFiles={['nodes.js', 'edges.js', 'button.css']}
/>

----
advanced-use/typescript.mdx
---
title: Usage with TypeScript
description: In this guide we exlpain how to work with React Flow and TypeScript.
created_at: 2024-07-01
---

import { Callout } from 'nextra/components';

# Usage with TypeScript

React Flow is written in TypeScript because we value the additional safety barrier it provides.
We export all the types you need for correctly typing data structures and functions you pass to the React Flow component. We also provide a way to extend the types of nodes and edges.

## Basic usage

Let's start with the most basic types you need for a simple starting point. Typescript might already infer some of these types, but we will define them explicitly nontheless.

```tsx
import { useState, useCallback } from 'react';
import {
  ReactFlow,
  addEdge,
  applyNodeChanges,
  applyEdgeChanges,
  type Node,
  type Edge,
  type FitViewOptions,
  type OnConnect,
  type OnNodesChange,
  type OnEdgesChange,
  type OnNodeDrag,
  type NodeTypes,
  type DefaultEdgeOptions,
} from '@xyflow/react';

const initialNodes: Node[] = [
  { id: '1', data: { label: 'Node 1' }, position: { x: 5, y: 5 } },
  { id: '2', data: { label: 'Node 2' }, position: { x: 5, y: 100 } },
];

const initialEdges: Edge[] = [{ id: 'e1-2', source: '1', target: '2' }];

const fitViewOptions: FitViewOptions = {
  padding: 0.2,
};

const defaultEdgeOptions: DefaultEdgeOptions = {
  animated: true,
};

const nodeTypes: NodeTypes = {
  num: NumberNode,
  txt: TextNode,
};

const onNodeDrag: OnNodeDrag = (_, node) => {
  console.log('drag event', node.data);
};

function Flow() {
  const [nodes, setNodes] = useState<Node[]>(initialNodes);
  const [edges, setEdges] = useState<Edge[]>(initialEdges);

  const onNodesChange: OnNodesChange = useCallback(
    (changes) => setNodes((nds) => applyNodeChanges(changes, nds)),
    [setNodes],
  );
  const onEdgesChange: OnEdgesChange = useCallback(
    (changes) => setEdges((eds) => applyEdgeChanges(changes, eds)),
    [setEdges],
  );
  const onConnect: OnConnect = useCallback(
    (connection) => setEdges((eds) => addEdge(connection, eds)),
    [setEdges],
  );

  return (
    <ReactFlow
      nodes={nodes}
      nodeTypes={nodeTypes}
      edges={edges}
      edgeTypes={edgeTypes}
      onNodesChange={onNodesChange}
      onEdgesChange={onEdgesChange}
      onConnect={onConnect}
      onNodeDrag={onNodeDrag}
      fitView
      fitViewOptions={fitViewOptions}
      defaultEdgeOptions={defaultEdgeOptions}
    />
  );
}
```

### Custom nodes

When working with [custom nodes](/learn/customization/custom-nodes) you have the possibility to pass a custom `Node` type (or your `Node` union) to the `NodeProps` type. There are basically two ways to work with custom nodes:

1. If you have **multiple custom nodes**, you want to pass a specific `Node` type as a generic to the `NodeProps` type:

```tsx filename="NumberNode.tsx"
import type { Node, NodeProps } from '@xyflow/react';

type NumberNode = Node<{ number: number }, 'number'>;

export default function NumberNode({ data }: NodeProps<NumberNode>) {
  return <div>A special number: {data.number}</div>;
}
```

2. If you have **one custom node** that renders different content based on the node type, you want to pass your `Node` union type as a generic to `NodeProps`:

```tsx filename="CustomNode.tsx"
import type { Node, NodeProps } from '@xyflow/react';

type NumberNode = Node<{ number: number }, 'number'>;
type TextNode = Node<{ text: string }, 'text'>;

type AppNode = NumberNode | TextNode;

export default function CustomNode({ data }: NodeProps<AppNode>) {
  if (data.type === 'number') {
    return <div>A special number: {data.number}</div>;
  }

  return <div>A special text: {data.text}</div>;
}
```

### Custom edges

For [custom edges](/learn/customization/custom-nodes) you have the same possiblity as for custom nodes.

```tsx filename="CustomEdge.tsx"
import {
  getStraightPath,
  BaseEdge,
  type EdgeProps,
  type Edge,
} from '@xyflow/react';

type CustomEdge = Edge<{ value: number }, 'custom'>;

export default function CustomEdge({
  id,
  sourceX,
  sourceY,
  targetX,
  targetY,
}: EdgeProps<CustomEdge>) {
  const [edgePath] = getStraightPath({ sourceX, sourceY, targetX, targetY });

  return <BaseEdge id={id} path={edgePath} />;
}
```

## Advanced usage

When creating complex applications with React Flow, you will have a number of custom nodes & edges, each with different kinds of data attached to them.
When we operate on these nodes & edges through built in functions and hooks, we have to make sure that we [narrow down](https://www.typescriptlang.org/docs/handbook/2/narrowing.html)
the types of nodes & edges to prevent runtime errors.

### `Node` and `Edge` type unions

You will see many functions, callbacks and hooks (even the ReactFlow component itself) that expect a `NodeType` or `EdgeType` generic. These generics are simply
[unions](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types) of all the different types of nodes & edges you have in your application.
As long as you have typed the data objects correctly (see previous section), you can use their exported type.

<Callout type="info">
  If you use any of the built-in nodes ('input', 'output', 'default') or edges
  ('straight', 'step', 'smoothstep', 'bezier'), you can add the `BuiltInNode`
  and `BuiltInEdge` types exported from `@xyflow/react` to your union type.
</Callout>

```tsx
import type { BuiltInNode, BuiltInEdge } from '@xyflow/react';

// Custom nodes
import NumberNode from './NumberNode';
import TextNode from './TextNode';

// Custom edge
import EditableEdge from './EditableEdge';

export type CustomNodeType = BuiltInNode | NumberNode | TextNode;
export type CustomEdgeType = BuiltInEdge | EditableEdge;
```

### Functions passed to `<ReactFlow />`

To receive correct types for callback functions, you can pass your union types to the `ReactFlow` component.
By doing that you will have to type your callback functions explicitly.

```tsx
import { type OnNodeDrag } from '@xyflow/react';

// ...

// Pass your union type here ...
const onNodeDrag: OnNodeDrag<CustomNodeType> = useCallback((_, node) => {
  if (node.type === 'number') {
    // From here on, Typescript knows that node.data
    // is of type { num: number }
    console.log('drag event', node.data.number);
  }
}, []);

const onNodesChange: OnNodesChange<CustomNodeType> = useCallback(
  (changes) => setNodes((nds) => applyNodeChanges(changes, nds)),
  [setNodes],
);
```

### Hooks

The type unions can also be used to type the return values of many hooks.

```tsx filename="FlowComponent.tsx"
import {
  useReactFlow,
  useHandleConnections,
  useNodesData,
  useStore,
} from '@xyflow/react';

export default function FlowComponent() {
  // returned nodes and edges are correctly typed now
  const { getNodes, getEdges } = useReactFlow<CustomNodeType, CustomEdgeType>();

  // You can type useStore by typing the selector function
  const nodes = useStore((s: ReactFlowState<CustomNodeType>) => ({
    nodes: s.nodes,
  }));

  const connections = useHandleConnections({
    type: 'target',
  });

  const nodesData = useNodesData<CustomNodeType>(connections?.[0].source);

  nodeData.forEach(({ type, data }) => {
    if (type === 'number') {
      // This is type safe because we have narrowed down the type
      console.log(data.number);
    }
  });
  // ...
}
```

### Type guards

There are multiple ways you can define [type guards](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#typeof-type-guards) in Typescript.
One way is to define type guard functions like `isNumberNode` or `isTextNode` to filter out specific nodes from a list of nodes.

```tsx
function isNumberNode(node: CustomNodeType): node is NumberNode {
  return node.type === 'number';
}

// numberNodes is of type NumberNode[]
const numberNodes = nodes.filter(isNumberNode);
```

----
advanced-use/ssr-ssg-configuration.mdx
---
title: Server Side Rendering
description: Step-by-step guide render React Flow apps on the server for displaying static flows, dynamically generating images from flows, or rendering graphs in non-javascript environments
created_at: 2024-07-01
---

# Server side rendering, server side generation

import { Callout } from 'nextra/components';

<Callout type="info">
  Server side rendering is supported since React Flow 12
</Callout>

This is an advanced use case and assumes you are already familiar with React Flow. If you're new to React Flow, check out our [getting started guide](/learn/getting-started/installation-and-requirements).

In this guide you will learn how to configure React Flow to render a flow on the server, which will allow you to

- Display static HTML diagrams in documentation
- Render React Flow diagrams in non-js environments
- Dynamically generate opengraph images that appear as embeds when sharing a link to your flow

(If you want to download an image of your flow, there's an easier way to do that on the client-side in our [download image example](/examples/misc/download-image).)

### Node dimensions

You need to configure a few things to make React Flow work on the server, the most important being the node dimensions. React Flow only renders nodes if they have a width and height. Usually you pass nodes without a specific `width` and `height`, they are then measured and the dimensions get written to `measured.width` and `measured.height`. Since we can't measure the dimensions on the server, we need to pass them explicitly. This can be done with the `width` and `height` or the `initialWidth` and `initialHeight` node properties.

```js
const nodes = [
  {
    id: '1',
    type: 'default',
    position: { x: 0, y: 0 },
    data: { label: 'Node 1' },
    width: 100,
    height: 50,
  },
];
```

React Flow now knows the dimensions of the node and can render it on the server. The `width` and `height` properties are used as an inline style for the node. If you expect nodes to have different dimensions on the client or if the dimensions should by dynamic based on the content, you can use the `initialWidth` and `initialHeight` properties. They are only used for the first render (on the server or on the client) as long as the nodes are not measured and `measured.width` and `measured.height` are not set.

<Callout type="default">
  <strong>
    There are two ways to specify node dimensions for server side rendering:
  </strong>
  <div>
    1. `width` and `height` for static dimensions that are known in advance and
    don't change.
  </div>
  <div>
    2. `initialWidth` and `initialHeight` for dynamic dimensions that are not
    known in advance or change.
  </div>
</Callout>

### Handle positions

You probably also want to render the edges on the server. On the client, React Flow checks the positions of the handles and stores that information to draw the edges. Since we can't measure the handle positions on the server, we need to pass this information, too. This can be done with the `handles` property of a node.

```js
const nodes: Node[] = [
  {
    id: '1',
    type: 'default',
    position: { x: 0, y: 0 },
    data: { label: 'Node 1' },
    width: 100,
    height: 50,
    handles: [
      {
        type: 'target',
        position: Position.Top,
        x: 100 / 2,
        y: 0,
      },
      {
        type: 'source',
        position: Position.Bottom,
        x: 100 / 2,
        y: 50,
      },
    ],
  },
];
```

With this additional information, React Flow knows enough about the handles to render the edges on the server. If you are fine with just rendering the nodes, you can skip this step.

### Using `fitView` on the server

If you know the dimensions of the React Flow container itself, you can even use `fitView` on the server. For this, you need to pass the `width` and `height` of the container to the `ReactFlow` component.

```js
<ReactFlow nodes={nodes} edges={edges} fitView width={1000} height={500} />
```

This will calculate the viewport and set the `transform` on the server in order to include all nodes in the viewport.

### Usage with the `<ReactFlowProvider>`

If you are using the `ReactFlowProvider`, you can pass `initialNodes`, `initialEdges` and optional wrapper dimensions (`initialWidth` and `initialHeight`) and `fitView` to the provider.

```js
<ReactFlowProvider
  initialNodes={nodes}
  initialEdges={edges}
  initialWidth={1000}
  initialHeight={500}
  fitView
>
  <App />
</ReactFlowProvider>
```

----
advanced-use/accessibility.mdx
---
title: Accessibility
description: React Flow is designed to be both keyboard and screenreader accesssible.
---

# Accessibility

A flow is accessible with a keyboard and readable by a screenreader. Nodes and edges are focusable, selectable, moveable and deleteable with the keyboard.

import { Callout } from 'nextra/components';

<Callout type="info">
  If you have an idea how we can improve the accessibility of React Flow, please
  feel free to [contact us](https://xyflow.com/contact).
</Callout>

## Built-in Features

### Keyboard Controls

- Nodes and edges are focusable by using the `Tab` key (`tabIndex={0}` + `role="button"`)
- Nodes and edges are selectable by using `Enter` or `Space`, un-selectable by using `Escape`
- Nodes are moveable with arrow keys (press Shift for increasing velocity)
- Nodes and Edges get a `aria-describedby` attribute to describe keyboard controls

You can configure the keyboard controls with the props: `nodesFocusable`, `edgesFocusable` and `disableKeyboardA11y`. `nodesFocusable` and `edgesFocusable` (both true by default) need to be true if you want to be able to focus elements with Tab and then select or deselect them with Enter and Escape. If you are setting `disableKeyboardA11y={true}`, the nodes are not moveable with arrow keys anymore.

<Callout type="info">
  Nodes are only moveable with arrow keys when `nodesDraggable` and
  `nodesFocusable` are true (default behaviour).
</Callout>

### WAI-ARIA

- Edges: Default `aria-label` - overwritable with new `Edge` option `ariaLabel`
- Nodes: `ariaLabel` option (no default here, because we assume that there might be text inside the node)
- Minimap component: `aria-describedby` + title
- Attribution component: `aria-label`
- Controls component: `aria-label` for controls container and buttons

## Better accessible node-based UIs

- When your nodes don't have textual content, you should provide an aria-label via the node options.
- You can improve the default `aria-label` ('from source.id to target.id') of an edge, when your nodes have names that you could use by passing specific aria-labels to the edges.
- follow best [practice WAI-ARIA guides](https://w3c.github.io/aria-practices/) in your application

--END--