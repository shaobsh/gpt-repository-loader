The following text is a Git repository with code. The structure of the text are sections that begin with ----, followed by a single line containing the file path and file name, followed by a variable amount of lines containing the file contents. The text representing the Git repository ends when the symbols --END-- are encounted. Any further text beyond --END-- are meant to be interpreted as instructions using the aforementioned Git repository as context.
----
_meta.json
{
  "index": "API Reference",
  "react-flow": "<ReactFlow />",
  "react-flow-provider": "<ReactFlowProvider />",
  "components": "Components",
  "hooks": "Hooks",
  "types": "Types",
  "utils": "Utils"
}

----
react-flow-provider.mdx
---
title: The ReactFlowProvider component
---

# &lt;ReactFlowProvider />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/components/ReactFlowProvider/index.tsx/#L9)

The `<ReactFlowProvider />` component is a
[context provider](https://react.dev/learn/passing-data-deeply-with-context#) that
makes it possible to access a flow's internal state outside of the
[`<ReactFlow />`](/api-reference/react-flow) component. Many of the hooks we
provide rely on this component to work.

```tsx
import { ReactFlow,  ReactFlowProvider, useNodes } from '@xyflow/react'

export default function Flow() {
  return (
    <ReactFlowProvider>
      <ReactFlow nodes={...} edges={...} />
      <Sidebar />
    </ReactFlowProvider>
  )
}

function Sidebar() {
  // This hook will only work if the component it's used in is a child of a
  // <ReactFlowProvider />.
  const nodes = useNodes()

  return (
    <aside>
      {nodes.map((node) => (
        <div key={node.id}>
          Node {node.id} -
            x: {node.position.x.toFixed(2)},
            y: {node.position.y.toFixed(2)}
        </div>
      ))}
    </aside>
  )
}
```

## Notes

- If you're using a router and want your flow's state to persist across routes,
  it's vital that you place the `<ReactFlowProvider />` component _outside_ of
  your router.
- If you have multiple flows on the same page you will need to use a separate
  `<ReactFlowProvider />` for each flow.

----
index.mdx
---
title: Api Reference
---

import { ContentGrid, ContentGridItem } from '@xyflow/xy-ui';
import { BlogPostPreview } from 'xy-shared';

# API Reference

This reference attempts to document every function, hook, component, and type
exported by React Flow. If you are looking for guides and tutorials, please refer to our [learn section](/learn).

## How to use this reference

We think that documentation should answer two broad
questions: "what is this thing?" and "how do I use it?"

To that end, our API reference aims to **concisely** answer that first question
and learn section goes into more detail on the second. If you find yourself clicking
around the reference wondering what the heck any of this means, maybe we have a
guide that can help you out!

<ContentGrid className="mt-8">
  <ContentGridItem route="/learn/customization/custom-nodes">
    <BlogPostPreview
      title="Custom nodes"
      intro="A powerful feature of React Flow is the ability to add custom nodes. Within your custom nodes you can render everything you want. You can define multiple source and target handles and render form inputs or charts for example. In this guide we will implement a node with an input field that updates some text in another part of the application."
    />
  </ContentGridItem>
  <ContentGridItem route="/learn/layouting/layouting">
    <BlogPostPreview
      title="Layouting"
      intro="We regularly get asked how to handle layouting in React Flow. While we could build some basic layouting into React Flow, we believe that you know your app's requirements best and with so many options out there we think it's better you choose the best right tool for the job. In this guide we'll look at four layouting libraries and how to use them."
    />
  </ContentGridItem>
</ContentGrid>

## A note for our long-term users

If you're coming here from our old API pages things might look a bit different!
We've reorganized our documentation to make it easier to look things up if you
know what you're looking for. All our types, components, hooks, and util functions
get their own page now to help you find exactly what you need.

If you're new to React Flow or you're not sure where to look for something, take
a look at the section below.

## A note for JavaScript users

React Flow is written in TypeScript, but we know that not everyone uses it. We
encourage developers to use the technology that works best for them, and
throughout our documentation there is a blend of TypeScript and JavaScript
examples.

For our API reference, however, we use TypeScript's syntax to document the types
of props and functions. Here's a quick crash course on how to read it:

• `?` means that the field or argument is optional.

• `<T>` in a type definition represents a generic type parameter. Like a function
argument but for types! The definition `type Array<T> = ...` means a type called
`Array` that takes a generic type parameter `T`.

• `<T>` when referring to a type is like "filling in" a generic type parameter.
It's like calling a function but for types! The type `Array<number>` is the
type `Array` with the generic type parameter `T` filled in with the type
`number`.

• `T | U` means that the type is either `T` or `U`: this is often called a
_union_.

• `T & U` means that the type is both `T` and `U`: this is often called an
_intersection_.

The TypeScript folks have their own
[handy guide for reading types](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html)
that you might find useful. If you're still stuck on something, feel free to
drop by our [Discord](https://discord.com/invite/RVmnytFmGW) and ask for help!

----
hooks.mdx
---
title: Hooks
---

import { ApiReferenceSummary } from '@/components/api-reference-summary';

# Hooks

<ApiReferenceSummary category="hooks" />

----
react-flow.mdx
---
title: The ReactFlow component
---

import { Callout } from 'nextra/components';
import { PropsTable } from '@/components/props-table';
import {
  commonProps,
  viewportProps,
  edgeProps,
  interactionProps,
  connectionLineProps,
  keyboardProps,
  generalEventHandlerProps,
  nodeEventHandlerProps,
  edgeEventHandlerProps,
  connectionEventHandlerProps,
  paneEventHandlerProps,
  selectionEventHandlerProps,
} from '@/page-data/reference/ReactFlow.props.ts';

# &lt;ReactFlow />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/container/ReactFlow/index.tsx/#L47)

The `<ReactFlow />` component is the heart of your React Flow application. It
renders your nodes and edges, handles user interaction, and can manage its own
state if used as an [uncontrolled flow](/learn/advanced-use/uncontrolled-flow).

```tsx
import { ReactFlow } from '@xyflow/react'

export default function Flow() {
  return <ReactFlow
    nodes={...}
    edges={...}
    onNodesChange={...}
    ...
  />
}
```

This component takes a lot of different props, most of which are optional. We've
tried to document them in groups that make sense to help you find your way.

## Common props

These are the props you will most commonly use when working with React Flow. If
you are working with a controlled flow with custom nodes, you will likely use
almost all of these!

<PropsTable {...commonProps} />

## Viewport props

<PropsTable {...viewportProps} />

## Edge props

<PropsTable {...edgeProps} />

## Event handlers

<Callout type="warning">
  It's important to remember to define any event handlers outside of your
  component or using React's `useCallback` hook. If you don't, this can cause
  React Flow to enter an infinite re-render loop!
</Callout>

### General Events

<PropsTable {...generalEventHandlerProps} />

### Node Events

<PropsTable {...nodeEventHandlerProps} />

### Edge Events

<PropsTable {...edgeEventHandlerProps} />

### Connection Events

<PropsTable {...connectionEventHandlerProps} />

### Pane Events

<PropsTable {...paneEventHandlerProps} />

### Selection Events

<PropsTable {...selectionEventHandlerProps} />

## Interaction props

<PropsTable {...interactionProps} />

## Connection line props

<PropsTable {...connectionLineProps} />

## Keyboard props

React Flow let's you pass in a few different keyboard shortcuts as another way
to interact with your flow. We've tried to set up sensible defaults like using
backspace to delete any selected nodes or edges, but you can use these props to
set your own.

To disable any of these shortcuts, pass in `null` to to the prop you want to
disable.

<PropsTable {...keyboardProps} />

## Notes

- The props of this component get exported as `ReactFlowProps`

----
types.mdx
---
title: Types
---

import { ApiReferenceSummary } from '@/components/api-reference-summary';

# Types

<ApiReferenceSummary category="types" />

----
utils.mdx
---
title: Utils
---

import { ApiReferenceSummary } from '@/components/api-reference-summary';

# Utils

<ApiReferenceSummary category="utils" />

----
components.mdx
---
title: Components
---

import { ApiReferenceSummary } from '@/components/api-reference-summary';

# Components

<ApiReferenceSummary category="components" />

----
types/on-nodes-change.mdx
---
title: OnNodesChange
description: ''
---

import { PropsTable } from '@/components/props-table';
import { fields } from '@/page-data/reference/types/OnNodesChange.ts';

# OnNodesChange

This type is used for typing the [`onNodesChange`](/api-reference/react-flow#on-nodes-change) function.

```tsx
export type OnNodesChange<NodeType extends Node = Node> = (
  changes: NodeChange<NodeType>[],
) => void;
```

## Fields

<PropsTable {...fields} />

## Usage

This type accepts a generic type argument of custom nodes types. See this
[section in our Typescript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.

```tsx
const onNodesChange: OnNodesChange = useCallback(
  (changes) => setNodes((nds) => applyNodeChanges(changes, nds)),
  [setNodes],
);
```

----
types/_meta.json
{
  "background-variant": "BackgroundVariant",
  "handle-connection": "HandleConnection",
  "connection": "Connection",
  "connection-line-component-props": "ConnectionLineComponentProps",
  "connection-line-type": "ConnectionLineType",
  "coordinate-extent": "CoordinateExtent",
  "connection-state": "ConnectionState",
  "default-edge-options": "DefaultEdgeOptions",
  "delete-elements": "DeleteElements",
  "edge": "Edge",
  "edge-change": "EdgeChange",
  "edge-marker": "EdgeMarker",
  "edge-props": "EdgeProps",
  "fit-view-options": "FitViewOptions",
  "handle": "Handle",
  "marker-type": "MarkerType",
  "mini-map-node-props": "MiniMapNodeProps",
  "node": "Node",
  "node-props": "NodeProps",
  "node-change": "NodeChange",
  "node-origin": "NodeOrigin",
  "node-handle": "NodeHandle",
  "on-nodes-change": "OnNodesChange",
  "on-edges-change": "OnEdgesChange",
  "pan-on-scroll-mode": "PanOnScrollMode",
  "panel-position": "PanelPosition",
  "position": "Position",
  "pro-options": "ProOptions",
  "react-flow-instance": "ReactFlowInstance",
  "react-flow-json-object": "ReactFlowJsonObject",
  "resize-params": "ResizeParams",
  "viewport": "Viewport",
  "xy-position": "XYPosition"
}

----
types/node-change.mdx
---
title: NodeChange
description:
  The onNodesChange callback takes an array of NodeChange objects that you should
  use to update your flow's state. The NodeChange type is a union of six different
  object types that represent that various ways an node can change in a flow.
---

import { PropsTable } from '@/components/props-table';
import {
  nodeDimensionChangeFields,
  nodePositionChangeFields,
  nodeSelectionChangeFields,
  nodeRemoveChangeFields,
  nodeAddChangeFields,
  nodeReplaceChangeFields,
} from '@/page-data/reference/types/NodeChange.fields.ts';

# NodeChange

[Source on GitHub](https://github.com/xyflow/xyflow/blob/487b13c9ad8903789f56c6fcfd8222f9cb74b812/packages/system/src/types/changes.ts/#L47)

The [`onNodesChange`](/api-reference/react-flow#on-nodes-change) callback takes
an array of `NodeChange` objects that you should use to update your flow's state.
The `NodeChange` type is a union of six different object types that represent that
various ways an node can change in a flow.

```ts
export type NodeChange =
  | NodeDimensionChange
  | NodePositionChange
  | NodeSelectionChange
  | NodeRemoveChange
  | NodeAddChange
  | NodeReplaceChange;
```

## Variant types

### NodeDimensionChange

<PropsTable {...nodeDimensionChangeFields} />

### NodePositionChange

<PropsTable {...nodePositionChangeFields} />

### NodeSelectionChange

<PropsTable {...nodeSelectionChangeFields} />

### NodeRemoveChange

<PropsTable {...nodeRemoveChangeFields} />

### NodeAddChange

<PropsTable {...nodeAddChangeFields} />

### NodeReplaceChange

<PropsTable {...nodeReplaceChangeFields} />

----
types/edge-marker.mdx
---
title: EdgeMarker
description:
  Edges can optionally have markers at the start and end of an edge. The EdgeMarker
  type is used to configure those markers! Check the docs for MarkerType for details
  on what types of edge marker are available.
---

import { PropsTable } from '@/components/props-table';
import { edgeMarkerFields } from '@/page-data/reference/types/EdgeMarker.ts';

# EdgeMarker

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/edges.ts/#L70-L78)

Edges can optionally have markers at the start and end of an edge. The `EdgeMarker`
type is used to configure those markers! Check the docs for [`MarkerType`](/api-reference/types/marker-type)
for details on what types of edge marker are available.

```ts
export type EdgeMarker = {
  type: MarkerType;
  color?: string;
  width?: number;
  height?: number;
  markerUnits?: string;
  orient?: string;
  strokeWidth?: number;
};
```

## Fields

<PropsTable {...edgeMarkerFields} />

----
types/on-edges-change.mdx
---
title: OnEdgesChange
description: ''
---

import { PropsTable } from '@/components/props-table';
import { fields } from '@/page-data/reference/types/OnEdgesChange.ts';

# OnEdgesChange

This type is used for typing the [`onEdgesChange`](/api-reference/react-flow#on-edges-change) function.

```tsx
export type OnEdgesChange<EdgeType extends Edge = Edge> = (
  changes: EdgeChange<EdgeType>[],
) => void;
```

## Fields

<PropsTable {...fields} />

## Usage

This type accepts a generic type argument of custom edge types. See this
[section in our Typescript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.

```tsx
const onEdgesChange: OnEdgesChange = useCallback(
  (changes) => setEdges((eds) => applyEdgeChanges(changes, eds)),
  [setEdges],
);
```

----
types/node-handle.mdx
---
title: NodeHandle
description:
  Edges may optionally have a marker on either end. The MarkerType type enumerates
  the options available to you when configuring a given marker.
---

# NodeHandle

[Source on GitHub](https://github.com/xyflow/xyflow/blob/13897512d3c57e72c2e27b14ffa129412289d948/packages/system/src/types/nodes.ts#L139)

```ts
export type NodeHandle {
  x: number,
  y: number,
  position: Position,
  id?: string | null,
  width?: number,
  height?: number,
  type?: 'source' | 'target',
}
```

----
types/node-origin.mdx
---
title: NodeOrigin
description: The origin of a Node determines how it is placed relative to its own coordinates.
---

# NodeOrigin

The origin of a Node determines how it is placed relative to its own coordinates.
`[0, 0]` places it at the top left corner, `[0.5, 0.5]` right in the center and `[1, 1]` at the bottom right of its position.

```ts
export type NodeOrigin = [number, number];
```

----
types/resize-params.mdx
---
title: ResizeParams
description:
  The ResizeParams type is used to type the various events that are emitted by the
  NodeResizer component. You'll sometimes see this type extended with an additional
  direction field too.
---

import { PropsTable } from '@/components/props-table';
import { resizeParamsFields } from '@/page-data/reference/types/ResizeParams.ts';

# ResizeParams

[Source on Github](https://github.com/xyflow/xyflow/blob/v11/packages/node-resizer/src/types.ts/#L4)

The `ResizeParams` type is used to type the various events that are emitted by the
`<NodeResizer />` component. You'll sometimes see this type extended with an additional
direction field too.

```ts
export type ResizeParams = {
  x: number;
  y: number;
  width: number;
  height: number;
};
```

## Fields

<PropsTable {...resizeParamsFields} />

----
types/handle.mdx
---
title: Handle
description: 'Handle attributes like id, position, and type.'
---

import { PropsTable } from '@/components/props-table';
import { handleFields } from '@/page-data/reference/types/Handle.fields.ts';

# Handle

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/handles.ts/#L5)

The `Handle` type represents the attributes of a handle.

```ts
export type Handle = {
  id?: string | null;
  nodeId: string;
  x: number;
  y: number;
  position: Position;
  type: 'source' | 'target';
  width: number;
  height: number;
};
```

## Fields

<PropsTable {...handleFields} />

----
types/edge.mdx
---
title: Edge
description:
  'Where a Connection is the minimal description of an edge between two nodes,
  an `Edge` is the complete description with everything React Flow needs to know
  in order to render it.'
---

import { PropsTable } from '@/components/props-table';
import {
  defaultEdgeFields,
  smoothStepEdgeTypeFields,
  bezierEdgeTypeFields,
} from '@/page-data/reference/types/Edge.fields.ts';

# Edge

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/edges.ts/#L34-L353)

Where a [`Connection`](/api-reference/types/connection) is the minimal description of an edge between
two nodes, an `Edge` is the complete description with everything React Flow needs
to know in order to render it.

```ts
export type Edge<T> = DefaultEdge<T> | SmoothStepEdge<T> | BezierEdge<T>;
```

## Variants

### Edge

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/edges.ts/#L34-L353)

<PropsTable {...defaultEdgeFields} />

### SmoothStepEdge

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/edges.ts/#L45-L46)

The `SmoothStepEdge` variant has all the same fields as an `Edge`, but it also has the following additional fields:

<PropsTable {...smoothStepEdgeTypeFields} />

### BezierEdge

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/edges.ts/#L52-L53)

The `BezierEdge` variant has all the same fields as an `Edge`, but it also has the following additional fields:

<PropsTable {...bezierEdgeTypeFields} />

## Default edge types

You can create any of React Flow's default edges by setting the `type` property
to one of the following values:

- `"default"`
- `"straight"`
- `"step"`
- `"smoothstep"`
- `"simplebezier"`

If you don't set the `type` property at all, React Flow will fallback to the
`"default"` bezier curve edge type.

These default edges are available even if you set the [`edgeTypes`](/api-reference/react-flow#edge-types)
prop to something else, unless you override any of these keys directly.

----
types/connection-state.mdx
---
title: ConnectionState
description: 'Data about an ongoing connection.'
---

import { PropsTable } from '@/components/props-table';
import { connectionStateFields } from '@/page-data/reference/types/ConnectionState.fields.ts';

# ConnectionState

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts/#L148-L174)

The `ConnectionState` type bundles all information about an ongoing connection. It is returned by the [`useConnection`](/api-reference/hooks/use-connection) hook.

```ts
type NoConnection = {
  inProgress: false;
  isValid: null;
  from: null;
  fromHandle: null;
  fromPosition: null;
  fromNode: null;
  to: null;
  toHandle: null;
  toPosition: null;
  toNode: null;
};
type ConnectionInProgress = {
  inProgress: true;
  isValid: boolean | null;
  from: XYPosition;
  fromHandle: Handle;
  fromPosition: Position;
  fromNode: NodeBase;
  to: XYPosition;
  toHandle: Handle | null;
  toPosition: Position;
  toNode: NodeBase | null;
};

type ConnectionState = ConnectionInProgress | NoConnection;
```

## Fields

<PropsTable {...connectionStateFields} />

----
types/position.mdx
---
title: Position
description:
  'While PanelPosition can be used to place a component in the corners of a
  container, the Position enum is less precise and used primarily in relation
  to edges and handles.'
---

# Position

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/utils.ts/#L1)

While [`PanelPosition`](/api-reference/types/panel-position) can be used to place a component in the
corners of a container, the `Position` enum is less precise and used primarily
in relation to edges and handles.

```ts
export enum Position {
  Left = 'left',
  Top = 'top',
  Right = 'right',
  Bottom = 'bottom',
}
```

----
types/connection-line-component-props.mdx
---
title: ConnectionLineComponentProps
description:
  'If you want to render a custom component for connection lines, you can set the
  connectionLineComponent prop on the ReactFlow component. The ConnectionLineComponentProps
  are passed to your custom component.'
---

import { PropsTable } from '@/components/props-table';
import { connectionLineComponentPropsFields } from '@/page-data/reference/types/ConnectionLineComponentProps.fields.ts';

# ConnectionLineComponentProps

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/edges.ts/#L193)

If you want to render a custom component for connection lines, you can set the
`connectionLineComponent` prop on the [`<ReactFlow />`](/api-reference/react-flow#connection-connectionLineComponent)
component. The `ConnectionLineComponentProps` are passed to your custom component.

```ts
export type ConnectionLineComponentProps = {
  connectionLineStyle?: React.CSSProperties;
  connectionLineType: ConnectionLineType;
  fromNode?: Node;
  fromHandle?: Handle;
  fromX: number;
  fromY: number;
  toX: number;
  toY: number;
  fromPosition: Position;
  toPosition: Position;
  connectionStatus: 'valid' | 'invalid' | null;
};
```

## Props

<PropsTable {...connectionLineComponentPropsFields} />

----
types/handle-connection.mdx
---
title: HandleConnection
description: 'The HandleConnection type is a Connection that includes the edgeId.'
---

import { PropsTable } from '@/components/props-table';
import { connectionFields } from '@/page-data/reference/types/HandleConnection.fields.ts';

# HandleConnection

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts/#L36-L37)

The `HandleConnection` type is an extention of a basic [Connection](/api-reference/types/connection) that includes the `edgeId`.

```ts
export type HandleConnection = {
  source: string | null;
  target: string | null;
  sourceHandle: string | null;
  targetHandle: string | null;
  edgeId: string;
};
```

## Fields

<PropsTable {...connectionFields} />

----
types/marker-type.mdx
---
title: MarkerType
description:
  Edges may optionally have a marker on either end. The MarkerType type enumerates
  the options available to you when configuring a given marker.
---

# MarkerType

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/edges.ts/#L82-L83)

Edges may optionally have a marker on either end. The MarkerType type enumerates
the options available to you when configuring a given marker.

```ts
export enum MarkerType {
  Arrow = 'arrow',
  ArrowClosed = 'arrowclosed',
}
```

----
types/mini-map-node-props.mdx
---
title: MiniMapNodeProps
description: ''
---

import { PropsTable } from '@/components/props-table';
import { minimapNodePropsFields } from '@/page-data/reference/types/MiniMapNodeProps.fields.ts';

# MiniMapNodeProps

[Source on GitHub](https://github.com/xyflow/xyflow/blob/487b13c9ad8903789f56c6fcfd8222f9cb74b812/packages/react/src/additional-components/MiniMap/types.ts/#L60)

```ts
export type MiniMapNodeProps = {
  id: string;
  x: number;
  y: number;
  width: number;
  height: number;
  borderRadius: number;
  className: string;
  color: string;
  shapeRendering: string;
  strokeColor: string;
  strokeWidth: number;
  style?: CSSProperties;
  selected: boolean;
  onClick?: (event: MouseEvent, id: string) => void;
};
```

## Fields

<PropsTable {...minimapNodePropsFields} />

----
types/pro-options.mdx
---
title: ProOptions
description:
  "By default, we render a small attribution in the corner of your flows that links
  back to the project. Anyone is free to remove this attribution whether they're a
  Pro subscriber or not but we ask that you take a quick look at our removing
  attribution guide before doing so."
---

# ProOptions

By default, we render a small attribution in the corner of your flows that links back
to the project. Anyone is free to remove this attribution whether they're a Pro subscriber
or not but we ask that you take a quick look at our
[removing attribution](/learn/troubleshooting/remove-attribution) guide before doing so.

```ts
type ProOptions = {
  hideAttribution?: boolean;
};
```

----
types/connection.mdx
---
title: Connection
description:
  'The Connection type is the basic minimal description of an Edge between two
  nodes. The addEdge util can be used to upgrade a Connection to an Edge.'
---

import { PropsTable } from '@/components/props-table';
import { connectionFields } from '@/page-data/reference/types/Connection.fields.ts';

# Connection

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts/#L29-L34)

The `Connection` type is the basic minimal description of an [`Edge`](/api-reference/types/edge)
between two nodes. The [`addEdge`](/api-reference/utils/add-edge) util can be used to upgrade
a `Connection` to an [`Edge`](/api-reference/types/edge).

```ts
export type Connection = {
  source: string | null;
  target: string | null;
  sourceHandle: string | null;
  targetHandle: string | null;
};
```

## Fields

<PropsTable {...connectionFields} />

----
types/viewport.mdx
---
title: Viewport
description:
  'Internally, React Flow maintains a coordinate system that is independent of the
  rest of the page. The Viewport type tells you where in that system your flow
  is currently being display at and how zoomed in or out it is.'
---

import { PropsTable } from '@/components/props-table';
import { viewportFields } from '@/page-data/reference/types/Viewport.fields.ts';

# Viewport

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts/#L75-L76)

Internally, React Flow maintains a coordinate system that is independent of the
rest of the page. The `Viewport` type tells you where in that system your flow
is currently being display at and how zoomed in or out it is.

```ts
export type Viewport = {
  x: number;
  y: number;
  zoom: number;
};
```

## Fields

<PropsTable {...viewportFields} />

## Notes

- A `Transform` has the same properties as the viewport, but they represent
  different things. Make sure you don't get them muddled up or things will start
  to look weird!

----
types/panel-position.mdx
---
title: PanelPosition
description:
  'This type is mostly used to help position things on top of the flow viewport.
  For example both the MiniMap and Controls components take a position prop of
  this type.'
---

# PanelPosition

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts/#L111-L112)

This type is mostly used to help position things on top of the flow viewport. For
example both the [`<MiniMap />`](/api-reference/components/minimap) and
[`<Controls />`](/api-reference/components/controls) components take a `position`
prop of this type.

```ts
export type PanelPosition =
  | 'top-left'
  | 'top-center'
  | 'top-right'
  | 'bottom-left'
  | 'bottom-center'
  | 'bottom-right';
```

----
types/node-props.mdx
---
title: NodeProps
description:
  'When you implement a custom node it is wrapped in a component that enables
  basic functionality like selection and dragging. Your custom node receives the
  following props:'
---

import { PropsTable } from '@/components/props-table';
import { nodePropsFields } from '@/page-data/reference/types/NodeProps.fields.ts';

# NodeProps&lt;T>

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/nodes.ts/#L89)

When you implement a [custom node](/learn/customization/custom-nodes) it is
wrapped in a component that enables basic functionality like selection and
dragging. Your custom node receives the following props:

```ts
export type NodeProps<NodeType extends Node = Node> = {
  id: string;
  data: Node['data'];
  dragHandle?: boolean;
  type?: string;
  selected?: boolean;
  isConnectable?: boolean;
  zIndex?: number;
  positionAbsoluteX: number;
  positionAbsoluteY: number;
  dragging: boolean;
  targetPosition?: Position;
  sourcePosition?: Position;
};
```

## Usage

```tsx
import { useState } from 'react';
import { NodeProps, Node } from '@xyflow/react';

export type CounterNode = Node<
  {
    initialCount?: number;
  },
  'counter'
>;

export default function CounterNode(props: NodeProps<CounterNode>) {
  const [count, setCount] = useState(props.data?.initialCount ?? 0);

  return (
    <div>
      <p>Count: {count}</p>
      <button className="nodrag" onClick={() => setCount(count + 1)}>
        Increment
      </button>
    </div>
  );
}
```

Remember to register your custom node by adding it to the
[`nodeTypes`](/api-reference/react-flow#nodetypes) prop of your
`<ReactFlow />` component.

```tsx
import { ReactFlow } from '@xyflow/react';
import CounterNode from './CounterNode';

const nodeTypes = {
  counterNode: CounterNode,
};

export default function App() {
  return <ReactFlow nodeTypes={nodeTypes} ... />
}
```

You can read more in our [custom node guide](/learn/customization/custom-nodes).

## Fields

<PropsTable {...nodePropsFields} />

## Notes

- If you have controls (like a slider) or other elements inside your custom node
  that **should not drag the node** you can add the class `nodrag` to those elements.
  This prevents the default drag behaviour as well as the default node selection
  behvaiour when elements with this class are clicked.

  ```tsx
  export default function CustomNode(props: NodeProps) {
    return (
      <div>
        <input className="nodrag" type="range" min={0} max={100} />
      </div>
    );
  }
  ```

- If you have scroll containers inside your custom node you can add the class
  `nowheel` to **disable the default canvas pan behaviour when scrolling** inside
  your custom nodes.

  ```tsx
  export default function CustomNode(props: NodeProps) {
    return (
      <div className="nowheel" style={{ overflow: 'auto' }}>
        <p>Scrollable content...</p>
      </div>
    );
  }
  ```

- When creating your own custom nodes, you will also need to remember to style
  them! Custom nodes have no default styles unlike the built-in nodes so you
  can use any styling method you like such as
  [styled components](/examples/styling/styled-components) or
  [tailwind](/examples/styling/tailwind).

----
types/edge-change.mdx
---
title: EdgeChange
description:
  The onEdgesChange callback takes an array of EdgeChange objects that you should
  use to update your flow's state. The EdgeChange type is a union of four different
  object types that represent that various ways an edge can change in a flow.
---

import { PropsTable } from '@/components/props-table';
import {
  edgeAddChangeFields,
  edgeRemoveChangeFields,
  edgeResetChangeFields,
  edgeSelectionChangeFields,
} from '@/page-data/reference/types/EdgeChange.fields.ts';

# EdgeChange

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/changes.ts/#L68-L72)

The [`onEdgesChange`](/api-reference/react-flow#on-edges-change) callback takes
an array of `EdgeChange` objects that you should use to update your flow's state.
The `EdgeChange` type is a union of four different object types that represent that
various ways an edge can change in a flow.

```ts
export type EdgeChange =
  | EdgeAddChange
  | EdgeRemoveChange
  | EdgeResetChange
  | EdgeSelectionChange;
```

## Variants

### EdgeAddChange

<PropsTable {...edgeAddChangeFields} />

### EdgeRemoveChange

<PropsTable {...edgeRemoveChangeFields} />

### EdgeResetChange

<PropsTable {...edgeResetChangeFields} />

### EdgeSelectionChange

<PropsTable {...edgeSelectionChangeFields} />

----
types/background-variant.mdx
---
title: BackgroundVariant
description:
  'The three variants are exported as an enum for convenience. You can either import
  the enum and use it like BackgroundVariant.Lines or you can use the raw string
  value directly.'
---

# BackgroundVariant

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/additional-components/Background/types.ts)

The three variants are exported as an enum for convenience. You can either import
the enum and use it like `BackgroundVariant.Lines` or you can use the raw string
value directly.

```ts
export enum BackgroundVariant {
  Lines = 'lines',
  Dots = 'dots',
  Cross = 'cross',
}
```

----
types/fit-view-options.mdx
---
title: FitViewOptions
description:
  'When calling fitView these options can be used to customize the behaviour.
  For example, the duration option can be used to transform the viewport smoothly
  over a given amount of time.'
---

import { PropsTable } from '@/components/props-table';
import { fitViewOptionsFields } from '@/page-data/reference/types/FitViewOptions.ts';

# FitViewOptions

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/general.ts/#L67-L68)

When calling [`fitView`](/api-reference/types/react-flow-instance#fitview) these options can be used
to customize the behaviour. For example, the `duration` option can be used to
transform the viewport smoothly over a given amount of time.

```ts
export type FitViewOptions = {
  padding?: number;
  includeHiddenNodes?: boolean;
  minZoom?: number;
  maxZoom?: number;
  duration?: number;
  nodes?: (Partial<Node> & { id: Node['id'] })[];
};
```

## Fields

<PropsTable {...fitViewOptionsFields} />

----
types/coordinate-extent.mdx
---
title: CoordinateExtent
description:
  'A coordinate extent represents two points in a coordinate system: one in the top
  left corner and one in the bottom right corner. It is used to represent the
  bounds of nodes in the flow or the bounds of the viewport.'
---

# CoordinateExtent

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/utils.ts/#L36-L37)

A coordinate extent represents two points in a coordinate system: one in the top
left corner and one in the bottom right corner. It is used to represent the
bounds of nodes in the flow or the bounds of the viewport.

```ts
export type CoordinateExtent = [[number, number], [number, number]];
```

## Notes

- Props that expect a `CoordinateExtent` usually default to `[[-∞, -∞], [+∞, +∞]]`
  to represent an unbounded extent.

----
types/delete-elements.mdx
---
title: DeleteElements
description: 'DeleteElements deletes nodes and edges from the flow and return the delted edges and nodes asynchronously.'
---

# DeleteElements

DeleteElements deletes provided nodes and edges and handles deleting any connected edges as well as child nodes. Returns successfully deleted edges and nodes asynchronously.

```ts
export type DeleteElements = (payload: {
  nodes?: (Partial<Node> & { id: Node['id'] })[];
  edges?: (Partial<Edge> & { id: Edge['id'] })[];
}) => Promise<{
  deletedNodes: Node[];
  deletedEdges: Edge[];
}>;
```

----
types/react-flow-instance.mdx
---
title: ReactFlowInstance
description:
  'The ReactFlowInstance provides a collection of methods to query and manipulate
  the internal state of your flow. You can get an instance by using the useReactFlow
  hook or attaching a listener to the onInit event.'
---

import { PropsTable } from '@/components/props-table';
import {
  nodesAndEdgesFields,
  intersectionFields,
  viewportFields,
} from '@/page-data/reference/types/ReactFlowInstance.fields.ts';

# ReactFlowInstance

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/instance.ts/#L178-L179)

The `ReactFlowInstance` provides a collection of methods to query and manipulate
the internal state of your flow. You can get an instance by using the
[`useReactFlow`](/api-reference/hooks/use-react-flow) hook or attaching a listener to the
[`onInit`](/api-reference/react-flow#event-oninit) event.

```ts
export type ReactFlowInstance<T, U> = {
  // Nodes and Edges
  getNode: (id: string) => Node<T> | undefined;
  getNodes: () => Node<T>[];
  addNodes: (payload: Node<T>[] | Node<T>) => void;
  setNodes: (payload: Node<T>[] | ((nodes: Node<T>[]) => Node<T>[])) => void;

  getEdge: (id: string) => Edge<U> | undefined;
  getEdges: () => Edge<U>[];
  addEdges: (payload: Edge<U>[] | Edge<U>) => void;
  setEdges: (payload: Edge<U>[] | ((edges: Edge<U>[]) => Edge<U>[])) => void;

  toObject: () => ReactFlowJsonObject<T, U>;
  deleteElements: (payload: {
    nodes?: (Partial<Node> & { id: Node['id'] })[];
    edges?: (Partial<Edge> & { id: Edge['id'] })[];
  }) => void;

  // Intersections
  getIntersectingNodes: (
    node: (Partial<Node<T>> & { id: Node['id'] }) | Rect,
    partially?: boolean,
    nodes?: Node<T>[],
  ) => Node<T>[];

  isNodeIntersecting: (
    node: (Partial<Node<T>> & { id: Node['id'] }) | Rect,
    area: Rect,
    partially?: boolean,
  ) => boolean;

  // Viewport
  viewportInitialized: boolean;
  zoomIn: (options?: { duration: number }) => void;
  zoomOut: (options?: { duration: number }) => void;
  zoomTo: (zoomLevel: number, options?: { duration: number }) => void;
  getZoom: () => number;
  setViewport: (viewport: Viewport, options?: { duration: number }) => void;
  getViewport: () => Viewport;
  fitView: (fitViewOptions?: FitViewOptions) => boolean;
  setCenter: (
    x: number,
    y: number,
    options?: { duration: number; zoom: number },
  ) => void;
  fitBounds: (
    bounds: Rect,
    options?: { duration: number; padding: number },
  ) => void;
  screenToFlowPosition: (position: { x: number; y: number }) => {
    x: number;
    y: number;
  };
  flowToScreenPosition: (position: { x: number; y: number }) => {
    x: number;
    y: number;
  };
  updateNode: (
    id: string,
    nodeUpdate: Partial<NodeType> | ((node: NodeType) => Partial<NodeType>),
    options?: { replace: boolean },
  ) => void;
  updateNodeData: (
    id: string,
    dataUpdate:
      | Partial<NodeType>['data']
      | ((node: Node) => Partial<NodeType>['data']),
    options?: { replace: boolean },
  ) => void;
  updateEdge: (
    id: string,
    edgeUpdate: Partial<EdgeType> | ((node: EdgeType) => Partial<EdgeType>),
    options?: { replace: boolean },
  ) => void;
  updateEdgeData: (
    id: string,
    dataUpdate:
      | Partial<EdgeType>['data']
      | ((node: Edge) => Partial<EdgeType>['data']),
    options?: { replace: boolean },
  ) => void;
};
```

## Fields

### Nodes and edges

<PropsTable {...nodesAndEdgesFields} />

### Intersections

<PropsTable {...intersectionFields} />

### Viewport fields

<PropsTable {...viewportFields} />

----
types/pan-on-scroll-mode.mdx
---
title: PanOnScrollMode
description:
  This enum is used to set the different modes of panning the viewport when the
  user scrolls.
---

# PanOnScrollMode

[Source on GitHub](https://github.com/xyflow/xyflow/blob/6e237ad2b77de8add92cb4e19ada3cdd8773d53c/packages/core/src/types/general.ts#L103C1-L107C2)

This enum is used to set the different modes of panning the viewport when the
user scrolls. The `Free` mode allows the user to pan in any direction by scrolling
with a device like a trackpad. The `Vertical` and `Horizontal` modes restrict
scroll panning to only the vertical or horizontal axis, respectively.

```ts
export enum PanOnScrollMode {
  Free = 'free',
  Vertical = 'vertical',
  Horizontal = 'horizontal',
}
```

----
types/react-flow-json-object.mdx
---
title: ReactFlowJsonObject
description:
  'A JSON-compatible representation of your flow. You can use this to save the flow
  to a database for example and load it back in later.'
---

import { PropsTable } from '@/components/props-table';
import { reactFlowJsonObjectFields } from '@/page-data/reference/types/ReactFlowJsonObject.fields.ts';

# ReactFlowJsonObject

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/instance.ts/#L5)

A JSON-compatible representation of your flow. You can use this to save the flow
to a database for example and load it back in later.

```ts
export type ReactFlowJsonObject<T, U> = {
  nodes: Node<T>[];
  edges: Edge<U>[];
  viewport: Viewport;
};
```

## Fields

<PropsTable {...reactFlowJsonObjectFields} />

----
types/default-edge-options.mdx
---
title: DefaultEdgeOptions
description:
  'Many properties on an Edge are optional. When a new edge is created, the
  properties that are not provided will be filled in with the default values passed
  to the defaultEdgeOptions prop of the ReactFlow component.'
---

import { PropsTable } from '@/components/props-table';
import { defaultEdgeOptionsFields } from '@/page-data/reference/types/DefaultEdgeOptions.fields.ts';

# DefaultEdgeOptions

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/edges.ts/#L88-L89)

Many properties on an [`Edge`](/api-reference/types/edge) are optional. When a new edge is created,
the properties that are not provided will be filled in with the default values
passed to the `defaultEdgeOptions` prop of the [`<ReactFlow />`](/api-reference/react-flow#defaultedgeoptions)
component.

```ts
export type DefaultEdgeOptions<T> = {
  type?: string;
  animated?: boolean;
  hidden?: boolean;
  deletable?: boolean;
  selectable?: boolean;
  data?: T;
  selected?: boolean;
  markerStart?: string | EdgeMarker;
  markerEnd?: string | EdgeMarker;
  zIndex?: number;
  ariaLabel?: string;
  interactionWidth?: number;
  focusable?: boolean;
};
```

## Fields

<PropsTable {...defaultEdgeOptionsFields} />

----
types/node.mdx
---
title: Node
description:
  'The Node type represents everything React Flow needs to know about a given node.
  Many of these properties can be manipulated both by React Flow or by you, but
  some such as width and height should be considered read-only.'
---

import { Callout } from 'nextra/components';
import { PropsTable } from '@/components/props-table';
import { nodeFields } from '@/page-data/reference/types/Node.fields.ts';

# Node

<Callout type="info">
  **Deprecation of `parentNode` property!** We have renamed the `parentNode`
  option to `parentId` in version 11.11.0. The old property is still supported
  but will be removed in version 12.
</Callout>

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/nodes.ts/#L10)

The `Node` type represents everything React Flow needs to know about a given node.
Many of these properties can be manipulated both by React Flow or by you, but
some such as `width` and `height` should be considered read-only.

```ts
export type Node<
  NodeData extends Record<string, unknown> = Record<string, unknown>,
  NodeType extends string = string,
> = {
  id: string;
  position: XYPosition;
  data: NodeData;
  type?: NodeType;
  sourcePosition?: Position;
  targetPosition?: Position;
  hidden?: boolean;
  selected?: boolean;
  dragging?: boolean;
  draggable?: boolean;
  selectable?: boolean;
  connectable?: boolean;
  resizing?: boolean;
  deletable?: boolean;
  dragHandle?: string;
  width?: number | null;
  height?: number | null;
  parentId?: string;
  zIndex?: number;
  extent?: 'parent' | CoordinateExtent;
  expandParent?: boolean;
  ariaLabel?: string;
  focusable?: boolean;
  style?: React.CSSProperties;
  className?: string;
  origin?: NodeOrigin;
  handles?: NodeHandle[];
  measured?: {
    width?: number;
    height?: number;
  };
};
```

## Fields

<PropsTable {...nodeFields} />

## Default node types

You can create any of React Flow's default nodes by setting the `type` property
to one of the following values:

- `"default"`
- `"input"`
- `"output"`
- `"group"`

If you don't set the `type` property at all, React Flow will fallback to the
`"default"` node with both an input and output port.

These default nodes are available even if you set the [`nodeTypes`](/api-reference/react-flow#node-types)
prop to something else, unless you override any of these keys directly.

## Notes

- You shouldn't try to set the `width` or `height` of a node directly. It is
  calculated internally by React Flow and used when rendering the node in the
  viewport. To control a node's size you should use the `style` or `className`
  props to apply CSS styles instead.

----
types/connection-line-type.mdx
---
title: ConnectionLineType
description:
  'If you set the connectionLineType prop on your ReactFlow component, it will
  dictate the style of connection line rendered when creating new edges.'
---

# ConnectionLineType

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/edges.ts/#L62)

If you set the `connectionLineType` prop on your [`<ReactFlow />`](/api-reference/react-flow#connection-connectionLineType)
component, it will dictate the style of connection line rendered when creating
new edges.

```ts
export enum ConnectionLineType {
  Bezier = 'default',
  Straight = 'straight',
  Step = 'step',
  SmoothStep = 'smoothstep',
  SimpleBezier = 'simplebezier',
}
```

## Notes

- If you choose to render a custom connection line component, this value will be
  passed to your component as part of its [`ConnectionLineComponentProps`](/api-reference/types/connection-line-component-props).

----
types/edge-props.mdx
---
title: EdgeProps
description:
  'When you implement a custom edge it is wrapped in a component that enables some
  basic functionality. Your custom edge component receives the following props:'
---

import { PropsTable } from '@/components/props-table';
import { edgePropsFields } from '@/page-data/reference/types/EdgeProps.ts';

# EdgeProps

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/edges.ts/#L100)

When you implement a custom edge it is wrapped in a component that enables some
basic functionality. Your custom edge component receives the following props:

```ts
export type EdgeProps<EdgeType extends Edge = Edge> = {
  id: string;
  animated: boolean;
  data: EdgeType['data'];
  style: React.CSSProperties;
  selected: boolean;
  source: string;
  target: string;
  sourceHandleId?: string | null;
  targetHandleId?: string | null;
  interactionWidth: number;
  sourceX: number;
  sourceY: number;
  targetX: number;
  targetY: number;
  sourcePosition: Position;
  targetPosition: Position;
  label?: string | React.ReactNode;
  labelStyle?: React.CSSProperties;
  labelShowBg?: boolean;
  labelBgStyle?: CSSProperties;
  labelBgPadding?: [number, number];
  labelBgBorderRadius?: number;
  markerStart?: string;
  markerEnd?: string;
  pathOptions?: any;
};
```

## Fields

<PropsTable {...edgePropsFields} />

----
types/xy-position.mdx
---
title: XYPosition
description: All positions are stored in an object with x and y coordinates.
---

# XYPosition

All positions are stored in an object with x and y coordinates.

```ts
export type XYPosition = {
  x: number;
  y: number;
};
```

----
utils/_meta.json
{
  "add-edge": "addEdge()",
  "apply-edge-changes": "applyEdgeChanges()",
  "apply-node-changes": "applyNodeChanges()",
  "get-bezier-path": "getBezierPath()",
  "get-connected-edges": "getConnectedEdges()",
  "get-incomers": "getIncomers()",
  "get-marker-end": "getMarkerEnd()",
  "get-nodes-bounds": "getNodesBounds()",
  "get-outgoers": "getOutgoers()",
  "get-simple-bezier-path": "getSimpleBezierPath()",
  "get-smooth-step-path": "getSmoothStepPath()",
  "get-straight-path": "getStraightPath()",
  "get-viewport-for-bounds": "getViewportForBounds()",
  "is-edge": "isEdge()",
  "is-node": "isNode()",
  "reconnect-edge": "reconnectEdge()"
}

----
utils/get-straight-path.mdx
---
title: getStraightPath()
description: 'Calculates the straight line path between two points.'
---

import { PropsTable } from '@/components/props-table';
import { signature } from '@/page-data/reference/utils/getStraightPath.ts';

# getStraightPath()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/edges/straight-edge.ts/#L30)

Calculates the straight line path between two points.

```js
import { getStraightPath } from '@xyflow/react';

const source = { x: 0, y: 20 };
const target = { x: 150, y: 100 };

const [path, labelX, labelY, offsetX, offsetY] = getStraightPath({
  sourceX: source.x,
  sourceY: source.y,
  targetX: target.x,
  targetY: target.y,
});

console.log(path); //=> "M 0,20L 150,100"
console.log(labelX, labelY); //=> 75, 60
console.log(offsetX, offsetY); //=> 75, 40
```

## Signature

<PropsTable {...signature} />

## Notes

- This function returns a tuple (aka a fixed-size array) to make it easier to work with multiple edge paths at once.

----
utils/get-incomers.mdx
---
title: getIncomers()
description:
  'This util is used to tell you what nodes, if any, are connected to the given node
  as the source of an edge.'
---

import { PropsTable } from '@/components/props-table';
import { signature } from '@/page-data/reference/utils/getIncomers.ts';

# getIncomers()

[Source on GitHub]https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/graph.ts/#L91)

This util is used to tell you what nodes, if any, are connected to the given node
as the _source_ of an edge.

```ts
import { getIncomers } from '@xyflow/react';

const nodes = [];
const edges = [];

const incomers = getIncomers(
  { id: '1', position: { x: 0, y: 0 }, data: { label: 'node' } },
  nodes,
  edges,
);
```

## Signature

<PropsTable {...signature} />

----
utils/get-marker-end.mdx
---
title: getMarkerEnd()
description: 'Helper that returns internal marker id or user defined marker id.'
---

import { PropsTable } from '@/components/props-table';
import { signature } from '@/page-data/reference/utils/getMarkerEnd.ts';

# getMarkerEnd()

[Source on Github](https://github.com/xyflow/xyflow/blob/v11/packages/core/src/components/Edges/utils.ts/#L6)

Helper that returns internal marker id or user defined marker id.

```js
import { getMarkerEnd } from '@xyflow/react';

const markerEndId = getMarkerEnd(MarkerType.Arrow);
```

## Signature

<PropsTable {...signature} />

----
utils/reconnect-edge.mdx
---
title: reconnectEdge()
description:
  'A handy utility to reconnect an existing Edge with new properties. This searches
  your edge array for an edge with a matching id and updates its properties with
  the connection you provide.'
---

import { Callout } from 'nextra/components';
import { PropsTable } from '@/components/props-table';
import { signature } from '@/page-data/reference/utils/reconnectEdge.ts';

# reconnectEdge()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/core/src/utils/graph.ts/#L97)

A handy utility to update an existing [`Edge`](/api-reference/types/edge) with new properties.
This searches your edge array for an edge with a matching `id` and updates its
properties with the connection you provide.

```js
const onReconnect = useCallback(
  (oldEdge: Edge, newConnection: Connection) => setEdges((els) => reconnectEdge(oldEdge, newConnection, els)),
  []
);
```

## Signature

<PropsTable {...signature} />

----
utils/get-simple-bezier-path.mdx
---
title: getSimpleBezierPath()
description:
  'The getSimpleBezierPath util returns everything you need to render a simple
  bezier edge between two nodes.'
---

import { PropsTable } from '@/components/props-table';
import { signature } from '@/page-data/reference/utils/getSimpleBezierPath.ts';

# getSimpleBezierPath()

[Source on Github](https://github.com/xyflow/xyflow/blob/main/packages/react/src/components/Edges/SimpleBezierEdge.tsx/#L32)

The `getSimpleBezierPath` util returns everything you need to render a simple
bezier edge between two nodes.

```js
import { Position, getSimpleBezierPath } from '@xyflow/react';

const source = { x: 0, y: 20 };
const target = { x: 150, y: 100 };

const [path, labelX, labelY, offsetX, offsetY] = getSimpleBezierPath({
  sourceX: source.x,
  sourceY: source.y,
  sourcePosition: Position.Right,
  targetX: target.x,
  targetY: target.y,
  targetPosition: Position.Left,
});

console.log(path); //=> "M0,20 C75,20 75,100 150,100"
console.log(labelX, labelY); //=> 75, 60
console.log(offsetX, offsetY); //=> 75, 40
```

## Signature

<PropsTable {...signature} />

## Notes

- This function returns a tuple (aka a fixed-size array) to make it easier to
  work with multiple edge paths at once.

----
utils/is-edge.mdx
---
title: isEdge()
description:
  'Test whether an object is useable as an Edge. In TypeScript this is a type
  guard that will narrow the type of whatever you pass in to Edge if it returns
  true.'
---

import { PropsTable } from '@/components/props-table';
import { signature } from '@/page-data/reference/utils/isEdge.ts';

# isEdge()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/graph.ts/#L39-L40)

Test whether an object is useable as an [`Edge`](/api-reference/types/edge). In TypeScript
this is a type guard that will narrow the type of whatever you pass in to
[`Edge`](/api-reference/types/edge) if it returns `true`.

```js
import { isEdge } from '@xyflow/react';

const edge = {
  id: 'edge-a',
  source: 'a',
  target: 'b',
};

if (isEdge(edge)) {
  // ..
}
```

## Signature

<PropsTable {...signature} />

----
utils/get-nodes-bounds.mdx
---
title: getNodesBounds()
description:
  'Returns the bounding box that contains all the given nodes in an array. This can
  be useful when combined with getTransformForBounds to calculate the correct
  transform to fit the given nodes in a viewport.'
---

import { Callout } from 'nextra/components';
import { PropsTable } from '@/components/props-table';
import { signature } from '@/page-data/reference/utils/getRectOfNodes.ts';

# getNodesBounds()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/graph.ts/#L133)

Returns the bounding box that contains all the given nodes in an array. This can
be useful when combined with [`getViewportForBounds`](/api-reference/utils/get-viewport-for-bounds)
to calculate the correct transform to fit the given nodes in a viewport.

<Callout type="info" emoji="ℹ️">
  This function was previously called `getRectOfNodes`
</Callout>

```js
import { getNodesBounds } from '@xyflow/react';

const nodes = [
  {
    id: 'a',
    position: { x: 0, y: 0 },
    data: { label: 'a' },
    width: 50,
    height: 25,
  },
  {
    id: 'b',
    position: { x: 100, y: 100 },
    data: { label: 'b' },
    width: 50,
    height: 25,
  },
];

const bounds = getNodesBounds(nodes);
```

## Signature

<PropsTable {...signature} />

----
utils/get-connected-edges.mdx
---
title: getConnectedEdges()
description:
  'Given an array of nodes that may be connected to one another and an array of
  all your edges, this util gives you an array of edges that connect any of the
  given nodes together.'
---

import { PropsTable } from '@/components/props-table';
import { signature } from '@/page-data/reference/utils/getConnectedEdges.ts';

# getConnectedEdges()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/graph.ts/#L224)

Given an array of nodes that may be connected to one another and an array of
_all_ your edges, this util gives you an array of edges that connect any of the
given nodes together.

```js
import { getConnectedEdges } from '@xyflow/react';

const nodes = [];
const edges = [];

const connectedEdges = getConnectedEdges(nodes, edges);
```

## Signature

<PropsTable {...signature} />

----
utils/add-edge.mdx
---
title: addEdge()
description:
  "This util is a convenience function to add a new Edge to an array of edges.
  It also performs some validation to make sure you don't add an invalid edge or
  duplicate an existing one."
---

import { PropsTable } from '@/components/props-table';
import { signature } from '@/page-data/reference/utils/addEdge.ts';

# addEdge()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/edges/general.ts/#L100)

This util is a convenience function to add a new [`Edge`](/api-reference/types/edge) to an
array of edges. It also performs some validation to make sure you don't add an
invalid edge or duplicate an existing one.

```js
import { useCallback } from 'react';
import {
  ReactFlow,
  addEdge,
  useNodesState,
  useEdgesState,
} from '@xyflow/react';

export default function Flow() {
  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const onConnect = useCallback(
    (connection) => {
      setEdges((oldEdges) => addEdge(connection, oldEdges));
    },
    [setEdges],
  );

  return <ReactFLow nodes={nodes} edges={edges} onConnect={onConnect} />;
}
```

## Signature

<PropsTable {...signature} />

## Notes

- If an edge with the same `target` and `source` already exists (and the same
  `targetHandle` and `sourceHandle` if those are set), then this util won't add
  a new edge even if the `id` property is different.

----
utils/get-outgoers.mdx
---
title: getOutgoers()
description:
  'This util is used to tell you what nodes, if any, are connected to the given node
  as the target of an edge.'
---

import { PropsTable } from '@/components/props-table';
import { signature } from '@/page-data/reference/utils/getOutgoers.ts';

# getOutgoers()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/graph.ts/#L64)

This util is used to tell you what nodes, if any, are connected to the given node
as the _target_ of an edge.

```ts
import { getOutgoers } from '@xyflow/react';

const nodes = [];
const edges = [];

const outgoers = getOutgoers(
  { id: '1', position: { x: 0, y: 0 }, data: { label: 'node' } },
  nodes,
  edges,
);
```

## Signature

<PropsTable {...signature} />

----
utils/get-bezier-path.mdx
---
title: getBezierPath()
description:
  'The getBezierPath util returns everything you need to render a bezier edge
  between two nodes.'
---

import { PropsTable } from '@/components/props-table';
import { signature } from '@/page-data/reference/utils/getBezierPath.ts';

# getBezierPath()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/edges/bezier-edge.ts/#L95)

The `getBezierPath` util returns everything you need to render a bezier edge
between two nodes.

```js
import { Position, getBezierPath } from '@xyflow/react';

const source = { x: 0, y: 20 };
const target = { x: 150, y: 100 };

const [path, labelX, labelY, offsetX, offsetY] = getBezierPath({
  sourceX: source.x,
  sourceY: source.y,
  sourcePosition: Position.Right,
  targetX: target.x,
  targetY: target.y,
  targetPosition: Position.Left,
});

console.log(path); //=> "M0,20 C75,20 75,100 150,100"
console.log(labelX, labelY); //=> 75, 60
console.log(offsetX, offsetY); //=> 75, 40
```

## Signature

<PropsTable {...signature} />

## Notes

- This function returns a tuple (aka a fixed-size array) to make it easier to
  work with multiple edge paths at once.

----
utils/get-viewport-for-bounds.mdx
---
title: getViewportForBounds()
description: 'This util returns the viewport for the given bounds.
  You might use this to pre-calculate the viewport for a given set of nodes on the
  server or calculate the viewport for the given bounds _without_ changing the
  viewport directly.'
---

import { Callout } from 'nextra/components';
import { PropsTable } from '@/components/props-table';
import { signature } from '@/page-data/reference/utils/getViewportForBounds.ts';

# getViewportForBounds()

[Source on Github](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/general.ts/#L170)

This util returns the viewport for the given bounds.
You might use this to pre-calculate the viewport for a given set of nodes on the
server or calculate the viewport for the given bounds _without_ changing the
viewport directly.

<Callout type="info" emoji="ℹ️">
  This function was previously called `getTransformForBounds`
</Callout>

```js
import { getViewportForBounds } from '@xyflow/react';

const { x, y, zoom } = getViewportForBounds(
  {
    x: 0,
    y: 0,
    width: 100,
    height: 100,
  },
  1200,
  800,
  0.5,
  2,
);
```

## Signature

<PropsTable {...signature} />

## Notes

- This is quite a low-level utility. You might want to look at the
  [`fitView`](/api-reference/types/react-flow-instance#fitview) or
  [`fitBounds`](/api-reference/types/react-flow-instance#fitbounds) methods for a more practical
  api.

----
utils/is-node.mdx
---
title: isNode()
description:
  'Test whether an object is useable as an Node. In TypeScript this is a type
  guard that will narrow the type of whatever you pass in to Node if it returns
  true.'
---

import { PropsTable } from '@/components/props-table';
import { signature } from '@/page-data/reference/utils/isNode.ts';

# isNode()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/graph.ts/#L49)

Test whether an object is useable as an [`Node`](/api-reference/types/node). In TypeScript
this is a type guard that will narrow the type of whatever you pass in to
[`Node`](/api-reference/types/node) if it returns `true`.

```js
import { isNode } from '@xyflow/react';

const node = {
  id: 'node-a',
  data: {
    label: 'node',
  },
  position: {
    x: 0,
    y: 0,
  },
};

if (isNode(node)) {
  // ..
}
```

## Signature

<PropsTable {...signature} />

----
utils/get-transform-for-bounds.mdx
---
title: getTransformForBounds()
description:
  'This util tells you what to set the viewport to in order to fit the given bounds.
  You might use this to pre-calculate the viewport for a given set of nodes on the
  server or calculate the viewport for the given bounds _without_ changing the
  viewport directly.'
---

import { Callout } from 'nextra/components';
import { PropsTable } from '@/components/props-table';
import { signature } from '@/page-data/reference/utils/getTransformForBounds.ts';

# getTransformForBounds()

[Source on Github](https://github.com/xyflow/xyflow/blob/v11/packages/core/src/utils/graph.ts/#L273)

<Callout type="warning" emoji="⚠️">
  This function is deprecated and will be removed in React Flow 12. Use
  [getViewportForBounds](/api-reference/utils/get-viewport-for-bounds) instead.
</Callout>

This util tells you what to set the viewport to in order to fit the given bounds.
You might use this to pre-calculate the viewport for a given set of nodes on the
server or calculate the viewport for the given bounds _without_ changing the
viewport directly.

```js
import { getTransformForBounds } from 'reactflow';

const transform = getTransformForBounds(
  {
    x: 0,
    y: 0,
    width: 100,
    height: 100,
  },
  1200,
  800,
  0.5,
  2,
);
```

## Signature

<PropsTable {...signature} />

## Notes

- This is quite a low-level utility. You might want to look at the
  [`fitView`](/api-reference/types/react-flow-instance#fitview) or
  [`fitBounds`](/api-reference/types/react-flow-instance#fitbounds) methods for a more practical
  api.
- This function is called get**Transform**... for historical reasons. Its return
  type represents a [`Viewport`](/api-reference/types/viewport) in tuple form.

----
utils/get-smooth-step-path.mdx
---
title: getSmoothStepPath()
description:
  'The getSmoothStepPath util returns everything you need to render a stepped path
  between two nodes. The borderRadius property can be used to choose how rounded
  the corners of those steps are.'
---

import { PropsTable } from '@/components/props-table';
import { signature } from '@/page-data/reference/utils/getSmoothStepPath.ts';

# getSmoothStepPath()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/edges/smoothstep-edge.ts/#L215)

The `getSmoothStepPath` util returns everything you need to render a stepped path
between two nodes. The `borderRadius` property can be used to choose how rounded
the corners of those steps are.

```js
import { Position, getSmoothStepPath } from '@xyflow/react';

const source = { x: 0, y: 20 };
const target = { x: 150, y: 100 };

const [path, labelX, labelY, offsetX, offsetY] = getSmoothStepPath({
  sourceX: source.x,
  sourceY: source.y,
  sourcePosition: Position.Right,
  targetX: target.x,
  targetY: target.y,
  targetPosition: Position.Left,
});

console.log(path); //=> "M0 20L20 20L 70,20Q 75,20 75,25L 75,95Q ..."
console.log(labelX, labelY); //=> 75, 60
console.log(offsetX, offsetY); //=> 75, 40
```

## Signature

<PropsTable {...signature} />

## Notes

- This function returns a tuple (aka a fixed-size array) to make it easier to
  work with multiple edge paths at once.
- You can set the `borderRadius` property to `0` to get a step edge path.

----
utils/apply-edge-changes.mdx
---
title: applyEdgeChanges()
description:
  "Various events on the ReactFlow component can produce an EdgeChange that
  describes how to update the edges of your flow in some way. If you don't need
  any custom behaviour, this util can be used to take an array of these changes
  and apply them to your edges."
---

import { PropsTable } from '@/components/props-table';
import { signature } from '@/page-data/reference/utils/applyEdgeChanges.ts';

# applyEdgeChanges()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/utils/changes.ts/#L167)

Various events on the [`<ReactFlow />`](/api-reference/react-flow) component can produce an
[`EdgeChange`](/api-reference/types/edge-change) that describes how to update the edges of your
flow in some way. If you don't need any custom behaviour, this util can be used to
take an array of these changes and apply them to your edges.

```js
import { useState, useCallback } from 'react';
import { ReactFlow, applyEdgeChanges } from '@xyflow/react';

export default function Flow() {
  const [nodes, setNodes] = useState([]);
  const [edges, setEdges] = useState([]);
  const onEdgesChange = useCallback(
    (changes) => {
      setEdges((oldEdges) => applyEdgeChanges(changes, oldEdges));
    },
    [setEdges],
  );

  return (
    <ReactFlow nodes={nodes} edges={edges} onEdgesChange={onEdgesChange} />
  );
}
```

## Signature

<PropsTable {...signature} />

## Notes

- If you don't need any custom behaviour, the [`useEdgesState`](/api-reference/hooks/use-edges-state)
  hook conviniently wraps this util and React's `useState` hook for you and might
  be simpler to use.

----
utils/apply-node-changes.mdx
---
title: applyNodeChanges()
description:
  "Various events on the ReactFlow component can produce an NodeChange that
  describes how to update the edges of your flow in some way. If you don't need
  any custom behaviour, this util can be used to take an array of these changes
  and apply them to your edges."
---

import { PropsTable } from '@/components/props-table';
import { signature } from '@/page-data/reference/utils/applyNodeChanges.ts';

# applyNodeChanges()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/utils/changes.ts/#L140)

Various events on the [`<ReactFlow />`](/api-reference/react-flow) component can produce an
[`NodeChange`](/api-reference/types/node-change) that describes how to update the edges of your
flow in some way. If you don't need any custom behaviour, this util can be used to
take an array of these changes and apply them to your edges.

```js
import { useState, useCallback } from 'react';
import { ReactFlow, applyNodeChanges } from '@xyflow/react';

export default function Flow() {
  const [nodes, setNodes] = useState([]);
  const [edges, setEdges] = useState([]);
  const onNodesChange = useCallback(
    (changes) => {
      setNodes((oldNodes) => applyNodeChanges(changes, oldNodes));
    },
    [setNodes],
  );

  return (
    <ReactFlow nodes={nodes} edges={edges} onNodesChange={onNodesChange} />
  );
}
```

## Signature

<PropsTable {...signature} />

## Notes

- If you don't need any custom behaviour, the [`useNodesState`](/api-reference/hooks/use-nodes-state)
  hook conviniently wraps this util and React's `useState` hook for you and might
  be simpler to use.

----
components/_meta.json
{
  "background": "<Background />",
  "base-edge": "<BaseEdge />",
  "control-button": "<ControlButton />",
  "controls": "<Controls />",
  "edge-label-renderer": "<EdgeLabelRenderer />",
  "edge-text": "<EdgeText />",
  "handle": "<Handle />",
  "minimap": "<MiniMap />",
  "node-resizer": "<NodeResizer />",
  "node-resize-control": "<NodeResizeControl />",
  "node-toolbar": "<NodeToolbar />",
  "panel": "<Panel />",
  "viewport-portal": "<ViewportPortal />"
}

----
components/background.mdx
---
title: The Background component
displayTitle: '<Background />'
description:
  'The Background component makes it convenient to render different types of
  backgrounds common in node-based UIs. It comes with three variants: lines,
  dots and cross.'
---

import { PropsTable } from '@/components/props-table';
import { backgroundProps } from '@/page-data/reference/components/Background.ts';

# &lt;Background />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/additional-components/Background/Background.tsx)

The `<Background />` component makes it convenient to render different types of
backgrounds common in node-based UIs. It comes with three variants: `lines`,
`dots` and `cross`.

```jsx
import { useState } from 'react';
import { ReactFlow, Background, BackgroundVariant } from '@xyflow/react';

export default function Flow() {
  return (
    <ReactFlow defaultNodes={[...]} defaultEdges={[...]}>
      <Background color="#ccc" variant={BackgroundVariant.Dots} />
    </ReactFlow>
  );
}
```

## Props

<PropsTable {...backgroundProps} />

## Examples

### Combining multiple backgrounds

It is possible to layer multiple `<Background />` components on top of one another
to create something more interesting. The following example shows how to render a
square grid accented every 10th line.

```tsx
import { ReactFlow,  Background, BackgroundVariant } from '@xyflow/react';

import '@xyflow/react/dist/style.css';

export default function Flow() {
  return (
    <ReactFlow defaultNodes={[...]} defaultEdges={[...]}>
      <Background
        id="1"
        gap={10}
        color="#f1f1f1"
        variant={BackgroundVariant.Lines}
      />

      <Background
        id="2"
        gap={100}
        color="#ccc"
        variant={BackgroundVariant.Lines}
      />
    </ReactFlow>
  );
}
```

## Notes

- When combining multiple `<Background />` components it's important to give each
  of them a unique `id` prop!

----
components/viewport-portal.mdx
---
title: The ViewportPortal component
displayTitle: '<ViewportPortal />'
description:
  '<ViewportPortal component can be used to add components to the same viewport of the flow where nodes and edges are rendered.
This is useful when you want to render your own components that are adhere to the same coordinate system as the nodes & edges and are also
affected by zooming and panning'
created_at: 2024-02-21
---

# &lt;ViewportPortal />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/components/ViewportPortal/index.tsx)

`<ViewportPortal />` component can be used to add components to the same viewport of the flow where nodes and edges are rendered.
This is useful when you want to render your own components that are adhere to the same coordinate system as the nodes & edges and are also
affected by zooming and panning

```jsx
import React from 'react';
import { ViewportPortal } from '@xyflow/react';

export default function () {
  return (
    <ViewportPortal>
      <div
        style={{ transform: 'translate(100px, 100px)', position: 'absolute' }}
      >
        This div is positioned at [100, 100] on the flow.
      </div>
    </ViewportPortal>
  );
}
```

----
components/base-edge.mdx
---
title: The BaseEdge component
displayTitle: '<BaseEdge />'
description:
  'The BaseEdge component gets used internally for all the edges. It can be used
  inside a custom edge and handles the invisible helper edge and the edge label
  for you.'
---

import { PropsTable } from '@/components/props-table';
import { baseEdgeProps } from '@/page-data/reference/components/BaseEdge.ts';

# &lt;BaseEdge />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/components/Edges/BaseEdge.tsx)

The `<BaseEdge />` component gets used internally for all the edges. It can be
used inside a custom edge and handles the invisible helper edge and the edge label
for you.

```jsx
import { BaseEdge } from '@xyflow/react';

export function CustomEdge({ sourceX, sourceY, targetX, targetY, ...props }) {
  const [edgePath] = getStraightPath({
    sourceX,
    sourceY,
    targetX,
    targetY,
  });

  return <BaseEdge path={edgePath} {...props} />;
}
```

## Props

<PropsTable {...baseEdgeProps} />

## Notes

- If you want to use an edge marker with the [`<BaseEdge />`](/api-reference/components/base-edge) component,
  you can pass the `markerStart` or `markerEnd` props passed to your custom edge
  through to the [`<BaseEdge />`](/api-reference/components/base-edge) component. You can see all the props
  passed to a custom edge by looking at the [`EdgeProps`](/api-reference/types/edge-props) type.

----
components/handle.mdx
---
title: The Handle component
displayTitle: '<Handle />'
description: 'The Handle component is used in your custom nodes to define connection points.'
---

import { PropsTable } from '@/components/props-table';
import { handleProps } from '@/page-data/reference/components/Handle.ts';

# &lt;Handle />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/components/Handle/index.tsx)

The `<Handle />` component is used in your [custom nodes](/learn/customization/custom-nodes)
to define connection points.

```jsx
import { Handle, Position } from '@xyflow/react';

export CustomNode = ({ data }) => {
  return (
    <>
      <div style={{ padding: '10px 20px' }}>
        {data.label}
      </div>

      <Handle type="target" position={Position.Left} />
      <Handle type="source" position={Position.Right} />
    </>
  );
};
```

## Props

For TypeScript users, the props type for the `<Handle />` component is exported
as `HandleProps`.

<PropsTable {...handleProps} />

## Examples

### Custom handle with validation

You can create your own custom handles by wrapping the `<Handle />` component.
This example shows a custom handle that only allows connections when the
connection source matches a given id.

```jsx
import { Handle, Position } from '@xyflow/react';

export const TargetHandleWithValidation = ({ position, source }) => (
  <Handle
    type="target"
    position={position}
    isValidConnection={(connection) => connection.source === source}
    onConnect={(params) => console.log('handle onConnect', params)}
    style={{ background: '#fff' }}
  />
);
```

### Style handles when connecting

The handle receives the additional class names `connecting` when the connection
line is above the handle and `valid` if the connection is valid. You can find an
example which uses these classes [here](/examples/interaction/validation).

### Multiple handles

If you need multiple source or target handles you can achieve this by creating a
custom node. Normally you just use the id of a node for the `source` or `target`
of an edge. If you have multiple source or target handles you need to pass an id
to these handles. These ids can be used by an edge with the `sourceHandle` and
`targetHandle` options, so that you can connect a specific handle. If you have a
node with an id = `1` and a handle with an id = `a` you can connect this handle
by using the node `source=1` and the `sourceHandle=a`.

### Dynamic handles

If you are programmatically changing the position or number of handles in your
custom node, you need to update the node internals with the
[`useUpdateNodeInternals`](/api-reference/hooks/use-update-node-internals) hook.

You can find an example of how to implement a custom node with multiple handles
in the [custom node guide](/learn/customization/custom-nodes) or in the
[custom node example](/examples/nodes/custom-node).

### Custom handle styles

Since the handle is a div, you can use CSS to style it or pass a style prop to
customize a Handle. You can see this in the
[Add Node On Edge Drop](/examples/nodes/add-node-on-edge-drop) and
[Simple Floating Edges](/examples/edges/simple-floating-edges) examples.

## Notes

- If you need to hide a handle for some reason, you must use `visibility: hidden`
  or `opacity: 0` instead of `display: none`. This is important because React
  Flow needs to calculate the dimensions of the handle to work properly and using
  `display: none` will report a width and height of 0!

----
components/minimap.mdx
---
title: The MiniMap component
displayTitle: '<MiniMap />'
description:
  'The MiniMap component can be used to render an overview of your flow. It renders
  each node as an SVG element and visualizes where the current viewport is in
  relation to the rest of the flow.'
---

import { Callout } from 'nextra/components';
import { PropsTable } from '@/components/props-table';
import {
  miniMapProps,
  miniMapNodeProps,
} from '@/page-data/reference/components/MiniMap.ts';

# &lt;MiniMap />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/additional-components/MiniMap/MiniMap.tsx)

The `<MiniMap />` component can be used to render an overview of your flow. It
renders each node as an SVG element and visualizes where the current viewport is
in relation to the rest of the flow.

```jsx
import { ReactFlow, MiniMap } from '@xyflow/react';

export default function Flow() {
  return (
    <ReactFlow nodes={[...]]} edges={[...]]}>
      <MiniMap nodeStrokeWidth={3} />
    </ReactFlow>
  );
}
```

## Props

For TypeScript users, the props type for the `<MiniMap />` component is exported
as `MiniMapProps`.

<PropsTable {...miniMapProps} />

## Examples

### Making the mini map interactive

By default, the mini map is non-interactive. To allow users to interact with the
viewport by panning or zooming the minimap, you can set either of the `zoomable`
or `pannable` (or both!) props to `true`.

```jsx
import { ReactFlow,  MiniMap } from '@xyflow/react';

export default function Flow() {
  return (
    <ReactFlow nodes={[...]]} edges={[...]]}>
      <MiniMap pannable zoomable />
    </ReactFlow>
  );
}
```

### Implement a custom mini map node

It is possible to pass a custom component to the `nodeComponent` prop to change
how nodes are rendered in the mini map. If you do this you **must** use only
SVG elements in your component if you want it to work correctly.

```jsx
import { ReactFlow,  MiniMap } from '@xyflow/react';

export default function Flow() {
  return (
    <ReactFlow nodes={[...]]} edges={[...]]}>
      <MiniMap nodeComponent={MiniMapNode} />
    </ReactFlow>
  );
}

function MiniMapNode({ x, y }) {
  return <circle cx={x} cy={y} r="50" />;
}
```

Check out the documentation for [`MiniMapNodeProps`](/api-reference/types/mini-map-node-props)
to see what props are passed to your custom component.

### Customising mini map node color

The `nodeColor`, `nodeStrokeColor`, and `nodeClassName` props can be a function
that takes a [`Node`](/api-reference/types/node) and computes a value for the prop. This can
be used to customise the appearance of each mini map node.

This example shows how to color each mini map node based on the node's type:

```jsx
import { ReactFlow,  MiniMap } from '@xyflow/react';

export default function Flow() {
  return (
    <ReactFlow nodes={[...]]} edges={[...]]}>
      <MiniMap nodeColor={nodeColor} />
    </ReactFlow>
  );
}

function nodeColor(node) {
  switch (node.type) {
    case 'input':
      return '#6ede87';
    case 'output':
      return '#6865A5';
    default:
      return '#ff0072';
  }
}
```

## Typescript

This component accepts a generic type argument of custom node types. See this
[section in our Typescript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.

```tsx
<MiniMap<CustomNodeType> nodeColor={nodeColor} />
```

----
components/edge-text.mdx
---
title: The EdgeText component
displayTitle: '<EdgeText />'
description:
  'You can use the EdgeText component as a helper component to display text within
  your custom edges.'
---

import { PropsTable } from '@/components/props-table';
import { edgeTextProps } from '@/page-data/reference/components/EdgeText.ts';

# &lt;EdgeText />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/components/Edges/EdgeText.tsx)

You can use the `<EdgeText />` component as a helper component to display text
within your custom edges.

```jsx
import { EdgeText } from '@xyflow/react';

export function CustomEdgeLabel({ label }) {
  return (
    <EdgeText
      x={100}
      y={100}
      label={label}
      labelStyle={{ fill: 'white' }}
      labelShowBg
      labelBgStyle={{ fill: 'red' }}
      labelBgPadding={[2, 4]}
      labelBgBorderRadius={2}
    />
  );
}
```

## Props

For TypeScript users, the props type for the `<EdgeText />` component is exported
as `EdgeTextProps`.

<PropsTable {...edgeTextProps} />

Additionally, you may also pass any standard React HTML attributes such as `onClick`,
`className` and so on.

----
components/node-toolbar.mdx
---
title: The NodeToolbar component
displayTitle: '<NodeToolbar />'
description:
  "The NodeToolbar component can render a toolbar or tooltip to one side of a
  custom node. This toolbar doesn't scale with the viewport so that the content
  is always visible."
---

import { PropsTable } from '@/components/props-table';
import { nodeToolbarProps } from '@/page-data/reference/components/NodeToolbar.ts';

# &lt;NodeToolbar />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/additional-components/NodeToolbar/NodeToolbar.tsx)

This component can render a toolbar or tooltip to one side of a custom node. This
toolbar doesn't scale with the viewport so that the content is always visible.

```jsx
import { memo } from 'react';
import { Handle, Position, NodeToolbar } from '@xyflow/react';

export CustomNode = ({ data }) => {
  return (
    <>
      <NodeToolbar isVisible={data.toolbarVisible} position={data.toolbarPosition}>
        <button>delete</button>
        <button>copy</button>
        <button>expand</button>
      </NodeToolbar>

      <div style={{ padding: '10px 20px' }}>
        {data.label}
      </div>

      <Handle type="target" position={Position.Left} />
      <Handle type="source" position={Position.Right} />
    </>
  );
};

export default memo(CustomNode);
```

## Props

For TypeScript users, the props type for the `<NodeToolbar />` component is exported
as `NodeToolbarProps`.

<PropsTable {...nodeToolbarProps} />

## Notes

- By default, the toolbar is only visible when a node is selected. If multiple
  nodes are selected it will not be visible to prevent overlapping toolbars or
  clutter. You can override this behavior by setting the `isVisible` prop to
  `true`.

----
components/node-resizer.mdx
---
title: The NodeResizer component
displayTitle: '<NodeResizer />'
description:
  'The NodeResizer component can be used to add a resize functionality to your
  nodes. It renders draggable controls around the node to resize in all directions.'
---

import ExampleViewer from '@/components/example-viewer';
import { PropsTable } from '@/components/props-table';
import { nodeResizerProps } from '@/page-data/reference/components/NodeResizer.ts';

# &lt;NodeResizer />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/additional-components/NodeResizer/NodeResizer.tsx)

The `<NodeResizer />` component can be used to add a resize functionality to your
nodes. It renders draggable controls around the node to resize in all directions.

```jsx
import { memo } from 'react';
import { Handle, Position, NodeResizer } from '@xyflow/react';

const ResizableNode = ({ data }) => {
  return (
    <>
      <NodeResizer minWidth={100} minHeight={30} />
      <Handle type="target" position={Position.Left} />
      <div style={{ padding: 10 }}>{data.label}</div>
      <Handle type="source" position={Position.Right} />
    </>
  );
};

export default memo(ResizableNode);
```

## Props

For TypeScript users, the props type for the `<NodeResizer />` component is exported
as `NodeResizerProps`.

<PropsTable {...nodeResizerProps} />

## Examples

Head over to the [example page](/examples/nodes/node-resizer) to see how this is done.

<ExampleViewer
  codePath="example-flows/NodeResizer"
  additionalFiles={[
    'ResizableNode.jsx',
    'ResizableNodeSelected.jsx',
    'CustomResizerNode.jsx',
  ]}
  showEditor={false}
  applyStyles={false}
  options={{ editorHeight: 400, editorWidthPercentage: 45, wrapContent: true }}
/>

### Custom Resize Controls

To build custom resize controls, you can use the [NodeResizeControl](/api-reference/components/node-resize-control) component and customize it.

## Notes

- Take a look at the docs for the [`NodeProps`](/api-reference/types/node-props) type or the
  guide on [custom nodes](/learn/customization/custom-nodes) to see how to
  implement your own nodes.

----
components/node-resize-control.mdx
---
title: The NodeResizeControl component
displayTitle: '<NodeResizeControl />'
description:
  'To create your own resizing UI, you can use the NodeResizeControl component
  where you can pass children (such as icons).'
---

import { PropsTable } from '@/components/props-table';
import { nodeResizeControlProps } from '@/page-data/reference/components/NodeResizeControl.ts';

# &lt;NodeResizeControl />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/additional-components/NodeResizer/NodeResizeControl.tsx)

To create your own resizing UI, you can use the `NodeResizeControl` component where you can pass children (such as icons).

## Props

For TypeScript users, the props type for the `<NodeResizeControl />` component is exported
as `ResizeControlProps`.

<PropsTable {...nodeResizeControlProps} />

----
components/controls.mdx
---
title: The Controls component
displayTitle: '<Controls />'
description:
  'The Controls component renders a small panel that contain convenient buttons
  to zoom in, zoom out, fit the view, and lock the viewport.'
---

import { PropsTable } from '@/components/props-table';
import { controlsProps } from '@/page-data/reference/components/Controls.ts';

# &lt;Controls />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/additional-components/Controls/Controls.tsx)

The `<Controls />` component renders a small panel that contain convenient
buttons to zoom in, zoom out, fit the view, and lock the viewport.

```tsx
import { ReactFlow,  Controls } from '@xyflow/react'

export default function Flow() {
  return (
    <ReactFlow nodes={[...]} edges={[...]}>
      <Controls />
    </ReactFlow>
  )
}
```

## Props

For TypeScript users, the props type for the `<Controls />` component is exported
as `ControlsProps`.

<PropsTable {...controlsProps} />

Additionally, the `<Controls />` component accepts any prop valid on a `<div />`
element.

## Notes

- To extend or customise the controls, you can use the [`<ControlButton />`](/api-reference/components/control-button)
  component

----
components/control-button.mdx
---
title: The ControlButton component
displayTitle: '<ControlButton />'
description:
  'You can add buttons to the control panel by using the ControlButton component
  and pass it as a child to the Controls component.'
---

# &lt;ControlButton />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/additional-components/ControlButton.tsx)

You can add buttons to the control panel by using the `<ControlButton />` component
and pass it as a child to the [`<Controls />`](/api-reference/components/controls) component.

```jsx
import { MagicWand } from '@radix-ui/react-icons'
import { ReactFlow,  Controls, ControlButton } from '@xyflow/react'

export default function Flow() {
  return (
    <ReactFlow nodes={[...]} edges={[...]}>
      <Controls>
        <ControlButton onClick={() => alert('Something magical just happened. ✨')}>
          <MagicWand />
        </ControlButton>
      </Controls>
    </ReactFlow>
  )
}
```

## Props

The `<ControlButton />` component accepts any prop valid on a HTML `<button />`
element.

----
components/edge-label-renderer.mdx
---
title: The EdgeLabelRenderer component
displayTitle: '<EdgeLabelRenderer />'
description:
  'Edges are SVG-based. If you want to render more complex labels you can use the
  EdgeLabelRenderer component to access a div based renderer. This component is a
  portal that renders the label in a div that is positioned on top of the edges.
  You can see an example usage of the component in the edge label renderer example.'
---

import { Callout } from 'nextra/components';
import { PropsTable } from '@/components/props-table';
import { edgeLabelRendererProps } from '@/page-data/reference/components/EdgeLabelRenderer.ts';

# &lt;EdgeLabelRenderer />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/components/EdgeLabelRenderer/index.tsx)

Edges are SVG-based. If you want to render more complex labels you can use the
`<EdgeLabelRenderer />` component to access a div based renderer. This component
is a portal that renders the label in a `<div />` that is positioned on top of
the edges. You can see an example usage of the component in the [edge label renderer](/examples/edges/edge-label-renderer)
example.

```jsx
import React from 'react';
import { getBezierPath, EdgeLabelRenderer, BaseEdge } from '@xyflow/react';

const CustomEdge = ({ id, data, ...props }) => {
  const [edgePath, labelX, labelY] = getBezierPath(props);

  return (
    <>
      <BaseEdge id={id} path={edgePath} />
      <EdgeLabelRenderer>
        <div
          style={{
            position: 'absolute',
            transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`,
            background: '#ffcc00',
            padding: 10,
            borderRadius: 5,
            fontSize: 12,
            fontWeight: 700,
          }}
          className="nodrag nopan"
        >
          {data.label}
        </div>
      </EdgeLabelRenderer>
    </>
  );
};

export default CustomEdge;
```

## Props

<PropsTable {...edgeLabelRendererProps} />

## Notes

- The `<EdgeLabelRenderer />` has no pointer events by default. If you want to
  add mouse interactions you need to set the style `pointerEvents: all` and add
  the `nopan` class on the label or the element you want to interact with.

----
components/panel.mdx
---
title: The Panel component
displayTitle: '<Panel />'
description:
  'The Panel component helps you position content above the viewport. It is used
  internally by the MiniMap and Controls components.'
---

import { PropsTable } from '@/components/props-table';
import { panelProps } from '@/page-data/reference/components/Panel.ts';

# &lt;Panel />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/components/Panel/index.tsx)

The `<Panel />` component helps you position content above the viewport. It is
used internally by the [`<MiniMap />`](/api-reference/components/minimap) and [`<Controls />`](/api-reference/components/controls)
components.

```jsx
import { ReactFlow, Background, Panel } from '@xyflow/react';

export default function Flow() {
  return (
    <ReactFlow nodes={[...]} fitView>
      <Panel position="top-left">top-left</Panel>
      <Panel position="top-center">top-center</Panel>
      <Panel position="top-right">top-right</Panel>
      <Panel position="bottom-left">bottom-left</Panel>
      <Panel position="bottom-center">bottom-center</Panel>
      <Panel position="bottom-right">bottom-right</Panel>
    </ReactFlow>
  );
}
```

## Props

For TypeScript users, the props type for the `<Panel />` component is exported
as `PanelProps`.

<PropsTable {...panelProps} />

Additionally, the `<Panel />` component accepts all props of the HTML `<div />`
element.

----
hooks/_meta.json
{
  "use-connection": "useConnection()",
  "use-edges": "useEdges()",
  "use-edges-state": "useEdgesState()",
  "use-handle-connections": "useHandleConnections()",
  "use-key-press": "useKeyPress()",
  "use-node-id": "useNodeId()",
  "use-nodes": "useNodes()",
  "use-nodes-data": "useNodesData()",
  "use-nodes-initialized": "useNodesInitialized()",
  "use-nodes-state": "useNodesState()",
  "use-on-selection-change": "useOnSelectionChange()",
  "use-on-viewport-change": "useOnViewportChange()",
  "use-react-flow": "useReactFlow()",
  "use-store": "useStore()",
  "use-store-api": "useStoreApi()",
  "use-update-node-internals": "useUpdateNodeInternals()",
  "use-viewport": "useViewport()"
}

----
hooks/use-nodes-data.mdx
---
title: useNodesData()
description: 'With this hook you can subscribe to changes of a node data of a specific node.'
created_at: 2024-07-09
---

import { PropsTable } from '@/components/props-table';
import { signature } from '@/page-data/reference/hooks/useNodesData.ts';

# useNodesData()

[Source on GitHub](https://github.com/xyflow/xyflow/packages/core/src/hooks/useHandleConnections.ts)

This hook lets you subscribe to changes of a specific nodes `data` object.

```jsx
import { useNodesData } from '@xyflow/react';

export default function () {
  const nodeData = useNodesData('nodeId-1');

  const nodesData = useNodesData(['nodeId-1', 'nodeId-2']);
}
```

## Signature

<PropsTable {...signature} />

## Typescript

This hook accepts a generic type argument of custom node types. See this
[section in our Typescript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.

```tsx
const nodesData = useNodesData<NodesType>(['nodeId-1', 'nodeId-2']);
```

----
hooks/use-viewport.mdx
---
title: useViewport
description:
  'The useViewport hook is a convenient way to read the current state of the
  Viewport in a component. Components that use this hook will re-render whenever
  the viewport changes.'
---

import { PropsTable } from '@/components/props-table';
import { signature } from '@/page-data/reference/hooks/useViewport.ts';

# useViewport

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useViewport.ts)

The `useViewport` hook is a convenient way to read the current state of the
[`Viewport`](/api-reference/types/viewport) in a component. Components that use this hook
will re-render **whenever the viewport changes**.

```jsx
import { useViewport } from '@xyflow/react';

export default function ViewportDisplay() {
  const { x, y, zoom } = useViewport();

  return (
    <div>
      <p>
        The viewport is currently at ({x}, {y}) and zoomed to {zoom}.
      </p>
    </div>
  );
}
```

## Signature

<PropsTable {...signature} />

## Notes

- This hook can only be used in a component that is a child of a
  [`<ReactFlowProvider />`](/api-reference/react-flow-provider) or a
  [`<ReactFlow />`](/api-reference/react-flow) component.

----
hooks/use-node-id.mdx
---
title: useNodeId
description:
  "You can use this hook to get the id of the node it is used inside. It is useful
  if you need the node's id deeper in the render tree but don't want to manually
  drill down the id as a prop."
---

import { PropsTable } from '@/components/props-table';
import { signature } from '@/page-data/reference/hooks/useNodeId.ts';

# useNodeId

[Source on Github](https://github.com/xyflow/xyflow/blob/v11/packages/core/src/contexts/NodeIdContext.ts/#L7)

You can use this hook to get the id of the node it is used inside. It is useful
if you need the node's id deeper in the render tree but don't want to manually
drill down the id as a prop.

```js
import { useNodeId } from '@xyflow/react';

export default function CustomNode() {
  return (
    <div>
      <span>This node has an id of </span>
      <NodeIdDisplay />
    </div>
  );
}

function NodeIdDisplay() {
  const nodeId = useNodeId();

  return <span>{nodeId}</span>;
}
```

## Signature

<PropsTable {...signature} />

## Notes

- This hook should only be used within a custom node or its children.

----
hooks/use-on-viewport-change.mdx
---
title: useOnViewportChange
description:
  'The useOnViewportChange hook lets you listen for changes to the viewport such
  as panning and zooming. You can provide a callback for each phase of a viewport
  change: onStart, onChange, and onEnd.'
---

import { PropsTable } from '@/components/props-table';
import { signature } from '@/page-data/reference/hooks/useOnViewportChange.ts';

# useOnViewportChange

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useOnViewportChange.ts)

The `useOnViewportChange` hook lets you listen for changes to the viewport such
as panning and zooming. You can provide a callback for each phase of a viewport
change: `onStart`, `onChange`, and `onEnd`.

```jsx
import { useCallback } from 'react';
import { useOnViewportChange } from '@xyflow/react';

function ViewportChangeLogger() {
  useOnViewportChange({
    onStart: (viewport: Viewport) => console.log('start', viewport),
    onChange: (viewport: Viewport) => console.log('change', viewport),
    onEnd: (viewport: Viewport) => console.log('end', viewport),
  });

  return null;
}
```

## Signature

<PropsTable {...signature} />

## Notes

- This hook can only be used in a component that is a child of a
  [`<ReactFlowProvider />`](/api-reference/react-flow-provider) or a
  [`<ReactFlow />`](/api-reference/react-flow) component.

----
hooks/use-nodes.mdx
---
title: useNodes
description:
  'This hook returns an array of the current nodes. Components that use this hook
  will re-render whenever any node changes, including when a node is selected or
  moved.'
---

import { PropsTable } from '@/components/props-table';
import { signature } from '@/page-data/reference/hooks/useNodes.ts';

# useNodes

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useNodes.ts)

This hook returns an array of the current nodes. Components that use this hook
will re-render **whenever any node changes**, including when a node is selected
or moved.

```jsx
import { useNodes } from '@xyflow/react';

export default function () {
  const nodes = useNodes();

  return <div>There are currently {nodes.length} nodes!</div>;
}
```

## Signature

<PropsTable {...signature} />

## Typescript

This hook accepts a generic type argument of custom node types. See this
[section in our Typescript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.

```tsx
const nodes = useNodes<CustomNodeType>();
```

## Notes

- Relying on `useNodes` unecessarily can be a common cause of performance
  issues. Whenever any node changes, this hook will cause the component to
  re-render. Often we actually care about something more specific, like when
  the _number_ of nodes changes: where possible try to use
  [`useStore`](/api-reference/hooks/use-store) instead.

----
hooks/use-connection.mdx
---
title: useConnection
description:
  The useConnection hook returns the current connection when there is an active
  connection interaction. If no connection interaction is active, it returns null
  for every property. A typical use case for this hook is to colorize handles
  based on a certain condition (e.g. if the connection is valid or not).
created_at: 2024-07-09
---

import { PropsTable } from '@/components/props-table';
import { signature } from '@/page-data/reference/hooks/useConnection.ts';

# useConnection

[Source on GitHub]()

The `useConnection` hook returns the current connection state when there is an active connection interaction. If no connection interaction is active, it returns `null` for every property. A typical use case for this hook is to colorize handles based on a certain condition (e.g. if the connection is valid or not).

```tsx
import { useConnection } from '@xyflow/react';

export default function () {
  const connection = useConnection();

  return (
    {connection &&
      <div>
        Someone is trying to make a connection from {connection.fromNode} to this one.
      </div>
    }
    {!connection &&
      <div>
        There are currently no incoming connections!
      </div>
    }
    )
}
```

## Signature

<PropsTable {...signature} />

----
hooks/use-nodes-state.mdx
---
title: useNodesState
description:
  "This hook makes it easy to prototype a controlled flow where you manage the
  state of nodes and edges outside the ReactFlowInstance. You can think of it
  like React's `useState` hook with an additional helper callback."
---

import { PropsTable } from '@/components/props-table';
import { signature } from '@/page-data/reference/hooks/useNodesState.ts';

# useNodesState

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useNodesEdgesState.ts)

This hook makes it easy to prototype a controlled flow where you manage the
state of nodes and edges outside the `ReactFlowInstance`. You can think of it
like React's `useState` hook with an additional helper callback.

```jsx
import { ReactFlow, useNodesState, useEdgesState } from '@xyflow/react';

const initialNodes = [];
const initialEdges = [];

export default function () {
  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);
  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);

  return (
    <ReactFlow
      nodes={nodes}
      edges={edges}
      onNodesChange={onNodesChange}
      onEdgesChange={onEdgesChange}
    />
  );
}
```

## Signature

<PropsTable {...signature} />

## Typescript

This hook accepts a generic type argument of custom node types. See this
[section in our Typescript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.

```tsx
const nodes = useNodesState<CustomNodeType>();
```

## Notes

- This hook was created to make prototyping easier and our documentation
  examples clearer. Although it is OK to use this hook in production, in
  practice you may want to use a more sophisticated state management solution
  like [Zustand](https://reactflow.dev/docs/guides/state-management/) instead.

----
hooks/use-store-api.mdx
---
title: useStoreApi
description:
  'In some cases, you might need to access the store directly. This hook returns
  the store object which can be used on demand to access the state or dispatch
  actions.'
---

import { Callout } from 'nextra/components';
import { PropsTable } from '@/components/props-table';
import { signature } from '@/page-data/reference/hooks/useStoreApi.ts';

# useStoreApi

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useStore.ts)

In some cases, you might need to access the store directly. This hook returns the store object which can be used on demand to access the state or dispatch actions.

<Callout type="info">
  This hook should only be used if there is no other way to access the internal
  state. For many of the common use cases, there are dedicated hooks available
  such as [`useReactFlow`](/api-reference/hooks/use-react-flow),
  [`useViewport`](/api-reference/hooks/use-react-flow), etc.
</Callout>

```tsx
import { useState, useCallback } from 'react';
import { ReactFlow, useStoreApi } from '@xyflow/react';

const NodesLengthDisplay = () => {
  const [nodesLength, setNodesLength] = useState(0);
  const store = useStoreApi();

  const onClick = useCallback(() => {
    const { nodes } = store.getState();
    const length = nodes.length || 0;

    setNodesLength(length);
  }, [store]);

  return (
    <div>
      <p>The current number of nodes is: {nodesLength}</p>
      <button onClick={onClick}>Update node length.</button>
    </div>
  );
};

function Flow() {
  return (
    <ReactFlow nodes={nodes}>
      <NodesLengthLogger />
    </ReactFlow>
  );
}
```

This example computes the number of nodes in the flow _on-demand_. This is in
contrast to the example in the [`useStore`](/api-reference/hooks/use-store) hook that re-renders
the component whenever the number of nodes changes.

Choosing whether to calculate values on-demand or to subscribe to changes as they
happen is a bit of a balancing act. On the one hand, putting too many heavy
calculations in an event handler can make your app feel sluggish or unresponsive.
On the other hand, computing values eagerly can lead to slow or unnecessary
re-renders.

We make both this hook and [`useStore`](/api-reference/hooks/use-store) available so that you can
choose the approach that works best for your use-case.

## Signature

<PropsTable {...signature} />

## Typescript

This hook accepts a generic type argument of custom node & edge types. See this
[section in our Typescript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.

```tsx
const store = useStoreApi<CustomNodeType, CustomEdgeType>();
```

----
hooks/use-on-selection-change.mdx
---
title: useOnSelectionChange
description:
  'This hook lets you listen for changes to both node and edge selection. As the
  name implies, the callback you provide will be called whenever the selection of
  either nodes or edges changes.'
---

import { Callout } from 'nextra/components';
import { PropsTable } from '@/components/props-table';
import { signature } from '@/page-data/reference/hooks/useOnSelectionChange.ts';

# useOnSelectionChange

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useOnSelectionChange.ts)

This hook lets you listen for changes to both node and edge selection. As the
name implies, the callback you provide will be called whenever the selection of
_either_ nodes or edges changes.

<Callout type="info">
  You need to memoize the passed `onChange` handler, otherwise the hook will not
  work correctly.
</Callout>

```jsx
import { useState } from 'react';
import { ReactFlow, useOnSelectionChange } from '@xyflow/react';

function SelectionDisplay() {
  const [selectedNodes, setSelectedNodes] = useState([]);
  const [selectedEdges, setSelectedEdges] = useState([]);

  // the passed handler has to be memoized, otherwise the hook will not work correctly
  const onChange = useCallback(({ nodes, edges }) => {
    setSelectedNodes(nodes.map((node) => node.id));
    setSelectedEdges(edges.map((edge) => edge.id));
  }, []);

  useOnSelectionChange({
    onChange,
  });

  return (
    <div>
      <p>Selected nodes: {selectedNodes.join(', ')}</p>
      <p>Selected edges: {selectedEdges.join(', ')}</p>
    </div>
  );
}
```

## Signature

<PropsTable {...signature} />

## Notes

- This hook can only be used in a component that is a child of a
  [`<ReactFlowProvider />`](/api-reference/react-flow-provider) or a
  [`<ReactFlow />`](/api-reference/react-flow) component.

----
hooks/use-handle-connections.mdx
---
title: useHandleConnections()
description:
  'This hook returns an array of the current edges. Components that use this hook
  will re-render whenever any edge changes.'
created_at: 2024-07-09
---

import { PropsTable } from '@/components/props-table';
import { signature } from '@/page-data/reference/hooks/useHandleConnections.ts';

# useHandleConnections

[Source on GitHub](https://github.com/xyflow/xyflow/packages/core/src/hooks/useHandleConnections.ts)

This hook returns an array connections on a specific handle or handle type.

```jsx
import { useHandleConnections } from '@xyflow/react';

export default function () {
  const connections = useHandleConnections({ type: 'target', id: 'my-handle' });

  return (
    <div>There are currently {connections.length} incoming connections!</div>
  );
}
```

## Signature

<PropsTable {...signature} />

----
hooks/use-store.mdx
---
title: useStore
description:
  'This hook can be used to subscribe to internal state changes of the React Flow
  component. The useStore hook is re-exported from the Zustand state management
  library, so you should check out their docs for more details.'
---

import { Callout } from 'nextra/components';
import { PropsTable } from '@/components/props-table';
import { signature } from '@/page-data/reference/hooks/useStore.ts';

# useStore

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useStore.ts)

This hook can be used to subscribe to internal state changes of the React Flow
component. The `useStore` hook is re-exported from the [Zustand](https://github.com/pmndrs/zustand)
state management library, so you should check out their docs for more details.

<Callout type="info">
  This hook should only be used if there is no other way to access the internal
  state. For many of the common use cases, there are dedicated hooks available
  such as [`useReactFlow`](/api-reference/hooks/use-react-flow),
  [`useViewport`](/api-reference/hooks/use-viewport), etc.
</Callout>

```jsx
import { ReactFlow, useStore } from '@xyflow/react';

const nodesLengthSelector = (state) =>
  state.nodes.length || 0;

const NodesLengthDisplay = () => {
  const nodesLength = useStore(nodesLengthSelector);

  return <div>The current number of nodes is: {nodesLength}</div>;
};

function Flow() {
  return (
    <ReactFlow nodes={[...]}>
      <NodesLengthDisplay />
    </ReactFlow>
  );
}
```

This example computes the number of nodes eagerly. Whenever the number of nodes
in the flow changes, the `<NodesLengthDisplay />` component will re-render. This
is in contrast to the example in the [`useStoreApi`](/api-reference/hooks/use-store-api) hook that only
computes the number of nodes when a button is clicked.

Choosing whether to calculate values on-demand or to subscribe to changes as they
happen is a bit of a balancing act. On the one hand, putting too many heavy
calculations in an event handler can make your app feel sluggish or unresponsive.
On the other hand, computing values eagerly can lead to slow or unnecessary
re-renders.

We make both this hook and [`useStoreApi`](/api-reference/hooks/use-store-api) available so that you
can choose the approach that works best for your use-case.

## Signature

<PropsTable {...signature} />

## Examples

### Triggering store actions

You can manipulate the internal React Flow state by triggering internal actions
through the `useStore` hook. These actions are already used internally throughout
the library, but you can also use them to implement custom functionality.

```jsx
import { useStore } from '@xyflow/react';

const setMinZoomSelector = (state) => state.setMinZoom;

function MinZoomSetter() {
  const setMinZoom = useStore(setMinZoomSelector);

  return <button onClick={() => setMinZoom(6)}>set min zoom</button>;
}
```

## Typescript

This hook can be typed by typing the selector function. See this
[section in our Typescript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.

```tsx
const nodes = useStore((s: ReactFlowState<CustomNodeType>) => ({
  nodes: s.nodes,
}));
```

## Notes

- You should define your store selector function _outside_ of the component that
  uses it, or use React's `useCallback` hook to memoize the function. Not doing
  this can incur a slight performance penalty.

----
hooks/use-react-flow.mdx
---
title: useReactFlow
description:
  'This hook returns a ReactFlowInstance that can be used to update nodes and
  edges, manipulate the viewport, or query the current state of the flow.'
---

import { PropsTable } from '@/components/props-table';
import {
  nodesAndEdgesFields,
  intersectionFields,
  viewportFields,
} from '@/page-data/reference/types/ReactFlowInstance.fields.ts';

# useReactFlow

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useReactFlow.ts)

This hook returns a [`ReactFlowInstance`](/api-reference/types/react-flow-instance) that can
be used to update nodes and edges, manipulate the viewport, or query the current
state of the flow.

```jsx
import { useCallback, useState } from 'react';
import { useReactFlow } from '@xyflow/react';

export function NodeCounter() {
  const reactFlow = useReactFlow();
  const [count, setCount] = useState(0);
  const countNodes = useCallback(() => {
    setCount(reactFlow.getNodes().length);
    // you need to pass it as a dependency if you are using it with useEffect or useCallback
    // because at the first render, it's not initialized yet and some functions might not work.
  }, [reactFlow]);

  return (
    <div>
      <button onClick={countNodes}>Update count</button>
      <p>There are {count} nodes in the flow.</p>
    </div>
  );
}
```

## Signature

### Nodes and edges

<PropsTable {...nodesAndEdgesFields} />

### Intersections

<PropsTable {...intersectionFields} />

### Viewport fields

<PropsTable {...viewportFields} />

## Typescript

This hook accepts a generic type argument of custom node & edge types. See this
[section in our Typescript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.

```tsx
const reactFlow = useReactFlow<CustomNodeType, CustomEdgeType>();
```

## Notes

- This hook can only be used in a component that is a child of a
  [`<ReactFlowProvider />`](/api-reference/react-flow-provider) or a
  [`<ReactFlow />`](/api-reference/react-flow) component.
- Unlike [`useNodes`](/api-reference/hooks/use-nodes) or [`useEdges`](/api-reference/hooks/use-edges), this hook won't
  cause your component to re-render when state changes. Instead, you can query
  the state when you need it by using methods on the [`ReactFlowInstance`](/api-reference/types/react-flow-instance)
  this hook returns.

----
hooks/use-key-press.mdx
---
title: useKeyPress
description:
  'This hook lets you listen for specific key codes and tells you whether they are
  currently pressed or not.'
---

import { PropsTable } from '@/components/props-table';
import { signature } from '@/page-data/reference/hooks/useKeyPress.ts';

# useKeyPress

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useKeyPress.ts)

This hook lets you listen for specific key codes and tells you whether they are
currently pressed or not.

```jsx
import { useKeyPress } from '@xyflow/react';

export default function () {
  const spacePressed = useKeyPress('Space');
  const cmdAndSPressed = useKeyPress(['Meta+s', 'Strg+s']);

  return (
    <div>
      {spacePressed && <p>Space pressed!</p>}
      {cmdAndSPressed && <p>Cmd + S pressed!</p>}
    </div>
  );
}
```

## Signature

<PropsTable {...signature} />

## Notes

- This hook does not rely on a `ReactFlowInstance` so you are free to use it
  anywhere in your app!

----
hooks/use-update-node-internals.mdx
---
title: useUpdateNodeInternals
description:
  "When you programmatically add or remove handles to a node or update a node's
  handle position, you need to let React Flow know about it using this hook. This
  will update the internal dimensions of the node and properly reposition handles
  on the canvas if necessary."
---

import { PropsTable } from '@/components/props-table';
import { signature } from '@/page-data/reference/hooks/useUpdateNodeInternals.ts';

# useUpdateNodeInternals

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useUpdateNodeInternals.ts)

When you programmatically add or remove handles to a node or update a node's
handle position, you need to let React Flow know about it using this hook. This
will update the internal dimensions of the node and properly reposition handles
on the canvas if necessary.

```jsx
import { useCallback, useState } from 'react';
import { Handle, useUpdateNodeInternals } from '@xyflow/react';

export default function RandomHandleNode({ id }) {
  const updateNodeInternals = useUpdateNodeInternals();
  const [handleCount, setHandleCount] = useState(0);
  const randomizeHandleCount = useCallback(() => {
    setHandleCount(Math.floor(Math.random() * 10));
    updateNodeInternals(id);
  }, [id, updateNodeInternals]);

  return (
    <>
      {Array.from({ length: handleCount }).map((_, index) => (
        <Handle
          key={index}
          type="target"
          position="left"
          id={`handle-${index}`}
        />
      ))}

      <div>
        <button onClick={randomizeHandleCount}>Randomize handle count</button>
        <p>There are {handleCount} handles on this node.</p>
      </div>
    </>
  );
}
```

## Signature

<PropsTable {...signature} />

## Notes

- This hook can only be used in a component that is a child of a
  [`<ReactFlowProvider />`](/api-reference/react-flow-provider) or a
  [`<ReactFlow />`](/api-reference/react-flow) component.

----
hooks/use-edges.mdx
---
title: useEdges
description:
  'This hook returns an array of the current edges. Components that use this hook
  will re-render whenever any edge changes.'
---

import { PropsTable } from '@/components/props-table';
import { signature } from '@/page-data/reference/hooks/useEdges.ts';

# useEdges

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useEdges.ts)

This hook returns an array of the current edges. Components that use this hook
will re-render **whenever any edge changes**.

```jsx
import { useEdges } from '@xyflow/react';

export default function () {
  const edges = useEdges();

  return <div>There are currently {edges.length} edges!</div>;
}
```

## Signature

<PropsTable {...signature} />

## Typescript

This hook accepts a generic type argument of custom edge types. See this
[section in our Typescript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.

```tsx
const nodes = useEdges<CustomEdgeType>();
```

## Notes

- Relying on `useEdges` unecessarily can be a common cause of performance
  issues. Whenever any edge changes, this hook will cause the component to
  re-render. Often we actually care about something more specific, like when
  the _number_ of edges changes: where possible try to use
  [`useStore`](/api-reference/hooks/use-store) instead.

----
hooks/use-edges-state.mdx
---
title: useEdgesState
description:
  "This hook makes it easy to prototype a controlled flow where you manage the
  state of nodes and edges outside the ReactFlowInstance. You can think of it
  like React's `useState` hook with an additional helper callback."
---

import { PropsTable } from '@/components/props-table';
import { signature } from '@/page-data/reference/hooks/useEdgesState.ts';

# useEdgesState

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useNodesEdgesState.ts)

This hook makes it easy to prototype a controlled flow where you manage the
state of nodes and edges outside the `ReactFlowInstance`. You can think of it
like React's `useState` hook with an additional helper callback.

```jsx
import { ReactFlow, useNodesState, useEdgesState } from '@xyflow/react';

const initialNodes = [];
const initialEdges = [];

export default function () {
  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);
  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);

  return (
    <ReactFlow
      nodes={nodes}
      edges={edges}
      onNodesChange={onNodesChange}
      onEdgesChange={onEdgesChange}
    />
  );
}
```

## Signature

<PropsTable {...signature} />

## Typescript

This hook accepts a generic type argument of custom edge types. See this
[section in our Typescript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.

```tsx
const nodes = useEdgesState<CustomEdgeType>();
```

## Notes

- This hook was created to make prototyping easier and our documentation
  examples clearer. Although it is OK to use this hook in production, in
  practice you may want to use a more sophisticated state management solution
  like [Zustand](https://reactflow.dev/docs/guides/state-management/) instead.

----
hooks/use-nodes-initialized.mdx
---
title: useNodesInitialized
description:
  'This hook tells you whether all the nodes in a flow have been measured and given
  a width and height. When you add a node to the flow, this hook will return
  false and then true again once the node has been measured.'
---

import { PropsTable } from '@/components/props-table';
import { signature } from '@/page-data/reference/hooks/useNodesInitialized.ts';

# useNodesInitialized

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useNodesInitialized.ts)

This hook tells you whether all the nodes in a flow have been measured and given
a width and height. When you add a node to the flow, this hook will return
`false` and then `true` again once the node has been measured.

```jsx
import { useReactFlow, useNodesInitialized } from '@xyflow/react';
import { useEffect, useState } from 'react';

const options = {
  includeHiddenNodes: false,
};

export default function useLayout() {
  const { getNodes } = useReactFlow();
  const nodesInitialized = useNodesInitialized(options);
  const [layoutedNodes, setLayoutedNodes] = useState(getNodes());

  useEffect(() => {
    if (nodesInitialized) {
      setLayoutedNodes(yourLayoutingFunction(getNodes()));
    }
  }, [nodesInitialized]);

  return layoutedNodes;
}
```

## Signature

<PropsTable {...signature} />

## Notes

- This hook always returns `false` if the internal nodes array is empty.

--END--